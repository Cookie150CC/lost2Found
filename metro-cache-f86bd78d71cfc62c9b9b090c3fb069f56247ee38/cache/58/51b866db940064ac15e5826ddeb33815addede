__d(function (global, _require, module, exports, _dependencyMap) {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
        value: true
    });

    function _interopDefault(ex) {
        return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
    }

    var firebase = _interopDefault(_require(_dependencyMap[0], "@firebase/app"));

    var logger = _require(_dependencyMap[1], "@firebase/logger");

    var tslib_1 = _require(_dependencyMap[2], "tslib");

    var webchannelWrapper = _require(_dependencyMap[3], "@firebase/webchannel-wrapper");

    var SDK_VERSION = firebase.SDK_VERSION;
    var logClient = new logger.Logger('@firebase/firestore');
    var LogLevel;

    (function (LogLevel) {
        LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
        LogLevel[LogLevel["ERROR"] = 1] = "ERROR";
        LogLevel[LogLevel["SILENT"] = 2] = "SILENT";
    })(LogLevel || (LogLevel = {}));

    function getLogLevel() {
        if (logClient.logLevel === logger.LogLevel.DEBUG) {
            return LogLevel.DEBUG;
        } else if (logClient.logLevel === logger.LogLevel.SILENT) {
            return LogLevel.SILENT;
        } else {
            return LogLevel.ERROR;
        }
    }

    function setLogLevel(newLevel) {
        switch (newLevel) {
            case LogLevel.DEBUG:
                logClient.logLevel = logger.LogLevel.DEBUG;
                break;

            case LogLevel.ERROR:
                logClient.logLevel = logger.LogLevel.ERROR;
                break;

            case LogLevel.SILENT:
                logClient.logLevel = logger.LogLevel.SILENT;
                break;

            default:
                logClient.error("Firestore (" + SDK_VERSION + "): Invalid value passed to `setLogLevel`");
        }
    }

    function debug(tag, msg) {
        var obj = [];

        for (var _i = 2; _i < arguments.length; _i++) {
            obj[_i - 2] = arguments[_i];
        }

        if (logClient.logLevel <= logger.LogLevel.DEBUG) {
            var args = obj.map(argToString);
            logClient.debug.apply(logClient, ["Firestore (" + SDK_VERSION + ") [" + tag + "]: " + msg].concat(args));
        }
    }

    function error(msg) {
        var obj = [];

        for (var _i = 1; _i < arguments.length; _i++) {
            obj[_i - 1] = arguments[_i];
        }

        if (logClient.logLevel <= logger.LogLevel.ERROR) {
            var args = obj.map(argToString);
            logClient.error.apply(logClient, ["Firestore (" + SDK_VERSION + "): " + msg].concat(args));
        }
    }

    function argToString(obj) {
        if (typeof obj === 'string') {
            return obj;
        } else {
            var platform = PlatformSupport.getPlatform();

            try {
                return platform.formatJSON(obj);
            } catch (e) {
                return obj;
            }
        }
    }

    function fail(failure) {
        var message = "FIRESTORE (" + SDK_VERSION + ") INTERNAL ASSERTION FAILED: " + failure;
        error(message);
        throw new Error(message);
    }

    function assert(assertion, message) {
        if (!assertion) {
            fail(message);
        }
    }

    var PlatformSupport = function () {
        function PlatformSupport() {}

        PlatformSupport.setPlatform = function (platform) {
            if (PlatformSupport.platform) {
                fail('Platform already defined');
            }

            PlatformSupport.platform = platform;
        };

        PlatformSupport.getPlatform = function () {
            if (!PlatformSupport.platform) {
                fail('Platform not set');
            }

            return PlatformSupport.platform;
        };

        return PlatformSupport;
    }();

    function emptyByteString() {
        return PlatformSupport.getPlatform().emptyByteString;
    }

    var Code = {
        OK: 'ok',
        CANCELLED: 'cancelled',
        UNKNOWN: 'unknown',
        INVALID_ARGUMENT: 'invalid-argument',
        DEADLINE_EXCEEDED: 'deadline-exceeded',
        NOT_FOUND: 'not-found',
        ALREADY_EXISTS: 'already-exists',
        PERMISSION_DENIED: 'permission-denied',
        UNAUTHENTICATED: 'unauthenticated',
        RESOURCE_EXHAUSTED: 'resource-exhausted',
        FAILED_PRECONDITION: 'failed-precondition',
        ABORTED: 'aborted',
        OUT_OF_RANGE: 'out-of-range',
        UNIMPLEMENTED: 'unimplemented',
        INTERNAL: 'internal',
        UNAVAILABLE: 'unavailable',
        DATA_LOSS: 'data-loss'
    };

    var FirestoreError = function (_super) {
        tslib_1.__extends(FirestoreError, _super);

        function FirestoreError(code, message) {
            var _this = _super.call(this, message) || this;

            _this.code = code;
            _this.message = message;
            _this.name = 'FirebaseError';

            _this.toString = function () {
                return _this.name + ": [code=" + _this.code + "]: " + _this.message;
            };

            return _this;
        }

        return FirestoreError;
    }(Error);

    function makeConstructorPrivate(cls, optionalMessage) {
        function PublicConstructor() {
            var error = 'This constructor is private.';

            if (optionalMessage) {
                error += ' ';
                error += optionalMessage;
            }

            throw new FirestoreError(Code.INVALID_ARGUMENT, error);
        }

        PublicConstructor.prototype = cls.prototype;

        for (var staticProperty in cls) {
            if (cls.hasOwnProperty(staticProperty)) {
                PublicConstructor[staticProperty] = cls[staticProperty];
            }
        }

        return PublicConstructor;
    }

    function contains(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
    }

    function defaulted(value, defaultValue) {
        return value !== undefined ? value : defaultValue;
    }

    function forEachNumber(obj, fn) {
        for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                var num = Number(key);

                if (!isNaN(num)) {
                    fn(num, obj[key]);
                }
            }
        }
    }

    function values(obj) {
        var vs = [];
        forEach(obj, function (_, v) {
            return vs.push(v);
        });
        return vs;
    }

    function forEach(obj, fn) {
        for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                fn(key, obj[key]);
            }
        }
    }

    function isEmpty(obj) {
        assert(obj != null && typeof obj === 'object', 'isEmpty() expects object parameter.');

        for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                return false;
            }
        }

        return true;
    }

    function shallowCopy(obj) {
        assert(obj && typeof obj === 'object', 'shallowCopy() expects object parameter.');
        var result = {};

        for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                result[key] = obj[key];
            }
        }

        return result;
    }

    function validateExactNumberOfArgs(functionName, args, numberOfArgs) {
        if (args.length !== numberOfArgs) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires " + formatPlural(numberOfArgs, 'argument') + ', but was called with ' + formatPlural(args.length, 'argument') + '.');
        }
    }

    function validateAtLeastNumberOfArgs(functionName, args, minNumberOfArgs) {
        if (args.length < minNumberOfArgs) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires at least " + formatPlural(minNumberOfArgs, 'argument') + ', but was called with ' + formatPlural(args.length, 'argument') + '.');
        }
    }

    function validateBetweenNumberOfArgs(functionName, args, minNumberOfArgs, maxNumberOfArgs) {
        if (args.length < minNumberOfArgs || args.length > maxNumberOfArgs) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires between " + minNumberOfArgs + " and " + (maxNumberOfArgs + " arguments, but was called with ") + formatPlural(args.length, 'argument') + '.');
        }
    }

    function validateNamedArrayAtLeastNumberOfElements(functionName, value, name, minNumberOfElements) {
        if (!(value instanceof Array) || value.length < minNumberOfElements) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires its " + name + " argument to be an " + 'array with at least ' + (formatPlural(minNumberOfElements, 'element') + "."));
        }
    }

    function validateArgType(functionName, type, position, argument) {
        validateType(functionName, type, ordinal(position) + " argument", argument);
    }

    function validateOptionalArgType(functionName, type, position, argument) {
        if (argument !== undefined) {
            validateArgType(functionName, type, position, argument);
        }
    }

    function validateNamedType(functionName, type, optionName, argument) {
        validateType(functionName, type, optionName + " option", argument);
    }

    function validateNamedOptionalType(functionName, type, optionName, argument) {
        if (argument !== undefined) {
            validateNamedType(functionName, type, optionName, argument);
        }
    }

    function validateArrayElements(functionName, optionName, typeDescription, argument, validator) {
        if (!(argument instanceof Array)) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires its " + optionName + " " + ("option to be an array, but it was: " + valueDescription(argument)));
        }

        for (var i = 0; i < argument.length; ++i) {
            if (!validator(argument[i])) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires all " + optionName + " " + ("elements to be " + typeDescription + ", but the value at index " + i + " ") + ("was: " + valueDescription(argument[i])));
            }
        }
    }

    function validateOptionalArrayElements(functionName, optionName, typeDescription, argument, validator) {
        if (argument !== undefined) {
            validateArrayElements(functionName, optionName, typeDescription, argument, validator);
        }
    }

    function validateNamedPropertyEquals(functionName, inputName, optionName, input, expected) {
        var expectedDescription = [];

        for (var _i = 0, expected_1 = expected; _i < expected_1.length; _i++) {
            var val = expected_1[_i];

            if (val === input) {
                return;
            }

            expectedDescription.push(valueDescription(val));
        }

        var actualDescription = valueDescription(input);
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid value " + actualDescription + " provided to function " + functionName + "() for option " + ("\"" + optionName + "\". Acceptable values: " + expectedDescription.join(', ')));
    }

    function validateNamedOptionalPropertyEquals(functionName, inputName, optionName, input, expected) {
        if (input !== undefined) {
            validateNamedPropertyEquals(functionName, inputName, optionName, input, expected);
        }
    }

    function validateType(functionName, type, inputName, input) {
        var valid = false;

        if (type === 'object') {
            valid = isPlainObject(input);
        } else if (type === 'non-empty string') {
            valid = typeof input === 'string' && input !== '';
        } else {
            valid = typeof input === type;
        }

        if (!valid) {
            var description = valueDescription(input);
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires its " + inputName + " " + ("to be of type " + type + ", but it was: " + description));
        }
    }

    function isPlainObject(input) {
        return typeof input === 'object' && input !== null && (Object.getPrototypeOf(input) === Object.prototype || Object.getPrototypeOf(input) === null);
    }

    function valueDescription(input) {
        if (input === undefined) {
            return 'undefined';
        } else if (input === null) {
            return 'null';
        } else if (typeof input === 'string') {
            if (input.length > 20) {
                input = input.substring(0, 20) + "...";
            }

            return JSON.stringify(input);
        } else if (typeof input === 'number' || typeof input === 'boolean') {
            return '' + input;
        } else if (typeof input === 'object') {
            if (input instanceof Array) {
                return 'an array';
            } else {
                var customObjectName = tryGetCustomObjectType(input);

                if (customObjectName) {
                    return "a custom " + customObjectName + " object";
                } else {
                    return 'an object';
                }
            }
        } else if (typeof input === 'function') {
            return 'a function';
        } else {
            return fail('Unknown wrong type: ' + typeof input);
        }
    }

    function tryGetCustomObjectType(input) {
        if (input.constructor) {
            var funcNameRegex = /function\s+([^\s(]+)\s*\(/;
            var results = funcNameRegex.exec(input.constructor.toString());

            if (results && results.length > 1) {
                return results[1];
            }
        }

        return null;
    }

    function validateDefined(functionName, position, argument) {
        if (argument === undefined) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires a valid " + ordinal(position) + " " + "argument, but it was undefined.");
        }
    }

    function validateOptionNames(functionName, options, optionNames) {
        forEach(options, function (key, _) {
            if (optionNames.indexOf(key) < 0) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, "Unknown option '" + key + "' passed to function " + functionName + "(). " + 'Available options: ' + optionNames.join(', '));
            }
        });
    }

    function invalidClassError(functionName, type, position, argument) {
        var description = valueDescription(argument);
        return new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires its " + ordinal(position) + " " + ("argument to be a " + type + ", but it was: " + description));
    }

    function ordinal(num) {
        switch (num) {
            case 1:
                return 'first';

            case 2:
                return 'second';

            case 3:
                return 'third';

            default:
                return num + 'th';
        }
    }

    function formatPlural(num, str) {
        return num + " " + str + (num === 1 ? '' : 's');
    }

    var AutoId = function () {
        function AutoId() {}

        AutoId.newId = function () {
            var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            var autoId = '';

            for (var i = 0; i < 20; i++) {
                autoId += chars.charAt(Math.floor(Math.random() * chars.length));
            }

            assert(autoId.length === 20, 'Invalid auto ID: ' + autoId);
            return autoId;
        };

        return AutoId;
    }();

    function primitiveComparator(left, right) {
        if (left < right) return -1;
        if (left > right) return 1;
        return 0;
    }

    function equals(left, right) {
        if (left !== null && left !== undefined) {
            return !!(right && left.isEqual(right));
        } else {
            return left === right;
        }
    }

    function arrayEquals(left, right) {
        if (left.length !== right.length) {
            return false;
        }

        for (var i = 0; i < left.length; i++) {
            if (!left[i].isEqual(right[i])) {
                return false;
            }
        }

        return true;
    }

    function immediateSuccessor(s) {
        return s + '\0';
    }

    function assertUint8ArrayAvailable() {
        if (typeof Uint8Array === 'undefined') {
            throw new FirestoreError(Code.UNIMPLEMENTED, 'Uint8Arrays are not available in this environment.');
        }
    }

    function assertBase64Available() {
        if (!PlatformSupport.getPlatform().base64Available) {
            throw new FirestoreError(Code.UNIMPLEMENTED, 'Blobs are unavailable in Firestore in this environment.');
        }
    }

    var Blob = function () {
        function Blob(binaryString) {
            assertBase64Available();
            this._binaryString = binaryString;
        }

        Blob.fromBase64String = function (base64) {
            validateExactNumberOfArgs('Blob.fromBase64String', arguments, 1);
            validateArgType('Blob.fromBase64String', 'string', 1, base64);
            assertBase64Available();

            try {
                var binaryString = PlatformSupport.getPlatform().atob(base64);
                return new Blob(binaryString);
            } catch (e) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Failed to construct Blob from Base64 string: ' + e);
            }
        };

        Blob.fromUint8Array = function (array) {
            validateExactNumberOfArgs('Blob.fromUint8Array', arguments, 1);
            assertUint8ArrayAvailable();

            if (!(array instanceof Uint8Array)) {
                throw invalidClassError('Blob.fromUint8Array', 'Uint8Array', 1, array);
            }

            var binaryString = Array.prototype.map.call(array, function (char) {
                return String.fromCharCode(char);
            }).join('');
            return new Blob(binaryString);
        };

        Blob.prototype.toBase64 = function () {
            validateExactNumberOfArgs('Blob.toBase64', arguments, 0);
            assertBase64Available();
            return PlatformSupport.getPlatform().btoa(this._binaryString);
        };

        Blob.prototype.toUint8Array = function () {
            validateExactNumberOfArgs('Blob.toUint8Array', arguments, 0);
            assertUint8ArrayAvailable();
            var buffer = new Uint8Array(this._binaryString.length);

            for (var i = 0; i < this._binaryString.length; i++) {
                buffer[i] = this._binaryString.charCodeAt(i);
            }

            return buffer;
        };

        Blob.prototype.toString = function () {
            return 'Blob(base64: ' + this.toBase64() + ')';
        };

        Blob.prototype.isEqual = function (other) {
            return this._binaryString === other._binaryString;
        };

        Blob.prototype._compareTo = function (other) {
            return primitiveComparator(this._binaryString, other._binaryString);
        };

        return Blob;
    }();

    var PublicBlob = makeConstructorPrivate(Blob, 'Use Blob.fromUint8Array() or Blob.fromBase64String() instead.');

    var GeoPoint = function () {
        function GeoPoint(latitude, longitude) {
            validateExactNumberOfArgs('GeoPoint', arguments, 2);
            validateArgType('GeoPoint', 'number', 1, latitude);
            validateArgType('GeoPoint', 'number', 2, longitude);

            if (!isFinite(latitude) || latitude < -90 || latitude > 90) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Latitude must be a number between -90 and 90, but was: ' + latitude);
            }

            if (!isFinite(longitude) || longitude < -180 || longitude > 180) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Longitude must be a number between -180 and 180, but was: ' + longitude);
            }

            this._lat = latitude;
            this._long = longitude;
        }

        Object.defineProperty(GeoPoint.prototype, "latitude", {
            get: function get() {
                return this._lat;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeoPoint.prototype, "longitude", {
            get: function get() {
                return this._long;
            },
            enumerable: true,
            configurable: true
        });

        GeoPoint.prototype.isEqual = function (other) {
            return this._lat === other._lat && this._long === other._long;
        };

        GeoPoint.prototype._compareTo = function (other) {
            return primitiveComparator(this._lat, other._lat) || primitiveComparator(this._long, other._long);
        };

        return GeoPoint;
    }();

    var Timestamp = function () {
        function Timestamp(seconds, nanoseconds) {
            this.seconds = seconds;
            this.nanoseconds = nanoseconds;

            if (nanoseconds < 0) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + nanoseconds);
            }

            if (nanoseconds >= 1e9) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + nanoseconds);
            }

            if (seconds < -62135596800) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + seconds);
            }

            if (seconds >= 253402300800) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + seconds);
            }
        }

        Timestamp.now = function () {
            return Timestamp.fromMillis(Date.now());
        };

        Timestamp.fromDate = function (date) {
            return Timestamp.fromMillis(date.getTime());
        };

        Timestamp.fromMillis = function (milliseconds) {
            var seconds = Math.floor(milliseconds / 1000);
            var nanos = (milliseconds - seconds * 1000) * 1e6;
            return new Timestamp(seconds, nanos);
        };

        Timestamp.prototype.toDate = function () {
            return new Date(this.toMillis());
        };

        Timestamp.prototype.toMillis = function () {
            return this.seconds * 1000 + this.nanoseconds / 1e6;
        };

        Timestamp.prototype._compareTo = function (other) {
            if (this.seconds === other.seconds) {
                return primitiveComparator(this.nanoseconds, other.nanoseconds);
            }

            return primitiveComparator(this.seconds, other.seconds);
        };

        Timestamp.prototype.isEqual = function (other) {
            return other.seconds === this.seconds && other.nanoseconds === this.nanoseconds;
        };

        Timestamp.prototype.toString = function () {
            return 'Timestamp(seconds=' + this.seconds + ', nanoseconds=' + this.nanoseconds + ')';
        };

        return Timestamp;
    }();

    var DatabaseInfo = function () {
        function DatabaseInfo(databaseId, persistenceKey, host, ssl) {
            this.databaseId = databaseId;
            this.persistenceKey = persistenceKey;
            this.host = host;
            this.ssl = ssl;
        }

        return DatabaseInfo;
    }();

    var DEFAULT_DATABASE_NAME = '(default)';

    var DatabaseId = function () {
        function DatabaseId(projectId, database) {
            this.projectId = projectId;
            this.database = database ? database : DEFAULT_DATABASE_NAME;
        }

        Object.defineProperty(DatabaseId.prototype, "isDefaultDatabase", {
            get: function get() {
                return this.database === DEFAULT_DATABASE_NAME;
            },
            enumerable: true,
            configurable: true
        });

        DatabaseId.prototype.isEqual = function (other) {
            return other instanceof DatabaseId && other.projectId === this.projectId && other.database === this.database;
        };

        DatabaseId.prototype.compareTo = function (other) {
            return primitiveComparator(this.projectId, other.projectId) || primitiveComparator(this.database, other.database);
        };

        return DatabaseId;
    }();

    var DOCUMENT_KEY_NAME = '__name__';

    var Path = function () {
        function Path(segments, offset, length) {
            this.init(segments, offset, length);
        }

        Path.prototype.init = function (segments, offset, length) {
            if (offset === undefined) {
                offset = 0;
            } else if (offset > segments.length) {
                fail('offset ' + offset + ' out of range ' + segments.length);
            }

            if (length === undefined) {
                length = segments.length - offset;
            } else if (length > segments.length - offset) {
                fail('length ' + length + ' out of range ' + (segments.length - offset));
            }

            this.segments = segments;
            this.offset = offset;
            this.len = length;
        };

        Path.prototype.construct = function (segments, offset, length) {
            var path = Object.create(Object.getPrototypeOf(this));
            path.init(segments, offset, length);
            return path;
        };

        Object.defineProperty(Path.prototype, "length", {
            get: function get() {
                return this.len;
            },
            enumerable: true,
            configurable: true
        });

        Path.prototype.isEqual = function (other) {
            return Path.comparator(this, other) === 0;
        };

        Path.prototype.child = function (nameOrPath) {
            var segments = this.segments.slice(this.offset, this.limit());

            if (nameOrPath instanceof Path) {
                nameOrPath.forEach(function (segment) {
                    segments.push(segment);
                });
            } else if (typeof nameOrPath === 'string') {
                segments.push(nameOrPath);
            } else {
                fail('Unknown parameter type for Path.child(): ' + nameOrPath);
            }

            return this.construct(segments);
        };

        Path.prototype.limit = function () {
            return this.offset + this.length;
        };

        Path.prototype.popFirst = function (size) {
            size = size === undefined ? 1 : size;
            assert(this.length >= size, "Can't call popFirst() with less segments");
            return this.construct(this.segments, this.offset + size, this.length - size);
        };

        Path.prototype.popLast = function () {
            assert(!this.isEmpty(), "Can't call popLast() on empty path");
            return this.construct(this.segments, this.offset, this.length - 1);
        };

        Path.prototype.firstSegment = function () {
            assert(!this.isEmpty(), "Can't call firstSegment() on empty path");
            return this.segments[this.offset];
        };

        Path.prototype.lastSegment = function () {
            assert(!this.isEmpty(), "Can't call lastSegment() on empty path");
            return this.segments[this.limit() - 1];
        };

        Path.prototype.get = function (index) {
            assert(index < this.length, 'Index out of range');
            return this.segments[this.offset + index];
        };

        Path.prototype.isEmpty = function () {
            return this.length === 0;
        };

        Path.prototype.isPrefixOf = function (other) {
            if (other.length < this.length) {
                return false;
            }

            for (var i = 0; i < this.length; i++) {
                if (this.get(i) !== other.get(i)) {
                    return false;
                }
            }

            return true;
        };

        Path.prototype.isImmediateParentOf = function (potentialChild) {
            if (this.length + 1 !== potentialChild.length) {
                return false;
            }

            for (var i = 0; i < this.length; i++) {
                if (this.get(i) !== potentialChild.get(i)) {
                    return false;
                }
            }

            return true;
        };

        Path.prototype.forEach = function (fn) {
            for (var i = this.offset, end = this.limit(); i < end; i++) {
                fn(this.segments[i]);
            }
        };

        Path.prototype.toArray = function () {
            return this.segments.slice(this.offset, this.limit());
        };

        Path.comparator = function (p1, p2) {
            var len = Math.min(p1.length, p2.length);

            for (var i = 0; i < len; i++) {
                var left = p1.get(i);
                var right = p2.get(i);
                if (left < right) return -1;
                if (left > right) return 1;
            }

            if (p1.length < p2.length) return -1;
            if (p1.length > p2.length) return 1;
            return 0;
        };

        return Path;
    }();

    var ResourcePath = function (_super) {
        tslib_1.__extends(ResourcePath, _super);

        function ResourcePath() {
            return _super !== null && _super.apply(this, arguments) || this;
        }

        ResourcePath.prototype.canonicalString = function () {
            return this.toArray().join('/');
        };

        ResourcePath.prototype.toString = function () {
            return this.canonicalString();
        };

        ResourcePath.fromString = function (path) {
            if (path.indexOf('//') >= 0) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid path (" + path + "). Paths must not contain // in them.");
            }

            var segments = path.split('/').filter(function (segment) {
                return segment.length > 0;
            });
            return new ResourcePath(segments);
        };

        ResourcePath.EMPTY_PATH = new ResourcePath([]);
        return ResourcePath;
    }(Path);

    var identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;

    var FieldPath = function (_super) {
        tslib_1.__extends(FieldPath, _super);

        function FieldPath() {
            return _super !== null && _super.apply(this, arguments) || this;
        }

        FieldPath.isValidIdentifier = function (segment) {
            return identifierRegExp.test(segment);
        };

        FieldPath.prototype.canonicalString = function () {
            return this.toArray().map(function (str) {
                str = str.replace('\\', '\\\\').replace('`', '\\`');

                if (!FieldPath.isValidIdentifier(str)) {
                    str = '`' + str + '`';
                }

                return str;
            }).join('.');
        };

        FieldPath.prototype.toString = function () {
            return this.canonicalString();
        };

        FieldPath.prototype.isKeyField = function () {
            return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;
        };

        FieldPath.keyField = function () {
            return new FieldPath([DOCUMENT_KEY_NAME]);
        };

        FieldPath.fromServerFormat = function (path) {
            var segments = [];
            var current = '';
            var i = 0;

            var addCurrentSegment = function addCurrentSegment() {
                if (current.length === 0) {
                    throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid field path (" + path + "). Paths must not be empty, begin " + "with '.', end with '.', or contain '..'");
                }

                segments.push(current);
                current = '';
            };

            var inBackticks = false;

            while (i < path.length) {
                var c = path[i];

                if (c === '\\') {
                    if (i + 1 === path.length) {
                        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has trailing escape character: ' + path);
                    }

                    var next = path[i + 1];

                    if (!(next === '\\' || next === '.' || next === '`')) {
                        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has invalid escape sequence: ' + path);
                    }

                    current += next;
                    i += 2;
                } else if (c === '`') {
                    inBackticks = !inBackticks;
                    i++;
                } else if (c === '.' && !inBackticks) {
                    addCurrentSegment();
                    i++;
                } else {
                    current += c;
                    i++;
                }
            }

            addCurrentSegment();

            if (inBackticks) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Unterminated ` in path: ' + path);
            }

            return new FieldPath(segments);
        };

        FieldPath.EMPTY_PATH = new FieldPath([]);
        return FieldPath;
    }(Path);

    var DocumentKey = function () {
        function DocumentKey(path) {
            this.path = path;
            assert(DocumentKey.isDocumentKey(path), 'Invalid DocumentKey with an odd number of segments: ' + path.toArray().join('/'));
        }

        DocumentKey.prototype.isEqual = function (other) {
            return other !== null && ResourcePath.comparator(this.path, other.path) === 0;
        };

        DocumentKey.prototype.toString = function () {
            return this.path.toString();
        };

        DocumentKey.comparator = function (k1, k2) {
            return ResourcePath.comparator(k1.path, k2.path);
        };

        DocumentKey.isDocumentKey = function (path) {
            return path.length % 2 === 0;
        };

        DocumentKey.fromSegments = function (segments) {
            return new DocumentKey(new ResourcePath(segments.slice()));
        };

        DocumentKey.fromPathString = function (path) {
            return new DocumentKey(ResourcePath.fromString(path));
        };

        DocumentKey.EMPTY = new DocumentKey(new ResourcePath([]));
        return DocumentKey;
    }();

    var MaybeDocument = function () {
        function MaybeDocument(key, version) {
            this.key = key;
            this.version = version;
        }

        MaybeDocument.compareByKey = function (d1, d2) {
            return DocumentKey.comparator(d1.key, d2.key);
        };

        return MaybeDocument;
    }();

    var Document = function (_super) {
        tslib_1.__extends(Document, _super);

        function Document(key, version, data, options) {
            var _this = _super.call(this, key, version) || this;

            _this.data = data;
            _this.hasLocalMutations = !!options.hasLocalMutations;
            _this.hasCommittedMutations = !!options.hasCommittedMutations;
            return _this;
        }

        Document.prototype.field = function (path) {
            return this.data.field(path);
        };

        Document.prototype.fieldValue = function (path) {
            var field = this.field(path);
            return field ? field.value() : undefined;
        };

        Document.prototype.value = function () {
            return this.data.value();
        };

        Document.prototype.isEqual = function (other) {
            return other instanceof Document && this.key.isEqual(other.key) && this.version.isEqual(other.version) && this.data.isEqual(other.data) && this.hasLocalMutations === other.hasLocalMutations && this.hasCommittedMutations === other.hasCommittedMutations;
        };

        Document.prototype.toString = function () {
            return "Document(" + this.key + ", " + this.version + ", " + this.data.toString() + ", " + ("{hasLocalMutations: " + this.hasLocalMutations + "}), ") + ("{hasCommittedMutations: " + this.hasCommittedMutations + "})");
        };

        Object.defineProperty(Document.prototype, "hasPendingWrites", {
            get: function get() {
                return this.hasLocalMutations || this.hasCommittedMutations;
            },
            enumerable: true,
            configurable: true
        });

        Document.compareByField = function (field, d1, d2) {
            var v1 = d1.field(field);
            var v2 = d2.field(field);

            if (v1 !== undefined && v2 !== undefined) {
                return v1.compareTo(v2);
            } else {
                return fail("Trying to compare documents on fields that don't exist");
            }
        };

        return Document;
    }(MaybeDocument);

    var NoDocument = function (_super) {
        tslib_1.__extends(NoDocument, _super);

        function NoDocument(key, version, options) {
            var _this = _super.call(this, key, version) || this;

            _this.hasCommittedMutations = !!(options && options.hasCommittedMutations);
            return _this;
        }

        NoDocument.prototype.toString = function () {
            return "NoDocument(" + this.key + ", " + this.version + ")";
        };

        Object.defineProperty(NoDocument.prototype, "hasPendingWrites", {
            get: function get() {
                return this.hasCommittedMutations;
            },
            enumerable: true,
            configurable: true
        });

        NoDocument.prototype.isEqual = function (other) {
            return other instanceof NoDocument && other.hasCommittedMutations === this.hasCommittedMutations && other.version.isEqual(this.version) && other.key.isEqual(this.key);
        };

        return NoDocument;
    }(MaybeDocument);

    var UnknownDocument = function (_super) {
        tslib_1.__extends(UnknownDocument, _super);

        function UnknownDocument(key, version) {
            return _super.call(this, key, version) || this;
        }

        UnknownDocument.prototype.toString = function () {
            return "UnknownDocument(" + this.key + ", " + this.version + ")";
        };

        Object.defineProperty(UnknownDocument.prototype, "hasPendingWrites", {
            get: function get() {
                return true;
            },
            enumerable: true,
            configurable: true
        });

        UnknownDocument.prototype.isEqual = function (other) {
            return other instanceof UnknownDocument && other.version.isEqual(this.version) && other.key.isEqual(this.key);
        };

        return UnknownDocument;
    }(MaybeDocument);

    var SortedMap = function () {
        function SortedMap(comparator, root) {
            this.comparator = comparator;
            this.root = root ? root : LLRBNode.EMPTY;
        }

        SortedMap.prototype.insert = function (key, value) {
            return new SortedMap(this.comparator, this.root.insert(key, value, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));
        };

        SortedMap.prototype.remove = function (key) {
            return new SortedMap(this.comparator, this.root.remove(key, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));
        };

        SortedMap.prototype.get = function (key) {
            var node = this.root;

            while (!node.isEmpty()) {
                var cmp = this.comparator(key, node.key);

                if (cmp === 0) {
                    return node.value;
                } else if (cmp < 0) {
                    node = node.left;
                } else if (cmp > 0) {
                    node = node.right;
                }
            }

            return null;
        };

        SortedMap.prototype.indexOf = function (key) {
            var prunedNodes = 0;
            var node = this.root;

            while (!node.isEmpty()) {
                var cmp = this.comparator(key, node.key);

                if (cmp === 0) {
                    return prunedNodes + node.left.size;
                } else if (cmp < 0) {
                    node = node.left;
                } else {
                    prunedNodes += node.left.size + 1;
                    node = node.right;
                }
            }

            return -1;
        };

        SortedMap.prototype.isEmpty = function () {
            return this.root.isEmpty();
        };

        Object.defineProperty(SortedMap.prototype, "size", {
            get: function get() {
                return this.root.size;
            },
            enumerable: true,
            configurable: true
        });

        SortedMap.prototype.minKey = function () {
            return this.root.minKey();
        };

        SortedMap.prototype.maxKey = function () {
            return this.root.maxKey();
        };

        SortedMap.prototype.inorderTraversal = function (action) {
            return this.root.inorderTraversal(action);
        };

        SortedMap.prototype.forEach = function (fn) {
            this.inorderTraversal(function (k, v) {
                fn(k, v);
                return false;
            });
        };

        SortedMap.prototype.reverseTraversal = function (action) {
            return this.root.reverseTraversal(action);
        };

        SortedMap.prototype.getIterator = function () {
            return new SortedMapIterator(this.root, null, this.comparator, false);
        };

        SortedMap.prototype.getIteratorFrom = function (key) {
            return new SortedMapIterator(this.root, key, this.comparator, false);
        };

        SortedMap.prototype.getReverseIterator = function () {
            return new SortedMapIterator(this.root, null, this.comparator, true);
        };

        SortedMap.prototype.getReverseIteratorFrom = function (key) {
            return new SortedMapIterator(this.root, key, this.comparator, true);
        };

        SortedMap.prototype[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"] = function () {
            var it = this.getIterator();
            return {
                next: function next() {
                    if (it.hasNext()) {
                        return {
                            done: false,
                            value: it.getNext()
                        };
                    } else {
                        return {
                            done: true,
                            value: {}
                        };
                    }
                }
            };
        };

        return SortedMap;
    }();

    var SortedMapIterator = function () {
        function SortedMapIterator(node, startKey, comparator, isReverse) {
            this.isReverse = isReverse;
            this.nodeStack = [];
            var cmp = 1;

            while (!node.isEmpty()) {
                cmp = startKey ? comparator(node.key, startKey) : 1;
                if (isReverse) cmp *= -1;

                if (cmp < 0) {
                    if (this.isReverse) {
                        node = node.left;
                    } else {
                        node = node.right;
                    }
                } else if (cmp === 0) {
                    this.nodeStack.push(node);
                    break;
                } else {
                    this.nodeStack.push(node);

                    if (this.isReverse) {
                        node = node.right;
                    } else {
                        node = node.left;
                    }
                }
            }
        }

        SortedMapIterator.prototype.getNext = function () {
            assert(this.nodeStack.length > 0, 'getNext() called on iterator when hasNext() is false.');
            var node = this.nodeStack.pop();
            var result = {
                key: node.key,
                value: node.value
            };

            if (this.isReverse) {
                node = node.left;

                while (!node.isEmpty()) {
                    this.nodeStack.push(node);
                    node = node.right;
                }
            } else {
                node = node.right;

                while (!node.isEmpty()) {
                    this.nodeStack.push(node);
                    node = node.left;
                }
            }

            return result;
        };

        SortedMapIterator.prototype.hasNext = function () {
            return this.nodeStack.length > 0;
        };

        SortedMapIterator.prototype.peek = function () {
            if (this.nodeStack.length === 0) return null;
            var node = this.nodeStack[this.nodeStack.length - 1];
            return {
                key: node.key,
                value: node.value
            };
        };

        return SortedMapIterator;
    }();

    var LLRBNode = function () {
        function LLRBNode(key, value, color, left, right) {
            this.key = key;
            this.value = value;
            this.color = color != null ? color : LLRBNode.RED;
            this.left = left != null ? left : LLRBNode.EMPTY;
            this.right = right != null ? right : LLRBNode.EMPTY;
            this.size = this.left.size + 1 + this.right.size;
        }

        LLRBNode.prototype.copy = function (key, value, color, left, right) {
            return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);
        };

        LLRBNode.prototype.isEmpty = function () {
            return false;
        };

        LLRBNode.prototype.inorderTraversal = function (action) {
            return this.left.inorderTraversal(action) || action(this.key, this.value) || this.right.inorderTraversal(action);
        };

        LLRBNode.prototype.reverseTraversal = function (action) {
            return this.right.reverseTraversal(action) || action(this.key, this.value) || this.left.reverseTraversal(action);
        };

        LLRBNode.prototype.min = function () {
            if (this.left.isEmpty()) {
                return this;
            } else {
                return this.left.min();
            }
        };

        LLRBNode.prototype.minKey = function () {
            return this.min().key;
        };

        LLRBNode.prototype.maxKey = function () {
            if (this.right.isEmpty()) {
                return this.key;
            } else {
                return this.right.maxKey();
            }
        };

        LLRBNode.prototype.insert = function (key, value, comparator) {
            var n = this;
            var cmp = comparator(key, n.key);

            if (cmp < 0) {
                n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);
            } else if (cmp === 0) {
                n = n.copy(null, value, null, null, null);
            } else {
                n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));
            }

            return n.fixUp();
        };

        LLRBNode.prototype.removeMin = function () {
            if (this.left.isEmpty()) {
                return LLRBNode.EMPTY;
            }

            var n = this;
            if (!n.left.isRed() && !n.left.left.isRed()) n = n.moveRedLeft();
            n = n.copy(null, null, null, n.left.removeMin(), null);
            return n.fixUp();
        };

        LLRBNode.prototype.remove = function (key, comparator) {
            var smallest;
            var n = this;

            if (comparator(key, n.key) < 0) {
                if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) {
                    n = n.moveRedLeft();
                }

                n = n.copy(null, null, null, n.left.remove(key, comparator), null);
            } else {
                if (n.left.isRed()) n = n.rotateRight();

                if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) {
                    n = n.moveRedRight();
                }

                if (comparator(key, n.key) === 0) {
                    if (n.right.isEmpty()) {
                        return LLRBNode.EMPTY;
                    } else {
                        smallest = n.right.min();
                        n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin());
                    }
                }

                n = n.copy(null, null, null, null, n.right.remove(key, comparator));
            }

            return n.fixUp();
        };

        LLRBNode.prototype.isRed = function () {
            return this.color;
        };

        LLRBNode.prototype.fixUp = function () {
            var n = this;
            if (n.right.isRed() && !n.left.isRed()) n = n.rotateLeft();
            if (n.left.isRed() && n.left.left.isRed()) n = n.rotateRight();
            if (n.left.isRed() && n.right.isRed()) n = n.colorFlip();
            return n;
        };

        LLRBNode.prototype.moveRedLeft = function () {
            var n = this.colorFlip();

            if (n.right.left.isRed()) {
                n = n.copy(null, null, null, null, n.right.rotateRight());
                n = n.rotateLeft();
                n = n.colorFlip();
            }

            return n;
        };

        LLRBNode.prototype.moveRedRight = function () {
            var n = this.colorFlip();

            if (n.left.left.isRed()) {
                n = n.rotateRight();
                n = n.colorFlip();
            }

            return n;
        };

        LLRBNode.prototype.rotateLeft = function () {
            var nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);
            return this.right.copy(null, null, this.color, nl, null);
        };

        LLRBNode.prototype.rotateRight = function () {
            var nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);
            return this.left.copy(null, null, this.color, null, nr);
        };

        LLRBNode.prototype.colorFlip = function () {
            var left = this.left.copy(null, null, !this.left.color, null, null);
            var right = this.right.copy(null, null, !this.right.color, null, null);
            return this.copy(null, null, !this.color, left, right);
        };

        LLRBNode.prototype.checkMaxDepth = function () {
            var blackDepth = this.check();

            if (Math.pow(2.0, blackDepth) <= this.size + 1) {
                return true;
            } else {
                return false;
            }
        };

        LLRBNode.prototype.check = function () {
            if (this.isRed() && this.left.isRed()) {
                throw fail('Red node has red child(' + this.key + ',' + this.value + ')');
            }

            if (this.right.isRed()) {
                throw fail('Right child of (' + this.key + ',' + this.value + ') is red');
            }

            var blackDepth = this.left.check();

            if (blackDepth !== this.right.check()) {
                throw fail('Black depths differ');
            } else {
                return blackDepth + (this.isRed() ? 0 : 1);
            }
        };

        LLRBNode.EMPTY = null;
        LLRBNode.RED = true;
        LLRBNode.BLACK = false;
        return LLRBNode;
    }();

    var LLRBEmptyNode = function () {
        function LLRBEmptyNode() {
            this.size = 0;
        }

        LLRBEmptyNode.prototype.copy = function (key, value, color, left, right) {
            return this;
        };

        LLRBEmptyNode.prototype.insert = function (key, value, comparator) {
            return new LLRBNode(key, value);
        };

        LLRBEmptyNode.prototype.remove = function (key, comparator) {
            return this;
        };

        LLRBEmptyNode.prototype.isEmpty = function () {
            return true;
        };

        LLRBEmptyNode.prototype.inorderTraversal = function (action) {
            return false;
        };

        LLRBEmptyNode.prototype.reverseTraversal = function (action) {
            return false;
        };

        LLRBEmptyNode.prototype.minKey = function () {
            return null;
        };

        LLRBEmptyNode.prototype.maxKey = function () {
            return null;
        };

        LLRBEmptyNode.prototype.isRed = function () {
            return false;
        };

        LLRBEmptyNode.prototype.checkMaxDepth = function () {
            return true;
        };

        LLRBEmptyNode.prototype.check = function () {
            return 0;
        };

        return LLRBEmptyNode;
    }();

    LLRBNode.EMPTY = new LLRBEmptyNode();
    var TypeOrder;

    (function (TypeOrder) {
        TypeOrder[TypeOrder["NullValue"] = 0] = "NullValue";
        TypeOrder[TypeOrder["BooleanValue"] = 1] = "BooleanValue";
        TypeOrder[TypeOrder["NumberValue"] = 2] = "NumberValue";
        TypeOrder[TypeOrder["TimestampValue"] = 3] = "TimestampValue";
        TypeOrder[TypeOrder["StringValue"] = 4] = "StringValue";
        TypeOrder[TypeOrder["BlobValue"] = 5] = "BlobValue";
        TypeOrder[TypeOrder["RefValue"] = 6] = "RefValue";
        TypeOrder[TypeOrder["GeoPointValue"] = 7] = "GeoPointValue";
        TypeOrder[TypeOrder["ArrayValue"] = 8] = "ArrayValue";
        TypeOrder[TypeOrder["ObjectValue"] = 9] = "ObjectValue";
    })(TypeOrder || (TypeOrder = {}));

    var ServerTimestampBehavior;

    (function (ServerTimestampBehavior) {
        ServerTimestampBehavior[ServerTimestampBehavior["Default"] = 0] = "Default";
        ServerTimestampBehavior[ServerTimestampBehavior["Estimate"] = 1] = "Estimate";
        ServerTimestampBehavior[ServerTimestampBehavior["Previous"] = 2] = "Previous";
    })(ServerTimestampBehavior || (ServerTimestampBehavior = {}));

    var FieldValueOptions = function () {
        function FieldValueOptions(serverTimestampBehavior, timestampsInSnapshots) {
            this.serverTimestampBehavior = serverTimestampBehavior;
            this.timestampsInSnapshots = timestampsInSnapshots;
        }

        FieldValueOptions.fromSnapshotOptions = function (options, timestampsInSnapshots) {
            switch (options.serverTimestamps) {
                case 'estimate':
                    return new FieldValueOptions(ServerTimestampBehavior.Estimate, timestampsInSnapshots);

                case 'previous':
                    return new FieldValueOptions(ServerTimestampBehavior.Previous, timestampsInSnapshots);

                case 'none':
                case undefined:
                    return new FieldValueOptions(ServerTimestampBehavior.Default, timestampsInSnapshots);

                default:
                    return fail('fromSnapshotOptions() called with invalid options.');
            }
        };

        return FieldValueOptions;
    }();

    var FieldValue = function () {
        function FieldValue() {}

        FieldValue.prototype.toString = function () {
            var val = this.value();
            return val === null ? 'null' : val.toString();
        };

        FieldValue.prototype.defaultCompareTo = function (other) {
            assert(this.typeOrder !== other.typeOrder, 'Default compareTo should not be used for values of same type.');
            var cmp = primitiveComparator(this.typeOrder, other.typeOrder);
            return cmp;
        };

        return FieldValue;
    }();

    var NullValue = function (_super) {
        tslib_1.__extends(NullValue, _super);

        function NullValue() {
            var _this = _super.call(this) || this;

            _this.typeOrder = TypeOrder.NullValue;
            _this.internalValue = null;
            return _this;
        }

        NullValue.prototype.value = function (options) {
            return null;
        };

        NullValue.prototype.isEqual = function (other) {
            return other instanceof NullValue;
        };

        NullValue.prototype.compareTo = function (other) {
            if (other instanceof NullValue) {
                return 0;
            }

            return this.defaultCompareTo(other);
        };

        NullValue.INSTANCE = new NullValue();
        return NullValue;
    }(FieldValue);

    var BooleanValue = function (_super) {
        tslib_1.__extends(BooleanValue, _super);

        function BooleanValue(internalValue) {
            var _this = _super.call(this) || this;

            _this.internalValue = internalValue;
            _this.typeOrder = TypeOrder.BooleanValue;
            return _this;
        }

        BooleanValue.prototype.value = function (options) {
            return this.internalValue;
        };

        BooleanValue.prototype.isEqual = function (other) {
            return other instanceof BooleanValue && this.internalValue === other.internalValue;
        };

        BooleanValue.prototype.compareTo = function (other) {
            if (other instanceof BooleanValue) {
                return primitiveComparator(this, other);
            }

            return this.defaultCompareTo(other);
        };

        BooleanValue.of = function (value) {
            return value ? BooleanValue.TRUE : BooleanValue.FALSE;
        };

        BooleanValue.TRUE = new BooleanValue(true);
        BooleanValue.FALSE = new BooleanValue(false);
        return BooleanValue;
    }(FieldValue);

    var NumberValue = function (_super) {
        tslib_1.__extends(NumberValue, _super);

        function NumberValue(internalValue) {
            var _this = _super.call(this) || this;

            _this.internalValue = internalValue;
            _this.typeOrder = TypeOrder.NumberValue;
            return _this;
        }

        NumberValue.prototype.value = function (options) {
            return this.internalValue;
        };

        NumberValue.prototype.compareTo = function (other) {
            if (other instanceof NumberValue) {
                return numericComparator(this.internalValue, other.internalValue);
            }

            return this.defaultCompareTo(other);
        };

        return NumberValue;
    }(FieldValue);

    function numericComparator(left, right) {
        if (left < right) {
            return -1;
        } else if (left > right) {
            return 1;
        } else if (left === right) {
            return 0;
        } else {
            if (isNaN(left)) {
                return isNaN(right) ? 0 : -1;
            } else {
                return 1;
            }
        }
    }

    function numericEquals(left, right) {
        if (left === right) {
            return left !== 0 || 1 / left === 1 / right;
        } else {
            return left !== left && right !== right;
        }
    }

    var IntegerValue = function (_super) {
        tslib_1.__extends(IntegerValue, _super);

        function IntegerValue(internalValue) {
            return _super.call(this, internalValue) || this;
        }

        IntegerValue.prototype.isEqual = function (other) {
            if (other instanceof IntegerValue) {
                return numericEquals(this.internalValue, other.internalValue);
            } else {
                return false;
            }
        };

        return IntegerValue;
    }(NumberValue);

    var DoubleValue = function (_super) {
        tslib_1.__extends(DoubleValue, _super);

        function DoubleValue(internalValue) {
            var _this = _super.call(this, internalValue) || this;

            _this.internalValue = internalValue;
            return _this;
        }

        DoubleValue.prototype.isEqual = function (other) {
            if (other instanceof DoubleValue) {
                return numericEquals(this.internalValue, other.internalValue);
            } else {
                return false;
            }
        };

        DoubleValue.NAN = new DoubleValue(NaN);
        DoubleValue.POSITIVE_INFINITY = new DoubleValue(Infinity);
        DoubleValue.NEGATIVE_INFINITY = new DoubleValue(-Infinity);
        return DoubleValue;
    }(NumberValue);

    var StringValue = function (_super) {
        tslib_1.__extends(StringValue, _super);

        function StringValue(internalValue) {
            var _this = _super.call(this) || this;

            _this.internalValue = internalValue;
            _this.typeOrder = TypeOrder.StringValue;
            return _this;
        }

        StringValue.prototype.value = function (options) {
            return this.internalValue;
        };

        StringValue.prototype.isEqual = function (other) {
            return other instanceof StringValue && this.internalValue === other.internalValue;
        };

        StringValue.prototype.compareTo = function (other) {
            if (other instanceof StringValue) {
                return primitiveComparator(this.internalValue, other.internalValue);
            }

            return this.defaultCompareTo(other);
        };

        return StringValue;
    }(FieldValue);

    var TimestampValue = function (_super) {
        tslib_1.__extends(TimestampValue, _super);

        function TimestampValue(internalValue) {
            var _this = _super.call(this) || this;

            _this.internalValue = internalValue;
            _this.typeOrder = TypeOrder.TimestampValue;
            return _this;
        }

        TimestampValue.prototype.value = function (options) {
            if (options && options.timestampsInSnapshots) {
                return this.internalValue;
            } else {
                return this.internalValue.toDate();
            }
        };

        TimestampValue.prototype.isEqual = function (other) {
            return other instanceof TimestampValue && this.internalValue.isEqual(other.internalValue);
        };

        TimestampValue.prototype.compareTo = function (other) {
            if (other instanceof TimestampValue) {
                return this.internalValue._compareTo(other.internalValue);
            } else if (other instanceof ServerTimestampValue) {
                return -1;
            } else {
                return this.defaultCompareTo(other);
            }
        };

        return TimestampValue;
    }(FieldValue);

    var ServerTimestampValue = function (_super) {
        tslib_1.__extends(ServerTimestampValue, _super);

        function ServerTimestampValue(localWriteTime, previousValue) {
            var _this = _super.call(this) || this;

            _this.localWriteTime = localWriteTime;
            _this.previousValue = previousValue;
            _this.typeOrder = TypeOrder.TimestampValue;
            return _this;
        }

        ServerTimestampValue.prototype.value = function (options) {
            if (options && options.serverTimestampBehavior === ServerTimestampBehavior.Estimate) {
                return new TimestampValue(this.localWriteTime).value(options);
            } else if (options && options.serverTimestampBehavior === ServerTimestampBehavior.Previous) {
                return this.previousValue ? this.previousValue.value(options) : null;
            } else {
                return null;
            }
        };

        ServerTimestampValue.prototype.isEqual = function (other) {
            return other instanceof ServerTimestampValue && this.localWriteTime.isEqual(other.localWriteTime);
        };

        ServerTimestampValue.prototype.compareTo = function (other) {
            if (other instanceof ServerTimestampValue) {
                return this.localWriteTime._compareTo(other.localWriteTime);
            } else if (other instanceof TimestampValue) {
                return 1;
            } else {
                return this.defaultCompareTo(other);
            }
        };

        ServerTimestampValue.prototype.toString = function () {
            return '<ServerTimestamp localTime=' + this.localWriteTime.toString() + '>';
        };

        return ServerTimestampValue;
    }(FieldValue);

    var BlobValue = function (_super) {
        tslib_1.__extends(BlobValue, _super);

        function BlobValue(internalValue) {
            var _this = _super.call(this) || this;

            _this.internalValue = internalValue;
            _this.typeOrder = TypeOrder.BlobValue;
            return _this;
        }

        BlobValue.prototype.value = function (options) {
            return this.internalValue;
        };

        BlobValue.prototype.isEqual = function (other) {
            return other instanceof BlobValue && this.internalValue.isEqual(other.internalValue);
        };

        BlobValue.prototype.compareTo = function (other) {
            if (other instanceof BlobValue) {
                return this.internalValue._compareTo(other.internalValue);
            }

            return this.defaultCompareTo(other);
        };

        return BlobValue;
    }(FieldValue);

    var RefValue = function (_super) {
        tslib_1.__extends(RefValue, _super);

        function RefValue(databaseId, key) {
            var _this = _super.call(this) || this;

            _this.databaseId = databaseId;
            _this.key = key;
            _this.typeOrder = TypeOrder.RefValue;
            return _this;
        }

        RefValue.prototype.value = function (options) {
            return this.key;
        };

        RefValue.prototype.isEqual = function (other) {
            if (other instanceof RefValue) {
                return this.key.isEqual(other.key) && this.databaseId.isEqual(other.databaseId);
            } else {
                return false;
            }
        };

        RefValue.prototype.compareTo = function (other) {
            if (other instanceof RefValue) {
                var cmp = this.databaseId.compareTo(other.databaseId);
                return cmp !== 0 ? cmp : DocumentKey.comparator(this.key, other.key);
            }

            return this.defaultCompareTo(other);
        };

        return RefValue;
    }(FieldValue);

    var GeoPointValue = function (_super) {
        tslib_1.__extends(GeoPointValue, _super);

        function GeoPointValue(internalValue) {
            var _this = _super.call(this) || this;

            _this.internalValue = internalValue;
            _this.typeOrder = TypeOrder.GeoPointValue;
            return _this;
        }

        GeoPointValue.prototype.value = function (options) {
            return this.internalValue;
        };

        GeoPointValue.prototype.isEqual = function (other) {
            return other instanceof GeoPointValue && this.internalValue.isEqual(other.internalValue);
        };

        GeoPointValue.prototype.compareTo = function (other) {
            if (other instanceof GeoPointValue) {
                return this.internalValue._compareTo(other.internalValue);
            }

            return this.defaultCompareTo(other);
        };

        return GeoPointValue;
    }(FieldValue);

    var ObjectValue = function (_super) {
        tslib_1.__extends(ObjectValue, _super);

        function ObjectValue(internalValue) {
            var _this = _super.call(this) || this;

            _this.internalValue = internalValue;
            _this.typeOrder = TypeOrder.ObjectValue;
            return _this;
        }

        ObjectValue.prototype.value = function (options) {
            var result = {};
            this.internalValue.inorderTraversal(function (key, val) {
                result[key] = val.value(options);
            });
            return result;
        };

        ObjectValue.prototype.forEach = function (action) {
            this.internalValue.inorderTraversal(action);
        };

        ObjectValue.prototype.isEqual = function (other) {
            if (other instanceof ObjectValue) {
                var it1 = this.internalValue.getIterator();
                var it2 = other.internalValue.getIterator();

                while (it1.hasNext() && it2.hasNext()) {
                    var next1 = it1.getNext();
                    var next2 = it2.getNext();

                    if (next1.key !== next2.key || !next1.value.isEqual(next2.value)) {
                        return false;
                    }
                }

                return !it1.hasNext() && !it2.hasNext();
            }

            return false;
        };

        ObjectValue.prototype.compareTo = function (other) {
            if (other instanceof ObjectValue) {
                var it1 = this.internalValue.getIterator();
                var it2 = other.internalValue.getIterator();

                while (it1.hasNext() && it2.hasNext()) {
                    var next1 = it1.getNext();
                    var next2 = it2.getNext();
                    var cmp = primitiveComparator(next1.key, next2.key) || next1.value.compareTo(next2.value);

                    if (cmp) {
                        return cmp;
                    }
                }

                return primitiveComparator(it1.hasNext(), it2.hasNext());
            } else {
                return this.defaultCompareTo(other);
            }
        };

        ObjectValue.prototype.set = function (path, to) {
            assert(!path.isEmpty(), 'Cannot set field for empty path on ObjectValue');

            if (path.length === 1) {
                return this.setChild(path.firstSegment(), to);
            } else {
                var child = this.child(path.firstSegment());

                if (!(child instanceof ObjectValue)) {
                    child = ObjectValue.EMPTY;
                }

                var newChild = child.set(path.popFirst(), to);
                return this.setChild(path.firstSegment(), newChild);
            }
        };

        ObjectValue.prototype.delete = function (path) {
            assert(!path.isEmpty(), 'Cannot delete field for empty path on ObjectValue');

            if (path.length === 1) {
                return new ObjectValue(this.internalValue.remove(path.firstSegment()));
            } else {
                var child = this.child(path.firstSegment());

                if (child instanceof ObjectValue) {
                    var newChild = child.delete(path.popFirst());
                    return new ObjectValue(this.internalValue.insert(path.firstSegment(), newChild));
                } else {
                    return this;
                }
            }
        };

        ObjectValue.prototype.contains = function (path) {
            return this.field(path) !== undefined;
        };

        ObjectValue.prototype.field = function (path) {
            assert(!path.isEmpty(), "Can't get field of empty path");
            var field = this;
            path.forEach(function (pathSegment) {
                if (field instanceof ObjectValue) {
                    field = field.internalValue.get(pathSegment) || undefined;
                } else {
                    field = undefined;
                }
            });
            return field;
        };

        ObjectValue.prototype.toString = function () {
            return JSON.stringify(this.value());
        };

        ObjectValue.prototype.child = function (childName) {
            return this.internalValue.get(childName) || undefined;
        };

        ObjectValue.prototype.setChild = function (childName, value) {
            return new ObjectValue(this.internalValue.insert(childName, value));
        };

        ObjectValue.EMPTY = new ObjectValue(new SortedMap(primitiveComparator));
        return ObjectValue;
    }(FieldValue);

    var ArrayValue = function (_super) {
        tslib_1.__extends(ArrayValue, _super);

        function ArrayValue(internalValue) {
            var _this = _super.call(this) || this;

            _this.internalValue = internalValue;
            _this.typeOrder = TypeOrder.ArrayValue;
            return _this;
        }

        ArrayValue.prototype.value = function (options) {
            return this.internalValue.map(function (v) {
                return v.value(options);
            });
        };

        ArrayValue.prototype.forEach = function (action) {
            this.internalValue.forEach(action);
        };

        ArrayValue.prototype.isEqual = function (other) {
            if (other instanceof ArrayValue) {
                if (this.internalValue.length !== other.internalValue.length) {
                    return false;
                }

                for (var i = 0; i < this.internalValue.length; i++) {
                    if (!this.internalValue[i].isEqual(other.internalValue[i])) {
                        return false;
                    }
                }

                return true;
            }

            return false;
        };

        ArrayValue.prototype.compareTo = function (other) {
            if (other instanceof ArrayValue) {
                var minLength = Math.min(this.internalValue.length, other.internalValue.length);

                for (var i = 0; i < minLength; i++) {
                    var cmp = this.internalValue[i].compareTo(other.internalValue[i]);

                    if (cmp) {
                        return cmp;
                    }
                }

                return primitiveComparator(this.internalValue.length, other.internalValue.length);
            } else {
                return this.defaultCompareTo(other);
            }
        };

        ArrayValue.prototype.toString = function () {
            return JSON.stringify(this.value());
        };

        return ArrayValue;
    }(FieldValue);

    var NumberAsAny = Number;
    var MIN_SAFE_INTEGER = NumberAsAny.MIN_SAFE_INTEGER || -(Math.pow(2, 53) - 1);
    var MAX_SAFE_INTEGER = NumberAsAny.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;

    var isInteger = NumberAsAny.isInteger || function (value) {
        return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
    };

    function isNullOrUndefined(value) {
        return value === null || value === undefined;
    }

    function isSafeInteger(value) {
        return isInteger(value) && value <= MAX_SAFE_INTEGER && value >= MIN_SAFE_INTEGER;
    }

    var Query = function () {
        function Query(path, explicitOrderBy, filters, limit, startAt, endAt) {
            if (explicitOrderBy === void 0) {
                explicitOrderBy = [];
            }

            if (filters === void 0) {
                filters = [];
            }

            if (limit === void 0) {
                limit = null;
            }

            if (startAt === void 0) {
                startAt = null;
            }

            if (endAt === void 0) {
                endAt = null;
            }

            this.path = path;
            this.explicitOrderBy = explicitOrderBy;
            this.filters = filters;
            this.limit = limit;
            this.startAt = startAt;
            this.endAt = endAt;
            this.memoizedCanonicalId = null;
            this.memoizedOrderBy = null;

            if (this.startAt) {
                this.assertValidBound(this.startAt);
            }

            if (this.endAt) {
                this.assertValidBound(this.endAt);
            }
        }

        Query.atPath = function (path) {
            return new Query(path);
        };

        Object.defineProperty(Query.prototype, "orderBy", {
            get: function get() {
                if (this.memoizedOrderBy === null) {
                    var inequalityField = this.getInequalityFilterField();
                    var firstOrderByField = this.getFirstOrderByField();

                    if (inequalityField !== null && firstOrderByField === null) {
                        if (inequalityField.isKeyField()) {
                            this.memoizedOrderBy = [KEY_ORDERING_ASC];
                        } else {
                            this.memoizedOrderBy = [new OrderBy(inequalityField), KEY_ORDERING_ASC];
                        }
                    } else {
                        assert(inequalityField === null || firstOrderByField !== null && inequalityField.isEqual(firstOrderByField), 'First orderBy should match inequality field.');
                        this.memoizedOrderBy = [];
                        var foundKeyOrdering = false;

                        for (var _i = 0, _a = this.explicitOrderBy; _i < _a.length; _i++) {
                            var orderBy = _a[_i];
                            this.memoizedOrderBy.push(orderBy);

                            if (orderBy.field.isKeyField()) {
                                foundKeyOrdering = true;
                            }
                        }

                        if (!foundKeyOrdering) {
                            var lastDirection = this.explicitOrderBy.length > 0 ? this.explicitOrderBy[this.explicitOrderBy.length - 1].dir : Direction.ASCENDING;
                            this.memoizedOrderBy.push(lastDirection === Direction.ASCENDING ? KEY_ORDERING_ASC : KEY_ORDERING_DESC);
                        }
                    }
                }

                return this.memoizedOrderBy;
            },
            enumerable: true,
            configurable: true
        });

        Query.prototype.addFilter = function (filter) {
            assert(this.getInequalityFilterField() == null || !(filter instanceof RelationFilter) || !filter.isInequality() || filter.field.isEqual(this.getInequalityFilterField()), 'Query must only have one inequality field.');
            assert(!DocumentKey.isDocumentKey(this.path), 'No filtering allowed for document query');
            var newFilters = this.filters.concat([filter]);
            return new Query(this.path, this.explicitOrderBy.slice(), newFilters, this.limit, this.startAt, this.endAt);
        };

        Query.prototype.addOrderBy = function (orderBy) {
            assert(!DocumentKey.isDocumentKey(this.path), 'No ordering allowed for document query');
            assert(!this.startAt && !this.endAt, 'Bounds must be set after orderBy');
            var newOrderBy = this.explicitOrderBy.concat([orderBy]);
            return new Query(this.path, newOrderBy, this.filters.slice(), this.limit, this.startAt, this.endAt);
        };

        Query.prototype.withLimit = function (limit) {
            return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), limit, this.startAt, this.endAt);
        };

        Query.prototype.withStartAt = function (bound) {
            return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, bound, this.endAt);
        };

        Query.prototype.withEndAt = function (bound) {
            return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, this.startAt, bound);
        };

        Query.prototype.canonicalId = function () {
            if (this.memoizedCanonicalId === null) {
                var canonicalId = this.path.canonicalString();
                canonicalId += '|f:';

                for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {
                    var filter = _a[_i];
                    canonicalId += filter.canonicalId();
                    canonicalId += ',';
                }

                canonicalId += '|ob:';

                for (var _b = 0, _c = this.orderBy; _b < _c.length; _b++) {
                    var orderBy = _c[_b];
                    canonicalId += orderBy.canonicalId();
                    canonicalId += ',';
                }

                if (!isNullOrUndefined(this.limit)) {
                    canonicalId += '|l:';
                    canonicalId += this.limit;
                }

                if (this.startAt) {
                    canonicalId += '|lb:';
                    canonicalId += this.startAt.canonicalId();
                }

                if (this.endAt) {
                    canonicalId += '|ub:';
                    canonicalId += this.endAt.canonicalId();
                }

                this.memoizedCanonicalId = canonicalId;
            }

            return this.memoizedCanonicalId;
        };

        Query.prototype.toString = function () {
            var str = 'Query(' + this.path.canonicalString();

            if (this.filters.length > 0) {
                str += ", filters: [" + this.filters.join(', ') + "]";
            }

            if (!isNullOrUndefined(this.limit)) {
                str += ', limit: ' + this.limit;
            }

            if (this.explicitOrderBy.length > 0) {
                str += ", orderBy: [" + this.explicitOrderBy.join(', ') + "]";
            }

            if (this.startAt) {
                str += ', startAt: ' + this.startAt.canonicalId();
            }

            if (this.endAt) {
                str += ', endAt: ' + this.endAt.canonicalId();
            }

            return str + ')';
        };

        Query.prototype.isEqual = function (other) {
            if (this.limit !== other.limit) {
                return false;
            }

            if (this.orderBy.length !== other.orderBy.length) {
                return false;
            }

            for (var i = 0; i < this.orderBy.length; i++) {
                if (!this.orderBy[i].isEqual(other.orderBy[i])) {
                    return false;
                }
            }

            if (this.filters.length !== other.filters.length) {
                return false;
            }

            for (var i = 0; i < this.filters.length; i++) {
                if (!this.filters[i].isEqual(other.filters[i])) {
                    return false;
                }
            }

            if (!this.path.isEqual(other.path)) {
                return false;
            }

            if (this.startAt !== null ? !this.startAt.isEqual(other.startAt) : other.startAt !== null) {
                return false;
            }

            return this.endAt !== null ? this.endAt.isEqual(other.endAt) : other.endAt === null;
        };

        Query.prototype.docComparator = function (d1, d2) {
            var comparedOnKeyField = false;

            for (var _i = 0, _a = this.orderBy; _i < _a.length; _i++) {
                var orderBy = _a[_i];
                var comp = orderBy.compare(d1, d2);
                if (comp !== 0) return comp;
                comparedOnKeyField = comparedOnKeyField || orderBy.field.isKeyField();
            }

            assert(comparedOnKeyField, "orderBy used that doesn't compare on key field");
            return 0;
        };

        Query.prototype.matches = function (doc) {
            return this.matchesAncestor(doc) && this.matchesOrderBy(doc) && this.matchesFilters(doc) && this.matchesBounds(doc);
        };

        Query.prototype.hasLimit = function () {
            return !isNullOrUndefined(this.limit);
        };

        Query.prototype.getFirstOrderByField = function () {
            return this.explicitOrderBy.length > 0 ? this.explicitOrderBy[0].field : null;
        };

        Query.prototype.getInequalityFilterField = function () {
            for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {
                var filter = _a[_i];

                if (filter instanceof RelationFilter && filter.isInequality()) {
                    return filter.field;
                }
            }

            return null;
        };

        Query.prototype.hasArrayContainsFilter = function () {
            return this.filters.find(function (filter) {
                return filter instanceof RelationFilter && filter.op === RelationOp.ARRAY_CONTAINS;
            }) !== undefined;
        };

        Query.prototype.isDocumentQuery = function () {
            return DocumentKey.isDocumentKey(this.path) && this.filters.length === 0;
        };

        Query.prototype.matchesAncestor = function (doc) {
            var docPath = doc.key.path;

            if (DocumentKey.isDocumentKey(this.path)) {
                return this.path.isEqual(docPath);
            } else {
                return this.path.isPrefixOf(docPath) && this.path.length === docPath.length - 1;
            }
        };

        Query.prototype.matchesOrderBy = function (doc) {
            for (var _i = 0, _a = this.explicitOrderBy; _i < _a.length; _i++) {
                var orderBy = _a[_i];

                if (!orderBy.field.isKeyField() && doc.field(orderBy.field) === undefined) {
                    return false;
                }
            }

            return true;
        };

        Query.prototype.matchesFilters = function (doc) {
            for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {
                var filter = _a[_i];

                if (!filter.matches(doc)) {
                    return false;
                }
            }

            return true;
        };

        Query.prototype.matchesBounds = function (doc) {
            if (this.startAt && !this.startAt.sortsBeforeDocument(this.orderBy, doc)) {
                return false;
            }

            if (this.endAt && this.endAt.sortsBeforeDocument(this.orderBy, doc)) {
                return false;
            }

            return true;
        };

        Query.prototype.assertValidBound = function (bound) {
            assert(bound.position.length <= this.orderBy.length, 'Bound is longer than orderBy');
        };

        return Query;
    }();

    var Filter = function () {
        function Filter() {}

        Filter.create = function (field, op, value) {
            if (value.isEqual(NullValue.INSTANCE)) {
                if (op !== RelationOp.EQUAL) {
                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You can only perform equals comparisons on null.');
                }

                return new NullFilter(field);
            } else if (value.isEqual(DoubleValue.NAN)) {
                if (op !== RelationOp.EQUAL) {
                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You can only perform equals comparisons on NaN.');
                }

                return new NanFilter(field);
            } else {
                return new RelationFilter(field, op, value);
            }
        };

        return Filter;
    }();

    var RelationOp = function () {
        function RelationOp(name) {
            this.name = name;
        }

        RelationOp.fromString = function (op) {
            switch (op) {
                case '<':
                    return RelationOp.LESS_THAN;

                case '<=':
                    return RelationOp.LESS_THAN_OR_EQUAL;

                case '==':
                    return RelationOp.EQUAL;

                case '>=':
                    return RelationOp.GREATER_THAN_OR_EQUAL;

                case '>':
                    return RelationOp.GREATER_THAN;

                case 'array-contains':
                    return RelationOp.ARRAY_CONTAINS;

                default:
                    return fail('Unknown relation: ' + op);
            }
        };

        RelationOp.prototype.toString = function () {
            return this.name;
        };

        RelationOp.prototype.isEqual = function (other) {
            return this.name === other.name;
        };

        RelationOp.LESS_THAN = new RelationOp('<');
        RelationOp.LESS_THAN_OR_EQUAL = new RelationOp('<=');
        RelationOp.EQUAL = new RelationOp('==');
        RelationOp.GREATER_THAN = new RelationOp('>');
        RelationOp.GREATER_THAN_OR_EQUAL = new RelationOp('>=');
        RelationOp.ARRAY_CONTAINS = new RelationOp('array-contains');
        return RelationOp;
    }();

    var RelationFilter = function (_super) {
        tslib_1.__extends(RelationFilter, _super);

        function RelationFilter(field, op, value) {
            var _this = _super.call(this) || this;

            _this.field = field;
            _this.op = op;
            _this.value = value;
            return _this;
        }

        RelationFilter.prototype.matches = function (doc) {
            if (this.field.isKeyField()) {
                assert(this.value instanceof RefValue, 'Comparing on key, but filter value not a RefValue');
                assert(this.op !== RelationOp.ARRAY_CONTAINS, "array-contains queries don't make sense on document keys.");
                var refValue = this.value;
                var comparison = DocumentKey.comparator(doc.key, refValue.key);
                return this.matchesComparison(comparison);
            } else {
                var val = doc.field(this.field);
                return val !== undefined && this.matchesValue(val);
            }
        };

        RelationFilter.prototype.matchesValue = function (value) {
            var _this = this;

            if (this.op === RelationOp.ARRAY_CONTAINS) {
                return value instanceof ArrayValue && value.internalValue.find(function (element) {
                    return element.isEqual(_this.value);
                }) !== undefined;
            } else {
                return this.value.typeOrder === value.typeOrder && this.matchesComparison(value.compareTo(this.value));
            }
        };

        RelationFilter.prototype.matchesComparison = function (comparison) {
            switch (this.op) {
                case RelationOp.LESS_THAN:
                    return comparison < 0;

                case RelationOp.LESS_THAN_OR_EQUAL:
                    return comparison <= 0;

                case RelationOp.EQUAL:
                    return comparison === 0;

                case RelationOp.GREATER_THAN:
                    return comparison > 0;

                case RelationOp.GREATER_THAN_OR_EQUAL:
                    return comparison >= 0;

                default:
                    return fail('Unknown relation op' + this.op);
            }
        };

        RelationFilter.prototype.isInequality = function () {
            return this.op !== RelationOp.EQUAL && this.op !== RelationOp.ARRAY_CONTAINS;
        };

        RelationFilter.prototype.canonicalId = function () {
            return this.field.canonicalString() + this.op.toString() + this.value.toString();
        };

        RelationFilter.prototype.isEqual = function (other) {
            if (other instanceof RelationFilter) {
                return this.op.isEqual(other.op) && this.field.isEqual(other.field) && this.value.isEqual(other.value);
            } else {
                return false;
            }
        };

        RelationFilter.prototype.toString = function () {
            return this.field.canonicalString() + " " + this.op + " " + this.value.value();
        };

        return RelationFilter;
    }(Filter);

    var NullFilter = function (_super) {
        tslib_1.__extends(NullFilter, _super);

        function NullFilter(field) {
            var _this = _super.call(this) || this;

            _this.field = field;
            return _this;
        }

        NullFilter.prototype.matches = function (doc) {
            var val = doc.field(this.field);
            return val !== undefined && val.value() === null;
        };

        NullFilter.prototype.canonicalId = function () {
            return this.field.canonicalString() + ' IS null';
        };

        NullFilter.prototype.toString = function () {
            return this.field.canonicalString() + " IS null";
        };

        NullFilter.prototype.isEqual = function (other) {
            if (other instanceof NullFilter) {
                return this.field.isEqual(other.field);
            } else {
                return false;
            }
        };

        return NullFilter;
    }(Filter);

    var NanFilter = function (_super) {
        tslib_1.__extends(NanFilter, _super);

        function NanFilter(field) {
            var _this = _super.call(this) || this;

            _this.field = field;
            return _this;
        }

        NanFilter.prototype.matches = function (doc) {
            var field = doc.field(this.field);
            var val = field && field.value();
            return typeof val === 'number' && isNaN(val);
        };

        NanFilter.prototype.canonicalId = function () {
            return this.field.canonicalString() + ' IS NaN';
        };

        NanFilter.prototype.toString = function () {
            return this.field.canonicalString() + " IS NaN";
        };

        NanFilter.prototype.isEqual = function (other) {
            if (other instanceof NanFilter) {
                return this.field.isEqual(other.field);
            } else {
                return false;
            }
        };

        return NanFilter;
    }(Filter);

    var Direction = function () {
        function Direction(name) {
            this.name = name;
        }

        Direction.prototype.toString = function () {
            return this.name;
        };

        Direction.ASCENDING = new Direction('asc');
        Direction.DESCENDING = new Direction('desc');
        return Direction;
    }();

    var Bound = function () {
        function Bound(position, before) {
            this.position = position;
            this.before = before;
        }

        Bound.prototype.canonicalId = function () {
            var canonicalId = this.before ? 'b:' : 'a:';

            for (var _i = 0, _a = this.position; _i < _a.length; _i++) {
                var component = _a[_i];
                canonicalId += component.toString();
            }

            return canonicalId;
        };

        Bound.prototype.sortsBeforeDocument = function (orderBy, doc) {
            assert(this.position.length <= orderBy.length, "Bound has more components than query's orderBy");
            var comparison = 0;

            for (var i = 0; i < this.position.length; i++) {
                var orderByComponent = orderBy[i];
                var component = this.position[i];

                if (orderByComponent.field.isKeyField()) {
                    assert(component instanceof RefValue, 'Bound has a non-key value where the key path is being used.');
                    comparison = DocumentKey.comparator(component.key, doc.key);
                } else {
                    var docValue = doc.field(orderByComponent.field);
                    assert(docValue !== undefined, 'Field should exist since document matched the orderBy already.');
                    comparison = component.compareTo(docValue);
                }

                if (orderByComponent.dir === Direction.DESCENDING) {
                    comparison = comparison * -1;
                }

                if (comparison !== 0) {
                    break;
                }
            }

            return this.before ? comparison <= 0 : comparison < 0;
        };

        Bound.prototype.isEqual = function (other) {
            if (other === null) {
                return false;
            }

            if (this.before !== other.before || this.position.length !== other.position.length) {
                return false;
            }

            for (var i = 0; i < this.position.length; i++) {
                var thisPosition = this.position[i];
                var otherPosition = other.position[i];
                return thisPosition.isEqual(otherPosition);
            }

            return true;
        };

        return Bound;
    }();

    var OrderBy = function () {
        function OrderBy(field, dir) {
            this.field = field;

            if (dir === undefined) {
                dir = Direction.ASCENDING;
            }

            this.dir = dir;
            this.isKeyOrderBy = field.isKeyField();
        }

        OrderBy.prototype.compare = function (d1, d2) {
            var comparison = this.isKeyOrderBy ? Document.compareByKey(d1, d2) : Document.compareByField(this.field, d1, d2);

            switch (this.dir) {
                case Direction.ASCENDING:
                    return comparison;

                case Direction.DESCENDING:
                    return -1 * comparison;

                default:
                    return fail('Unknown direction: ' + this.dir);
            }
        };

        OrderBy.prototype.canonicalId = function () {
            return this.field.canonicalString() + this.dir.toString();
        };

        OrderBy.prototype.toString = function () {
            return this.field.canonicalString() + " (" + this.dir + ")";
        };

        OrderBy.prototype.isEqual = function (other) {
            return this.dir === other.dir && this.field.isEqual(other.field);
        };

        return OrderBy;
    }();

    var KEY_ORDERING_ASC = new OrderBy(FieldPath.keyField(), Direction.ASCENDING);
    var KEY_ORDERING_DESC = new OrderBy(FieldPath.keyField(), Direction.DESCENDING);

    var SnapshotVersion = function () {
        function SnapshotVersion(timestamp) {
            this.timestamp = timestamp;
        }

        SnapshotVersion.fromMicroseconds = function (value) {
            var seconds = Math.floor(value / 1e6);
            var nanos = value % 1e6 * 1e3;
            return new SnapshotVersion(new Timestamp(seconds, nanos));
        };

        SnapshotVersion.fromTimestamp = function (value) {
            return new SnapshotVersion(value);
        };

        SnapshotVersion.forDeletedDoc = function () {
            return SnapshotVersion.MIN;
        };

        SnapshotVersion.prototype.compareTo = function (other) {
            return this.timestamp._compareTo(other.timestamp);
        };

        SnapshotVersion.prototype.isEqual = function (other) {
            return this.timestamp.isEqual(other.timestamp);
        };

        SnapshotVersion.prototype.toMicroseconds = function () {
            return this.timestamp.seconds * 1e6 + this.timestamp.nanoseconds / 1000;
        };

        SnapshotVersion.prototype.toString = function () {
            return 'SnapshotVersion(' + this.timestamp.toString() + ')';
        };

        SnapshotVersion.prototype.toTimestamp = function () {
            return this.timestamp;
        };

        SnapshotVersion.MIN = new SnapshotVersion(new Timestamp(0, 0));
        return SnapshotVersion;
    }();

    var QueryPurpose;

    (function (QueryPurpose) {
        QueryPurpose[QueryPurpose["Listen"] = 0] = "Listen";
        QueryPurpose[QueryPurpose["ExistenceFilterMismatch"] = 1] = "ExistenceFilterMismatch";
        QueryPurpose[QueryPurpose["LimboResolution"] = 2] = "LimboResolution";
    })(QueryPurpose || (QueryPurpose = {}));

    var QueryData = function () {
        function QueryData(query, targetId, purpose, sequenceNumber, snapshotVersion, resumeToken) {
            if (snapshotVersion === void 0) {
                snapshotVersion = SnapshotVersion.MIN;
            }

            if (resumeToken === void 0) {
                resumeToken = emptyByteString();
            }

            this.query = query;
            this.targetId = targetId;
            this.purpose = purpose;
            this.sequenceNumber = sequenceNumber;
            this.snapshotVersion = snapshotVersion;
            this.resumeToken = resumeToken;
        }

        QueryData.prototype.copy = function (overwrite) {
            return new QueryData(this.query, this.targetId, this.purpose, overwrite.sequenceNumber === undefined ? this.sequenceNumber : overwrite.sequenceNumber, overwrite.snapshotVersion === undefined ? this.snapshotVersion : overwrite.snapshotVersion, overwrite.resumeToken === undefined ? this.resumeToken : overwrite.resumeToken);
        };

        QueryData.prototype.isEqual = function (other) {
            return this.targetId === other.targetId && this.purpose === other.purpose && this.sequenceNumber === other.sequenceNumber && this.snapshotVersion.isEqual(other.snapshotVersion) && this.resumeToken === other.resumeToken && this.query.isEqual(other.query);
        };

        return QueryData;
    }();

    var FieldMask = function () {
        function FieldMask(fields) {
            this.fields = fields;
        }

        FieldMask.prototype.covers = function (fieldPath) {
            for (var _i = 0, _a = this.fields; _i < _a.length; _i++) {
                var fieldMaskPath = _a[_i];

                if (fieldMaskPath.isPrefixOf(fieldPath)) {
                    return true;
                }
            }

            return false;
        };

        FieldMask.prototype.isEqual = function (other) {
            return arrayEquals(this.fields, other.fields);
        };

        return FieldMask;
    }();

    var FieldTransform = function () {
        function FieldTransform(field, transform) {
            this.field = field;
            this.transform = transform;
        }

        FieldTransform.prototype.isEqual = function (other) {
            return this.field.isEqual(other.field) && this.transform.isEqual(other.transform);
        };

        return FieldTransform;
    }();

    var MutationResult = function () {
        function MutationResult(version, transformResults) {
            this.version = version;
            this.transformResults = transformResults;
        }

        return MutationResult;
    }();

    var MutationType;

    (function (MutationType) {
        MutationType[MutationType["Set"] = 0] = "Set";
        MutationType[MutationType["Patch"] = 1] = "Patch";
        MutationType[MutationType["Transform"] = 2] = "Transform";
        MutationType[MutationType["Delete"] = 3] = "Delete";
    })(MutationType || (MutationType = {}));

    var Precondition = function () {
        function Precondition(updateTime, exists) {
            this.updateTime = updateTime;
            this.exists = exists;
            assert(updateTime === undefined || exists === undefined, 'Precondition can specify "exists" or "updateTime" but not both');
        }

        Precondition.exists = function (exists) {
            return new Precondition(undefined, exists);
        };

        Precondition.updateTime = function (version) {
            return new Precondition(version);
        };

        Object.defineProperty(Precondition.prototype, "isNone", {
            get: function get() {
                return this.updateTime === undefined && this.exists === undefined;
            },
            enumerable: true,
            configurable: true
        });

        Precondition.prototype.isValidFor = function (maybeDoc) {
            if (this.updateTime !== undefined) {
                return maybeDoc instanceof Document && maybeDoc.version.isEqual(this.updateTime);
            } else if (this.exists !== undefined) {
                return this.exists === maybeDoc instanceof Document;
            } else {
                assert(this.isNone, 'Precondition should be empty');
                return true;
            }
        };

        Precondition.prototype.isEqual = function (other) {
            return equals(this.updateTime, other.updateTime) && this.exists === other.exists;
        };

        Precondition.NONE = new Precondition();
        return Precondition;
    }();

    var Mutation = function () {
        function Mutation() {}

        Mutation.prototype.verifyKeyMatches = function (maybeDoc) {
            if (maybeDoc != null) {
                assert(maybeDoc.key.isEqual(this.key), 'Can only apply a mutation to a document with the same key');
            }
        };

        Mutation.getPostMutationVersion = function (maybeDoc) {
            if (maybeDoc instanceof Document) {
                return maybeDoc.version;
            } else {
                return SnapshotVersion.MIN;
            }
        };

        return Mutation;
    }();

    var SetMutation = function (_super) {
        tslib_1.__extends(SetMutation, _super);

        function SetMutation(key, value, precondition) {
            var _this = _super.call(this) || this;

            _this.key = key;
            _this.value = value;
            _this.precondition = precondition;
            _this.type = MutationType.Set;
            return _this;
        }

        SetMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {
            this.verifyKeyMatches(maybeDoc);
            assert(mutationResult.transformResults == null, 'Transform results received by SetMutation.');
            var version = mutationResult.version;
            return new Document(this.key, version, this.value, {
                hasCommittedMutations: true
            });
        };

        SetMutation.prototype.applyToLocalView = function (maybeDoc, baseDoc, localWriteTime) {
            this.verifyKeyMatches(maybeDoc);

            if (!this.precondition.isValidFor(maybeDoc)) {
                return maybeDoc;
            }

            var version = Mutation.getPostMutationVersion(maybeDoc);
            return new Document(this.key, version, this.value, {
                hasLocalMutations: true
            });
        };

        SetMutation.prototype.isEqual = function (other) {
            return other instanceof SetMutation && this.key.isEqual(other.key) && this.value.isEqual(other.value) && this.precondition.isEqual(other.precondition);
        };

        return SetMutation;
    }(Mutation);

    var PatchMutation = function (_super) {
        tslib_1.__extends(PatchMutation, _super);

        function PatchMutation(key, data, fieldMask, precondition) {
            var _this = _super.call(this) || this;

            _this.key = key;
            _this.data = data;
            _this.fieldMask = fieldMask;
            _this.precondition = precondition;
            _this.type = MutationType.Patch;
            return _this;
        }

        PatchMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {
            this.verifyKeyMatches(maybeDoc);
            assert(mutationResult.transformResults == null, 'Transform results received by PatchMutation.');

            if (!this.precondition.isValidFor(maybeDoc)) {
                return new UnknownDocument(this.key, mutationResult.version);
            }

            var newData = this.patchDocument(maybeDoc);
            return new Document(this.key, mutationResult.version, newData, {
                hasCommittedMutations: true
            });
        };

        PatchMutation.prototype.applyToLocalView = function (maybeDoc, baseDoc, localWriteTime) {
            this.verifyKeyMatches(maybeDoc);

            if (!this.precondition.isValidFor(maybeDoc)) {
                return maybeDoc;
            }

            var version = Mutation.getPostMutationVersion(maybeDoc);
            var newData = this.patchDocument(maybeDoc);
            return new Document(this.key, version, newData, {
                hasLocalMutations: true
            });
        };

        PatchMutation.prototype.isEqual = function (other) {
            return other instanceof PatchMutation && this.key.isEqual(other.key) && this.fieldMask.isEqual(other.fieldMask) && this.precondition.isEqual(other.precondition);
        };

        PatchMutation.prototype.patchDocument = function (maybeDoc) {
            var data;

            if (maybeDoc instanceof Document) {
                data = maybeDoc.data;
            } else {
                data = ObjectValue.EMPTY;
            }

            return this.patchObject(data);
        };

        PatchMutation.prototype.patchObject = function (data) {
            for (var _i = 0, _a = this.fieldMask.fields; _i < _a.length; _i++) {
                var fieldPath = _a[_i];

                if (!fieldPath.isEmpty()) {
                    var newValue = this.data.field(fieldPath);

                    if (newValue !== undefined) {
                        data = data.set(fieldPath, newValue);
                    } else {
                        data = data.delete(fieldPath);
                    }
                }
            }

            return data;
        };

        return PatchMutation;
    }(Mutation);

    var TransformMutation = function (_super) {
        tslib_1.__extends(TransformMutation, _super);

        function TransformMutation(key, fieldTransforms) {
            var _this = _super.call(this) || this;

            _this.key = key;
            _this.fieldTransforms = fieldTransforms;
            _this.type = MutationType.Transform;
            _this.precondition = Precondition.exists(true);
            return _this;
        }

        TransformMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {
            this.verifyKeyMatches(maybeDoc);
            assert(mutationResult.transformResults != null, 'Transform results missing for TransformMutation.');

            if (!this.precondition.isValidFor(maybeDoc)) {
                return new UnknownDocument(this.key, mutationResult.version);
            }

            var doc = this.requireDocument(maybeDoc);
            var transformResults = this.serverTransformResults(maybeDoc, mutationResult.transformResults);
            var version = mutationResult.version;
            var newData = this.transformObject(doc.data, transformResults);
            return new Document(this.key, version, newData, {
                hasCommittedMutations: true
            });
        };

        TransformMutation.prototype.applyToLocalView = function (maybeDoc, baseDoc, localWriteTime) {
            this.verifyKeyMatches(maybeDoc);

            if (!this.precondition.isValidFor(maybeDoc)) {
                return maybeDoc;
            }

            var doc = this.requireDocument(maybeDoc);
            var transformResults = this.localTransformResults(localWriteTime, baseDoc);
            var newData = this.transformObject(doc.data, transformResults);
            return new Document(this.key, doc.version, newData, {
                hasLocalMutations: true
            });
        };

        TransformMutation.prototype.isEqual = function (other) {
            return other instanceof TransformMutation && this.key.isEqual(other.key) && arrayEquals(this.fieldTransforms, other.fieldTransforms) && this.precondition.isEqual(other.precondition);
        };

        TransformMutation.prototype.requireDocument = function (maybeDoc) {
            assert(maybeDoc instanceof Document, 'Unknown MaybeDocument type ' + maybeDoc);
            var doc = maybeDoc;
            assert(doc.key.isEqual(this.key), 'Can only transform a document with the same key');
            return doc;
        };

        TransformMutation.prototype.serverTransformResults = function (baseDoc, serverTransformResults) {
            var transformResults = [];
            assert(this.fieldTransforms.length === serverTransformResults.length, "server transform result count (" + serverTransformResults.length + ") " + ("should match field transform count (" + this.fieldTransforms.length + ")"));

            for (var i = 0; i < serverTransformResults.length; i++) {
                var fieldTransform = this.fieldTransforms[i];
                var transform = fieldTransform.transform;
                var previousValue = null;

                if (baseDoc instanceof Document) {
                    previousValue = baseDoc.field(fieldTransform.field) || null;
                }

                transformResults.push(transform.applyToRemoteDocument(previousValue, serverTransformResults[i]));
            }

            return transformResults;
        };

        TransformMutation.prototype.localTransformResults = function (localWriteTime, baseDoc) {
            var transformResults = [];

            for (var _i = 0, _a = this.fieldTransforms; _i < _a.length; _i++) {
                var fieldTransform = _a[_i];
                var transform = fieldTransform.transform;
                var previousValue = null;

                if (baseDoc instanceof Document) {
                    previousValue = baseDoc.field(fieldTransform.field) || null;
                }

                transformResults.push(transform.applyToLocalView(previousValue, localWriteTime));
            }

            return transformResults;
        };

        TransformMutation.prototype.transformObject = function (data, transformResults) {
            assert(transformResults.length === this.fieldTransforms.length, 'TransformResults length mismatch.');

            for (var i = 0; i < this.fieldTransforms.length; i++) {
                var fieldTransform = this.fieldTransforms[i];
                var fieldPath = fieldTransform.field;
                data = data.set(fieldPath, transformResults[i]);
            }

            return data;
        };

        return TransformMutation;
    }(Mutation);

    var DeleteMutation = function (_super) {
        tslib_1.__extends(DeleteMutation, _super);

        function DeleteMutation(key, precondition) {
            var _this = _super.call(this) || this;

            _this.key = key;
            _this.precondition = precondition;
            _this.type = MutationType.Delete;
            return _this;
        }

        DeleteMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {
            this.verifyKeyMatches(maybeDoc);
            assert(mutationResult.transformResults == null, 'Transform results received by DeleteMutation.');
            return new NoDocument(this.key, mutationResult.version, {
                hasCommittedMutations: true
            });
        };

        DeleteMutation.prototype.applyToLocalView = function (maybeDoc, baseDoc, localWriteTime) {
            this.verifyKeyMatches(maybeDoc);

            if (!this.precondition.isValidFor(maybeDoc)) {
                return maybeDoc;
            }

            if (maybeDoc) {
                assert(maybeDoc.key.isEqual(this.key), 'Can only apply mutation to document with same key');
            }

            return new NoDocument(this.key, SnapshotVersion.forDeletedDoc());
        };

        DeleteMutation.prototype.isEqual = function (other) {
            return other instanceof DeleteMutation && this.key.isEqual(other.key) && this.precondition.isEqual(other.precondition);
        };

        return DeleteMutation;
    }(Mutation);

    var ServerTimestampTransform = function () {
        function ServerTimestampTransform() {}

        ServerTimestampTransform.prototype.applyToLocalView = function (previousValue, localWriteTime) {
            return new ServerTimestampValue(localWriteTime, previousValue);
        };

        ServerTimestampTransform.prototype.applyToRemoteDocument = function (previousValue, transformResult) {
            return transformResult;
        };

        ServerTimestampTransform.prototype.isEqual = function (other) {
            return other instanceof ServerTimestampTransform;
        };

        ServerTimestampTransform.instance = new ServerTimestampTransform();
        return ServerTimestampTransform;
    }();

    var ArrayUnionTransformOperation = function () {
        function ArrayUnionTransformOperation(elements) {
            this.elements = elements;
        }

        ArrayUnionTransformOperation.prototype.applyToLocalView = function (previousValue, localWriteTime) {
            return this.apply(previousValue);
        };

        ArrayUnionTransformOperation.prototype.applyToRemoteDocument = function (previousValue, transformResult) {
            return this.apply(previousValue);
        };

        ArrayUnionTransformOperation.prototype.apply = function (previousValue) {
            var result = coercedFieldValuesArray(previousValue);

            var _loop_1 = function _loop_1(toUnion) {
                if (!result.find(function (element) {
                    return element.isEqual(toUnion);
                })) {
                    result.push(toUnion);
                }
            };

            for (var _i = 0, _a = this.elements; _i < _a.length; _i++) {
                var toUnion = _a[_i];

                _loop_1(toUnion);
            }

            return new ArrayValue(result);
        };

        ArrayUnionTransformOperation.prototype.isEqual = function (other) {
            return other instanceof ArrayUnionTransformOperation && arrayEquals(other.elements, this.elements);
        };

        return ArrayUnionTransformOperation;
    }();

    var ArrayRemoveTransformOperation = function () {
        function ArrayRemoveTransformOperation(elements) {
            this.elements = elements;
        }

        ArrayRemoveTransformOperation.prototype.applyToLocalView = function (previousValue, localWriteTime) {
            return this.apply(previousValue);
        };

        ArrayRemoveTransformOperation.prototype.applyToRemoteDocument = function (previousValue, transformResult) {
            return this.apply(previousValue);
        };

        ArrayRemoveTransformOperation.prototype.apply = function (previousValue) {
            var result = coercedFieldValuesArray(previousValue);

            var _loop_2 = function _loop_2(toRemove) {
                result = result.filter(function (element) {
                    return !element.isEqual(toRemove);
                });
            };

            for (var _i = 0, _a = this.elements; _i < _a.length; _i++) {
                var toRemove = _a[_i];

                _loop_2(toRemove);
            }

            return new ArrayValue(result);
        };

        ArrayRemoveTransformOperation.prototype.isEqual = function (other) {
            return other instanceof ArrayRemoveTransformOperation && arrayEquals(other.elements, this.elements);
        };

        return ArrayRemoveTransformOperation;
    }();

    function coercedFieldValuesArray(value) {
        if (value instanceof ArrayValue) {
            return value.internalValue.slice();
        } else {
            return [];
        }
    }

    var ExistenceFilter = function () {
        function ExistenceFilter(count) {
            this.count = count;
        }

        ExistenceFilter.prototype.isEqual = function (other) {
            return other && other.count === this.count;
        };

        return ExistenceFilter;
    }();

    var RpcCode;

    (function (RpcCode) {
        RpcCode[RpcCode["OK"] = 0] = "OK";
        RpcCode[RpcCode["CANCELLED"] = 1] = "CANCELLED";
        RpcCode[RpcCode["UNKNOWN"] = 2] = "UNKNOWN";
        RpcCode[RpcCode["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
        RpcCode[RpcCode["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
        RpcCode[RpcCode["NOT_FOUND"] = 5] = "NOT_FOUND";
        RpcCode[RpcCode["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
        RpcCode[RpcCode["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
        RpcCode[RpcCode["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
        RpcCode[RpcCode["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
        RpcCode[RpcCode["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
        RpcCode[RpcCode["ABORTED"] = 10] = "ABORTED";
        RpcCode[RpcCode["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
        RpcCode[RpcCode["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
        RpcCode[RpcCode["INTERNAL"] = 13] = "INTERNAL";
        RpcCode[RpcCode["UNAVAILABLE"] = 14] = "UNAVAILABLE";
        RpcCode[RpcCode["DATA_LOSS"] = 15] = "DATA_LOSS";
    })(RpcCode || (RpcCode = {}));

    function isPermanentError(code) {
        switch (code) {
            case Code.OK:
                return fail('Treated status OK as error');

            case Code.CANCELLED:
            case Code.UNKNOWN:
            case Code.DEADLINE_EXCEEDED:
            case Code.RESOURCE_EXHAUSTED:
            case Code.INTERNAL:
            case Code.UNAVAILABLE:
            case Code.UNAUTHENTICATED:
                return false;

            case Code.INVALID_ARGUMENT:
            case Code.NOT_FOUND:
            case Code.ALREADY_EXISTS:
            case Code.PERMISSION_DENIED:
            case Code.FAILED_PRECONDITION:
            case Code.ABORTED:
            case Code.OUT_OF_RANGE:
            case Code.UNIMPLEMENTED:
            case Code.DATA_LOSS:
                return true;

            default:
                return fail('Unknown status code: ' + code);
        }
    }

    function mapCodeFromRpcStatus(status) {
        var code = RpcCode[status];

        if (code === undefined) {
            return undefined;
        }

        return mapCodeFromRpcCode(code);
    }

    function mapCodeFromRpcCode(code) {
        if (code === undefined) {
            error('GRPC error has no .code');
            return Code.UNKNOWN;
        }

        switch (code) {
            case RpcCode.OK:
                return Code.OK;

            case RpcCode.CANCELLED:
                return Code.CANCELLED;

            case RpcCode.UNKNOWN:
                return Code.UNKNOWN;

            case RpcCode.DEADLINE_EXCEEDED:
                return Code.DEADLINE_EXCEEDED;

            case RpcCode.RESOURCE_EXHAUSTED:
                return Code.RESOURCE_EXHAUSTED;

            case RpcCode.INTERNAL:
                return Code.INTERNAL;

            case RpcCode.UNAVAILABLE:
                return Code.UNAVAILABLE;

            case RpcCode.UNAUTHENTICATED:
                return Code.UNAUTHENTICATED;

            case RpcCode.INVALID_ARGUMENT:
                return Code.INVALID_ARGUMENT;

            case RpcCode.NOT_FOUND:
                return Code.NOT_FOUND;

            case RpcCode.ALREADY_EXISTS:
                return Code.ALREADY_EXISTS;

            case RpcCode.PERMISSION_DENIED:
                return Code.PERMISSION_DENIED;

            case RpcCode.FAILED_PRECONDITION:
                return Code.FAILED_PRECONDITION;

            case RpcCode.ABORTED:
                return Code.ABORTED;

            case RpcCode.OUT_OF_RANGE:
                return Code.OUT_OF_RANGE;

            case RpcCode.UNIMPLEMENTED:
                return Code.UNIMPLEMENTED;

            case RpcCode.DATA_LOSS:
                return Code.DATA_LOSS;

            default:
                return fail('Unknown status code: ' + code);
        }
    }

    function mapRpcCodeFromCode(code) {
        if (code === undefined) {
            return RpcCode.OK;
        }

        switch (code) {
            case Code.OK:
                return RpcCode.OK;

            case Code.CANCELLED:
                return RpcCode.CANCELLED;

            case Code.UNKNOWN:
                return RpcCode.UNKNOWN;

            case Code.DEADLINE_EXCEEDED:
                return RpcCode.DEADLINE_EXCEEDED;

            case Code.RESOURCE_EXHAUSTED:
                return RpcCode.RESOURCE_EXHAUSTED;

            case Code.INTERNAL:
                return RpcCode.INTERNAL;

            case Code.UNAVAILABLE:
                return RpcCode.UNAVAILABLE;

            case Code.UNAUTHENTICATED:
                return RpcCode.UNAUTHENTICATED;

            case Code.INVALID_ARGUMENT:
                return RpcCode.INVALID_ARGUMENT;

            case Code.NOT_FOUND:
                return RpcCode.NOT_FOUND;

            case Code.ALREADY_EXISTS:
                return RpcCode.ALREADY_EXISTS;

            case Code.PERMISSION_DENIED:
                return RpcCode.PERMISSION_DENIED;

            case Code.FAILED_PRECONDITION:
                return RpcCode.FAILED_PRECONDITION;

            case Code.ABORTED:
                return RpcCode.ABORTED;

            case Code.OUT_OF_RANGE:
                return RpcCode.OUT_OF_RANGE;

            case Code.UNIMPLEMENTED:
                return RpcCode.UNIMPLEMENTED;

            case Code.DATA_LOSS:
                return RpcCode.DATA_LOSS;

            default:
                return fail('Unknown status code: ' + code);
        }
    }

    function mapCodeFromHttpStatus(status) {
        switch (status) {
            case 200:
                return Code.OK;

            case 400:
                return Code.INVALID_ARGUMENT;

            case 401:
                return Code.UNAUTHENTICATED;

            case 403:
                return Code.PERMISSION_DENIED;

            case 404:
                return Code.NOT_FOUND;

            case 409:
                return Code.ABORTED;

            case 416:
                return Code.OUT_OF_RANGE;

            case 429:
                return Code.RESOURCE_EXHAUSTED;

            case 499:
                return Code.CANCELLED;

            case 500:
                return Code.UNKNOWN;

            case 501:
                return Code.UNIMPLEMENTED;

            case 503:
                return Code.UNAVAILABLE;

            case 504:
                return Code.DEADLINE_EXCEEDED;

            default:
                if (status >= 200 && status < 300) return Code.OK;
                if (status >= 400 && status < 500) return Code.FAILED_PRECONDITION;
                if (status >= 500 && status < 600) return Code.INTERNAL;
                return Code.UNKNOWN;
        }
    }

    var SortedSet = function () {
        function SortedSet(comparator) {
            this.comparator = comparator;
            this.data = new SortedMap(this.comparator);
        }

        SortedSet.fromMapKeys = function (map) {
            var keys = new SortedSet(map.comparator);
            map.forEach(function (key) {
                keys = keys.add(key);
            });
            return keys;
        };

        SortedSet.prototype.has = function (elem) {
            return this.data.get(elem) !== null;
        };

        SortedSet.prototype.first = function () {
            return this.data.minKey();
        };

        SortedSet.prototype.last = function () {
            return this.data.maxKey();
        };

        Object.defineProperty(SortedSet.prototype, "size", {
            get: function get() {
                return this.data.size;
            },
            enumerable: true,
            configurable: true
        });

        SortedSet.prototype.indexOf = function (elem) {
            return this.data.indexOf(elem);
        };

        SortedSet.prototype.forEach = function (cb) {
            this.data.inorderTraversal(function (k, v) {
                cb(k);
                return false;
            });
        };

        SortedSet.prototype.forEachInRange = function (range, cb) {
            var iter = this.data.getIteratorFrom(range[0]);

            while (iter.hasNext()) {
                var elem = iter.getNext();
                if (this.comparator(elem.key, range[1]) >= 0) return;
                cb(elem.key);
            }
        };

        SortedSet.prototype.forEachWhile = function (cb, start) {
            var iter;

            if (start !== undefined) {
                iter = this.data.getIteratorFrom(start);
            } else {
                iter = this.data.getIterator();
            }

            while (iter.hasNext()) {
                var elem = iter.getNext();
                var result = cb(elem.key);
                if (!result) return;
            }
        };

        SortedSet.prototype.firstAfterOrEqual = function (elem) {
            var iter = this.data.getIteratorFrom(elem);
            return iter.hasNext() ? iter.getNext().key : null;
        };

        SortedSet.prototype.add = function (elem) {
            return this.copy(this.data.remove(elem).insert(elem, true));
        };

        SortedSet.prototype.delete = function (elem) {
            if (!this.has(elem)) return this;
            return this.copy(this.data.remove(elem));
        };

        SortedSet.prototype.isEmpty = function () {
            return this.data.isEmpty();
        };

        SortedSet.prototype.unionWith = function (other) {
            var result = this;
            other.forEach(function (elem) {
                result = result.add(elem);
            });
            return result;
        };

        SortedSet.prototype.isEqual = function (other) {
            if (!(other instanceof SortedSet)) return false;
            if (this.size !== other.size) return false;
            var thisIt = this.data.getIterator();
            var otherIt = other.data.getIterator();

            while (thisIt.hasNext()) {
                var thisElem = thisIt.getNext().key;
                var otherElem = otherIt.getNext().key;
                if (this.comparator(thisElem, otherElem) !== 0) return false;
            }

            return true;
        };

        SortedSet.prototype.toArray = function () {
            var res = [];
            this.forEach(function (targetId) {
                res.push(targetId);
            });
            return res;
        };

        SortedSet.prototype.toString = function () {
            var result = [];
            this.forEach(function (elem) {
                return result.push(elem);
            });
            return 'SortedSet(' + result.toString() + ')';
        };

        SortedSet.prototype[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"] = function () {
            var it = this.data.getIterator();
            return {
                next: function next() {
                    if (it.hasNext()) {
                        return {
                            done: false,
                            value: it.getNext().key
                        };
                    } else {
                        return {
                            done: true,
                            value: {}
                        };
                    }
                }
            };
        };

        SortedSet.prototype.copy = function (data) {
            var result = new SortedSet(this.comparator);
            result.data = data;
            return result;
        };

        return SortedSet;
    }();

    var EMPTY_MAYBE_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);

    function maybeDocumentMap() {
        return EMPTY_MAYBE_DOCUMENT_MAP;
    }

    var EMPTY_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);

    function documentMap() {
        return EMPTY_DOCUMENT_MAP;
    }

    var EMPTY_DOCUMENT_VERSION_MAP = new SortedMap(DocumentKey.comparator);

    function documentVersionMap() {
        return EMPTY_DOCUMENT_VERSION_MAP;
    }

    var EMPTY_DOCUMENT_KEY_SET = new SortedSet(DocumentKey.comparator);

    function documentKeySet() {
        return EMPTY_DOCUMENT_KEY_SET;
    }

    var EMPTY_TARGET_ID_SET = new SortedSet(primitiveComparator);

    function targetIdSet() {
        return EMPTY_TARGET_ID_SET;
    }

    var DocumentSet = function () {
        function DocumentSet(comp) {
            if (comp) {
                this.comparator = function (d1, d2) {
                    return comp(d1, d2) || DocumentKey.comparator(d1.key, d2.key);
                };
            } else {
                this.comparator = function (d1, d2) {
                    return DocumentKey.comparator(d1.key, d2.key);
                };
            }

            this.keyedMap = documentMap();
            this.sortedSet = new SortedMap(this.comparator);
        }

        DocumentSet.emptySet = function (oldSet) {
            return new DocumentSet(oldSet.comparator);
        };

        DocumentSet.prototype.has = function (key) {
            return this.keyedMap.get(key) != null;
        };

        DocumentSet.prototype.get = function (key) {
            return this.keyedMap.get(key);
        };

        DocumentSet.prototype.first = function () {
            return this.sortedSet.minKey();
        };

        DocumentSet.prototype.last = function () {
            return this.sortedSet.maxKey();
        };

        DocumentSet.prototype.isEmpty = function () {
            return this.sortedSet.isEmpty();
        };

        DocumentSet.prototype.indexOf = function (key) {
            var doc = this.keyedMap.get(key);
            return doc ? this.sortedSet.indexOf(doc) : -1;
        };

        Object.defineProperty(DocumentSet.prototype, "size", {
            get: function get() {
                return this.sortedSet.size;
            },
            enumerable: true,
            configurable: true
        });

        DocumentSet.prototype.forEach = function (cb) {
            this.sortedSet.inorderTraversal(function (k, v) {
                cb(k);
                return false;
            });
        };

        DocumentSet.prototype.add = function (doc) {
            var set = this.delete(doc.key);
            return set.copy(set.keyedMap.insert(doc.key, doc), set.sortedSet.insert(doc, null));
        };

        DocumentSet.prototype.delete = function (key) {
            var doc = this.get(key);

            if (!doc) {
                return this;
            }

            return this.copy(this.keyedMap.remove(key), this.sortedSet.remove(doc));
        };

        DocumentSet.prototype.isEqual = function (other) {
            if (!(other instanceof DocumentSet)) return false;
            if (this.size !== other.size) return false;
            var thisIt = this.sortedSet.getIterator();
            var otherIt = other.sortedSet.getIterator();

            while (thisIt.hasNext()) {
                var thisDoc = thisIt.getNext().key;
                var otherDoc = otherIt.getNext().key;
                if (!thisDoc.isEqual(otherDoc)) return false;
            }

            return true;
        };

        DocumentSet.prototype.toString = function () {
            var docStrings = [];
            this.forEach(function (doc) {
                docStrings.push(doc.toString());
            });

            if (docStrings.length === 0) {
                return 'DocumentSet ()';
            } else {
                return 'DocumentSet (\n  ' + docStrings.join('  \n') + '\n)';
            }
        };

        DocumentSet.prototype.copy = function (keyedMap, sortedSet) {
            var newSet = new DocumentSet();
            newSet.comparator = this.comparator;
            newSet.keyedMap = keyedMap;
            newSet.sortedSet = sortedSet;
            return newSet;
        };

        return DocumentSet;
    }();

    var ChangeType;

    (function (ChangeType) {
        ChangeType[ChangeType["Added"] = 0] = "Added";
        ChangeType[ChangeType["Removed"] = 1] = "Removed";
        ChangeType[ChangeType["Modified"] = 2] = "Modified";
        ChangeType[ChangeType["Metadata"] = 3] = "Metadata";
    })(ChangeType || (ChangeType = {}));

    var SyncState;

    (function (SyncState) {
        SyncState[SyncState["Local"] = 0] = "Local";
        SyncState[SyncState["Synced"] = 1] = "Synced";
    })(SyncState || (SyncState = {}));

    var DocumentChangeSet = function () {
        function DocumentChangeSet() {
            this.changeMap = new SortedMap(DocumentKey.comparator);
        }

        DocumentChangeSet.prototype.track = function (change) {
            var key = change.doc.key;
            var oldChange = this.changeMap.get(key);

            if (!oldChange) {
                this.changeMap = this.changeMap.insert(key, change);
                return;
            }

            if (change.type !== ChangeType.Added && oldChange.type === ChangeType.Metadata) {
                this.changeMap = this.changeMap.insert(key, change);
            } else if (change.type === ChangeType.Metadata && oldChange.type !== ChangeType.Removed) {
                this.changeMap = this.changeMap.insert(key, {
                    type: oldChange.type,
                    doc: change.doc
                });
            } else if (change.type === ChangeType.Modified && oldChange.type === ChangeType.Modified) {
                this.changeMap = this.changeMap.insert(key, {
                    type: ChangeType.Modified,
                    doc: change.doc
                });
            } else if (change.type === ChangeType.Modified && oldChange.type === ChangeType.Added) {
                this.changeMap = this.changeMap.insert(key, {
                    type: ChangeType.Added,
                    doc: change.doc
                });
            } else if (change.type === ChangeType.Removed && oldChange.type === ChangeType.Added) {
                this.changeMap = this.changeMap.remove(key);
            } else if (change.type === ChangeType.Removed && oldChange.type === ChangeType.Modified) {
                this.changeMap = this.changeMap.insert(key, {
                    type: ChangeType.Removed,
                    doc: oldChange.doc
                });
            } else if (change.type === ChangeType.Added && oldChange.type === ChangeType.Removed) {
                this.changeMap = this.changeMap.insert(key, {
                    type: ChangeType.Modified,
                    doc: change.doc
                });
            } else {
                fail('unsupported combination of changes: ' + JSON.stringify(change) + ' after ' + JSON.stringify(oldChange));
            }
        };

        DocumentChangeSet.prototype.getChanges = function () {
            var changes = [];
            this.changeMap.inorderTraversal(function (key, change) {
                changes.push(change);
            });
            return changes;
        };

        return DocumentChangeSet;
    }();

    var ViewSnapshot = function () {
        function ViewSnapshot(query, docs, oldDocs, docChanges, mutatedKeys, fromCache, syncStateChanged, excludesMetadataChanges) {
            this.query = query;
            this.docs = docs;
            this.oldDocs = oldDocs;
            this.docChanges = docChanges;
            this.mutatedKeys = mutatedKeys;
            this.fromCache = fromCache;
            this.syncStateChanged = syncStateChanged;
            this.excludesMetadataChanges = excludesMetadataChanges;
        }

        ViewSnapshot.fromInitialDocuments = function (query, documents, mutatedKeys, fromCache) {
            var changes = [];
            documents.forEach(function (doc) {
                changes.push({
                    type: ChangeType.Added,
                    doc: doc
                });
            });
            return new ViewSnapshot(query, documents, DocumentSet.emptySet(documents), changes, mutatedKeys, fromCache, true, false);
        };

        Object.defineProperty(ViewSnapshot.prototype, "hasPendingWrites", {
            get: function get() {
                return !this.mutatedKeys.isEmpty();
            },
            enumerable: true,
            configurable: true
        });

        ViewSnapshot.prototype.isEqual = function (other) {
            if (this.fromCache !== other.fromCache || this.syncStateChanged !== other.syncStateChanged || !this.mutatedKeys.isEqual(other.mutatedKeys) || !this.query.isEqual(other.query) || !this.docs.isEqual(other.docs) || !this.oldDocs.isEqual(other.oldDocs)) {
                return false;
            }

            var changes = this.docChanges;
            var otherChanges = other.docChanges;

            if (changes.length !== otherChanges.length) {
                return false;
            }

            for (var i = 0; i < changes.length; i++) {
                if (changes[i].type !== otherChanges[i].type || !changes[i].doc.isEqual(otherChanges[i].doc)) {
                    return false;
                }
            }

            return true;
        };

        return ViewSnapshot;
    }();

    var RemoteEvent = function () {
        function RemoteEvent(snapshotVersion, targetChanges, targetMismatches, documentUpdates, resolvedLimboDocuments) {
            this.snapshotVersion = snapshotVersion;
            this.targetChanges = targetChanges;
            this.targetMismatches = targetMismatches;
            this.documentUpdates = documentUpdates;
            this.resolvedLimboDocuments = resolvedLimboDocuments;
        }

        RemoteEvent.createSynthesizedRemoteEventForCurrentChange = function (targetId, current) {
            var targetChanges = (_a = {}, _a[targetId] = TargetChange.createSynthesizedTargetChangeForCurrentChange(targetId, current), _a);
            return new RemoteEvent(SnapshotVersion.MIN, targetChanges, targetIdSet(), maybeDocumentMap(), documentKeySet());

            var _a;
        };

        return RemoteEvent;
    }();

    var TargetChange = function () {
        function TargetChange(resumeToken, current, addedDocuments, modifiedDocuments, removedDocuments) {
            this.resumeToken = resumeToken;
            this.current = current;
            this.addedDocuments = addedDocuments;
            this.modifiedDocuments = modifiedDocuments;
            this.removedDocuments = removedDocuments;
        }

        TargetChange.createSynthesizedTargetChangeForCurrentChange = function (targetId, current) {
            return new TargetChange(emptyByteString(), current, documentKeySet(), documentKeySet(), documentKeySet());
        };

        return TargetChange;
    }();

    var DocumentWatchChange = function () {
        function DocumentWatchChange(updatedTargetIds, removedTargetIds, key, newDoc) {
            this.updatedTargetIds = updatedTargetIds;
            this.removedTargetIds = removedTargetIds;
            this.key = key;
            this.newDoc = newDoc;
        }

        return DocumentWatchChange;
    }();

    var ExistenceFilterChange = function () {
        function ExistenceFilterChange(targetId, existenceFilter) {
            this.targetId = targetId;
            this.existenceFilter = existenceFilter;
        }

        return ExistenceFilterChange;
    }();

    var WatchTargetChangeState;

    (function (WatchTargetChangeState) {
        WatchTargetChangeState[WatchTargetChangeState["NoChange"] = 0] = "NoChange";
        WatchTargetChangeState[WatchTargetChangeState["Added"] = 1] = "Added";
        WatchTargetChangeState[WatchTargetChangeState["Removed"] = 2] = "Removed";
        WatchTargetChangeState[WatchTargetChangeState["Current"] = 3] = "Current";
        WatchTargetChangeState[WatchTargetChangeState["Reset"] = 4] = "Reset";
    })(WatchTargetChangeState || (WatchTargetChangeState = {}));

    var WatchTargetChange = function () {
        function WatchTargetChange(state, targetIds, resumeToken, cause) {
            if (resumeToken === void 0) {
                resumeToken = emptyByteString();
            }

            if (cause === void 0) {
                cause = null;
            }

            this.state = state;
            this.targetIds = targetIds;
            this.resumeToken = resumeToken;
            this.cause = cause;
        }

        return WatchTargetChange;
    }();

    var TargetState = function () {
        function TargetState() {
            this.pendingResponses = 0;
            this.documentChanges = snapshotChangesMap();
            this._resumeToken = emptyByteString();
            this._current = false;
            this._hasPendingChanges = true;
        }

        Object.defineProperty(TargetState.prototype, "current", {
            get: function get() {
                return this._current;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TargetState.prototype, "resumeToken", {
            get: function get() {
                return this._resumeToken;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TargetState.prototype, "isPending", {
            get: function get() {
                return this.pendingResponses !== 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TargetState.prototype, "hasPendingChanges", {
            get: function get() {
                return this._hasPendingChanges;
            },
            enumerable: true,
            configurable: true
        });

        TargetState.prototype.updateResumeToken = function (resumeToken) {
            if (resumeToken.length > 0) {
                this._hasPendingChanges = true;
                this._resumeToken = resumeToken;
            }
        };

        TargetState.prototype.toTargetChange = function () {
            var addedDocuments = documentKeySet();
            var modifiedDocuments = documentKeySet();
            var removedDocuments = documentKeySet();
            this.documentChanges.forEach(function (key, changeType) {
                switch (changeType) {
                    case ChangeType.Added:
                        addedDocuments = addedDocuments.add(key);
                        break;

                    case ChangeType.Modified:
                        modifiedDocuments = modifiedDocuments.add(key);
                        break;

                    case ChangeType.Removed:
                        removedDocuments = removedDocuments.add(key);
                        break;

                    default:
                        fail('Encountered invalid change type: ' + changeType);
                }
            });
            return new TargetChange(this._resumeToken, this._current, addedDocuments, modifiedDocuments, removedDocuments);
        };

        TargetState.prototype.clearPendingChanges = function () {
            this._hasPendingChanges = false;
            this.documentChanges = snapshotChangesMap();
        };

        TargetState.prototype.addDocumentChange = function (key, changeType) {
            this._hasPendingChanges = true;
            this.documentChanges = this.documentChanges.insert(key, changeType);
        };

        TargetState.prototype.removeDocumentChange = function (key) {
            this._hasPendingChanges = true;
            this.documentChanges = this.documentChanges.remove(key);
        };

        TargetState.prototype.recordPendingTargetRequest = function () {
            this.pendingResponses += 1;
        };

        TargetState.prototype.recordTargetResponse = function () {
            this.pendingResponses -= 1;
        };

        TargetState.prototype.markCurrent = function () {
            this._hasPendingChanges = true;
            this._current = true;
        };

        return TargetState;
    }();

    var WatchChangeAggregator = function () {
        function WatchChangeAggregator(metadataProvider) {
            this.metadataProvider = metadataProvider;
            this.targetStates = {};
            this.pendingDocumentUpdates = maybeDocumentMap();
            this.pendingDocumentTargetMapping = documentTargetMap();
            this.pendingTargetResets = new SortedSet(primitiveComparator);
        }

        WatchChangeAggregator.prototype.handleDocumentChange = function (docChange) {
            for (var _i = 0, _a = docChange.updatedTargetIds; _i < _a.length; _i++) {
                var targetId = _a[_i];

                if (docChange.newDoc instanceof Document) {
                    this.addDocumentToTarget(targetId, docChange.newDoc);
                } else if (docChange.newDoc instanceof NoDocument) {
                    this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);
                }
            }

            for (var _b = 0, _c = docChange.removedTargetIds; _b < _c.length; _b++) {
                var targetId = _c[_b];
                this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);
            }
        };

        WatchChangeAggregator.prototype.handleTargetChange = function (targetChange) {
            var _this = this;

            this.forEachTarget(targetChange, function (targetId) {
                var targetState = _this.ensureTargetState(targetId);

                switch (targetChange.state) {
                    case WatchTargetChangeState.NoChange:
                        if (_this.isActiveTarget(targetId)) {
                            targetState.updateResumeToken(targetChange.resumeToken);
                        }

                        break;

                    case WatchTargetChangeState.Added:
                        targetState.recordTargetResponse();

                        if (!targetState.isPending) {
                            targetState.clearPendingChanges();
                        }

                        targetState.updateResumeToken(targetChange.resumeToken);
                        break;

                    case WatchTargetChangeState.Removed:
                        targetState.recordTargetResponse();

                        if (!targetState.isPending) {
                            _this.removeTarget(targetId);
                        }

                        assert(!targetChange.cause, 'WatchChangeAggregator does not handle errored targets');
                        break;

                    case WatchTargetChangeState.Current:
                        if (_this.isActiveTarget(targetId)) {
                            targetState.markCurrent();
                            targetState.updateResumeToken(targetChange.resumeToken);
                        }

                        break;

                    case WatchTargetChangeState.Reset:
                        if (_this.isActiveTarget(targetId)) {
                            _this.resetTarget(targetId);

                            targetState.updateResumeToken(targetChange.resumeToken);
                        }

                        break;

                    default:
                        fail('Unknown target watch change state: ' + targetChange.state);
                }
            });
        };

        WatchChangeAggregator.prototype.forEachTarget = function (targetChange, fn) {
            if (targetChange.targetIds.length > 0) {
                targetChange.targetIds.forEach(fn);
            } else {
                forEachNumber(this.targetStates, fn);
            }
        };

        WatchChangeAggregator.prototype.handleExistenceFilter = function (watchChange) {
            var targetId = watchChange.targetId;
            var expectedCount = watchChange.existenceFilter.count;
            var queryData = this.queryDataForActiveTarget(targetId);

            if (queryData) {
                var query = queryData.query;

                if (query.isDocumentQuery()) {
                    if (expectedCount === 0) {
                        var key = new DocumentKey(query.path);
                        this.removeDocumentFromTarget(targetId, key, new NoDocument(key, SnapshotVersion.forDeletedDoc()));
                    } else {
                        assert(expectedCount === 1, 'Single document existence filter with count: ' + expectedCount);
                    }
                } else {
                    var currentSize = this.getCurrentDocumentCountForTarget(targetId);

                    if (currentSize !== expectedCount) {
                        this.resetTarget(targetId);
                        this.pendingTargetResets = this.pendingTargetResets.add(targetId);
                    }
                }
            }
        };

        WatchChangeAggregator.prototype.createRemoteEvent = function (snapshotVersion) {
            var _this = this;

            var targetChanges = {};
            forEachNumber(this.targetStates, function (targetId, targetState) {
                var queryData = _this.queryDataForActiveTarget(targetId);

                if (queryData) {
                    if (targetState.current && queryData.query.isDocumentQuery()) {
                        var key = new DocumentKey(queryData.query.path);

                        if (_this.pendingDocumentUpdates.get(key) === null && !_this.targetContainsDocument(targetId, key)) {
                            _this.removeDocumentFromTarget(targetId, key, new NoDocument(key, snapshotVersion));
                        }
                    }

                    if (targetState.hasPendingChanges) {
                        targetChanges[targetId] = targetState.toTargetChange();
                        targetState.clearPendingChanges();
                    }
                }
            });
            var resolvedLimboDocuments = documentKeySet();
            this.pendingDocumentTargetMapping.forEach(function (key, targets) {
                var isOnlyLimboTarget = true;
                targets.forEachWhile(function (targetId) {
                    var queryData = _this.queryDataForActiveTarget(targetId);

                    if (queryData && queryData.purpose !== QueryPurpose.LimboResolution) {
                        isOnlyLimboTarget = false;
                        return false;
                    }

                    return true;
                });

                if (isOnlyLimboTarget) {
                    resolvedLimboDocuments = resolvedLimboDocuments.add(key);
                }
            });
            var remoteEvent = new RemoteEvent(snapshotVersion, targetChanges, this.pendingTargetResets, this.pendingDocumentUpdates, resolvedLimboDocuments);
            this.pendingDocumentUpdates = maybeDocumentMap();
            this.pendingDocumentTargetMapping = documentTargetMap();
            this.pendingTargetResets = new SortedSet(primitiveComparator);
            return remoteEvent;
        };

        WatchChangeAggregator.prototype.addDocumentToTarget = function (targetId, document) {
            if (!this.isActiveTarget(targetId)) {
                return;
            }

            var changeType = this.targetContainsDocument(targetId, document.key) ? ChangeType.Modified : ChangeType.Added;
            var targetState = this.ensureTargetState(targetId);
            targetState.addDocumentChange(document.key, changeType);
            this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(document.key, document);
            this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(document.key, this.ensureDocumentTargetMapping(document.key).add(targetId));
        };

        WatchChangeAggregator.prototype.removeDocumentFromTarget = function (targetId, key, updatedDocument) {
            if (!this.isActiveTarget(targetId)) {
                return;
            }

            var targetState = this.ensureTargetState(targetId);

            if (this.targetContainsDocument(targetId, key)) {
                targetState.addDocumentChange(key, ChangeType.Removed);
            } else {
                targetState.removeDocumentChange(key);
            }

            this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(key, this.ensureDocumentTargetMapping(key).delete(targetId));

            if (updatedDocument) {
                this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(key, updatedDocument);
            }
        };

        WatchChangeAggregator.prototype.removeTarget = function (targetId) {
            delete this.targetStates[targetId];
        };

        WatchChangeAggregator.prototype.getCurrentDocumentCountForTarget = function (targetId) {
            var targetState = this.ensureTargetState(targetId);
            var targetChange = targetState.toTargetChange();
            return this.metadataProvider.getRemoteKeysForTarget(targetId).size + targetChange.addedDocuments.size - targetChange.removedDocuments.size;
        };

        WatchChangeAggregator.prototype.recordPendingTargetRequest = function (targetId) {
            var targetState = this.ensureTargetState(targetId);
            targetState.recordPendingTargetRequest();
        };

        WatchChangeAggregator.prototype.ensureTargetState = function (targetId) {
            if (!this.targetStates[targetId]) {
                this.targetStates[targetId] = new TargetState();
            }

            return this.targetStates[targetId];
        };

        WatchChangeAggregator.prototype.ensureDocumentTargetMapping = function (key) {
            var targetMapping = this.pendingDocumentTargetMapping.get(key);

            if (!targetMapping) {
                targetMapping = new SortedSet(primitiveComparator);
                this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(key, targetMapping);
            }

            return targetMapping;
        };

        WatchChangeAggregator.prototype.isActiveTarget = function (targetId) {
            return this.queryDataForActiveTarget(targetId) !== null;
        };

        WatchChangeAggregator.prototype.queryDataForActiveTarget = function (targetId) {
            var targetState = this.targetStates[targetId];
            return targetState && targetState.isPending ? null : this.metadataProvider.getQueryDataForTarget(targetId);
        };

        WatchChangeAggregator.prototype.resetTarget = function (targetId) {
            var _this = this;

            assert(!this.targetStates[targetId].isPending, 'Should only reset active targets');
            this.targetStates[targetId] = new TargetState();
            var existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);
            existingKeys.forEach(function (key) {
                _this.removeDocumentFromTarget(targetId, key, null);
            });
        };

        WatchChangeAggregator.prototype.targetContainsDocument = function (targetId, key) {
            var existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);
            return existingKeys.has(key);
        };

        return WatchChangeAggregator;
    }();

    function documentTargetMap() {
        return new SortedMap(DocumentKey.comparator);
    }

    function snapshotChangesMap() {
        return new SortedMap(DocumentKey.comparator);
    }

    var DIRECTIONS = function () {
        var dirs = {};
        dirs[Direction.ASCENDING.name] = 'ASCENDING';
        dirs[Direction.DESCENDING.name] = 'DESCENDING';
        return dirs;
    }();

    var OPERATORS = function () {
        var ops = {};
        ops[RelationOp.LESS_THAN.name] = 'LESS_THAN';
        ops[RelationOp.LESS_THAN_OR_EQUAL.name] = 'LESS_THAN_OR_EQUAL';
        ops[RelationOp.GREATER_THAN.name] = 'GREATER_THAN';
        ops[RelationOp.GREATER_THAN_OR_EQUAL.name] = 'GREATER_THAN_OR_EQUAL';
        ops[RelationOp.EQUAL.name] = 'EQUAL';
        ops[RelationOp.ARRAY_CONTAINS.name] = 'ARRAY_CONTAINS';
        return ops;
    }();

    var ISO_REG_EXP = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);

    function assertPresent(value, description) {
        assert(!isNullOrUndefined(value), description + ' is missing');
    }

    function parseInt64(value) {
        if (typeof value === 'number') {
            return value;
        } else if (typeof value === 'string') {
            return Number(value);
        } else {
            return fail("can't parse " + value);
        }
    }

    var JsonProtoSerializer = function () {
        function JsonProtoSerializer(databaseId, options) {
            this.databaseId = databaseId;
            this.options = options;
        }

        JsonProtoSerializer.prototype.emptyByteString = function () {
            if (this.options.useProto3Json) {
                return '';
            } else {
                return new Uint8Array(0);
            }
        };

        JsonProtoSerializer.prototype.unsafeCastProtoByteString = function (byteString) {
            return byteString;
        };

        JsonProtoSerializer.prototype.fromRpcStatus = function (status) {
            var code = status.code === undefined ? Code.UNKNOWN : mapCodeFromRpcCode(status.code);
            return new FirestoreError(code, status.message || '');
        };

        JsonProtoSerializer.prototype.toInt32Value = function (val) {
            if (!isNullOrUndefined(val)) {
                return {
                    value: val
                };
            } else {
                return undefined;
            }
        };

        JsonProtoSerializer.prototype.fromInt32Value = function (val) {
            var result;

            if (typeof val === 'object') {
                result = val.value;
            } else {
                result = val;
            }

            return isNullOrUndefined(result) ? null : result;
        };

        JsonProtoSerializer.prototype.toTimestamp = function (timestamp) {
            return {
                seconds: timestamp.seconds,
                nanos: timestamp.nanoseconds
            };
        };

        JsonProtoSerializer.prototype.fromTimestamp = function (date) {
            if (typeof date === 'string') {
                return this.fromIso8601String(date);
            } else {
                assert(!!date, 'Cannot deserialize null or undefined timestamp.');
                var seconds = parseInt64(date.seconds || '0');
                var nanos = date.nanos || 0;
                return new Timestamp(seconds, nanos);
            }
        };

        JsonProtoSerializer.prototype.fromIso8601String = function (utc) {
            var nanos = 0;
            var fraction = ISO_REG_EXP.exec(utc);
            assert(!!fraction, 'invalid timestamp: ' + utc);

            if (fraction[1]) {
                var nanoStr = fraction[1];
                nanoStr = (nanoStr + '000000000').substr(0, 9);
                nanos = Number(nanoStr);
            }

            var date = new Date(utc);
            var seconds = Math.floor(date.getTime() / 1000);
            return new Timestamp(seconds, nanos);
        };

        JsonProtoSerializer.prototype.toBytes = function (bytes) {
            if (this.options.useProto3Json) {
                return bytes.toBase64();
            } else {
                return this.unsafeCastProtoByteString(bytes.toUint8Array());
            }
        };

        JsonProtoSerializer.prototype.fromBlob = function (blob) {
            if (typeof blob === 'string') {
                assert(this.options.useProto3Json, 'Expected bytes to be passed in as Uint8Array, but got a string instead.');
                return Blob.fromBase64String(blob);
            } else {
                assert(!this.options.useProto3Json, 'Expected bytes to be passed in as string, but got something else instead.');
                return Blob.fromUint8Array(blob);
            }
        };

        JsonProtoSerializer.prototype.toVersion = function (version) {
            return this.toTimestamp(version.toTimestamp());
        };

        JsonProtoSerializer.prototype.fromVersion = function (version) {
            assert(!!version, "Trying to deserialize version that isn't set");
            return SnapshotVersion.fromTimestamp(this.fromTimestamp(version));
        };

        JsonProtoSerializer.prototype.toResourceName = function (databaseId, path) {
            return this.fullyQualifiedPrefixPath(databaseId).child('documents').child(path).canonicalString();
        };

        JsonProtoSerializer.prototype.fromResourceName = function (name) {
            var resource = ResourcePath.fromString(name);
            assert(this.isValidResourceName(resource), 'Tried to deserialize invalid key ' + resource.toString());
            return resource;
        };

        JsonProtoSerializer.prototype.toName = function (key) {
            return this.toResourceName(this.databaseId, key.path);
        };

        JsonProtoSerializer.prototype.fromName = function (name) {
            var resource = this.fromResourceName(name);
            assert(resource.get(1) === this.databaseId.projectId, 'Tried to deserialize key from different project: ' + resource.get(1) + ' vs ' + this.databaseId.projectId);
            assert(!resource.get(3) && !this.databaseId.database || resource.get(3) === this.databaseId.database, 'Tried to deserialize key from different database: ' + resource.get(3) + ' vs ' + this.databaseId.database);
            return new DocumentKey(this.extractLocalPathFromResourceName(resource));
        };

        JsonProtoSerializer.prototype.toQueryPath = function (path) {
            if (path.length === 0) {
                return this.encodedDatabaseId;
            }

            return this.toResourceName(this.databaseId, path);
        };

        JsonProtoSerializer.prototype.fromQueryPath = function (name) {
            var resourceName = this.fromResourceName(name);

            if (resourceName.length === 4) {
                return ResourcePath.EMPTY_PATH;
            }

            return this.extractLocalPathFromResourceName(resourceName);
        };

        Object.defineProperty(JsonProtoSerializer.prototype, "encodedDatabaseId", {
            get: function get() {
                var path = new ResourcePath(['projects', this.databaseId.projectId, 'databases', this.databaseId.database]);
                return path.canonicalString();
            },
            enumerable: true,
            configurable: true
        });

        JsonProtoSerializer.prototype.fullyQualifiedPrefixPath = function (databaseId) {
            return new ResourcePath(['projects', databaseId.projectId, 'databases', databaseId.database]);
        };

        JsonProtoSerializer.prototype.extractLocalPathFromResourceName = function (resourceName) {
            assert(resourceName.length > 4 && resourceName.get(4) === 'documents', 'tried to deserialize invalid key ' + resourceName.toString());
            return resourceName.popFirst(5);
        };

        JsonProtoSerializer.prototype.isValidResourceName = function (path) {
            return path.length >= 4 && path.get(0) === 'projects' && path.get(2) === 'databases';
        };

        JsonProtoSerializer.prototype.toValue = function (val) {
            if (val instanceof NullValue) {
                return {
                    nullValue: 'NULL_VALUE'
                };
            } else if (val instanceof BooleanValue) {
                return {
                    booleanValue: val.value()
                };
            } else if (val instanceof IntegerValue) {
                return {
                    integerValue: '' + val.value()
                };
            } else if (val instanceof DoubleValue) {
                var doubleValue = val.value();

                if (this.options.useProto3Json) {
                    if (isNaN(doubleValue)) {
                        return {
                            doubleValue: 'NaN'
                        };
                    } else if (doubleValue === Infinity) {
                        return {
                            doubleValue: 'Infinity'
                        };
                    } else if (doubleValue === -Infinity) {
                        return {
                            doubleValue: '-Infinity'
                        };
                    }
                }

                return {
                    doubleValue: val.value()
                };
            } else if (val instanceof StringValue) {
                return {
                    stringValue: val.value()
                };
            } else if (val instanceof ObjectValue) {
                return {
                    mapValue: this.toMapValue(val)
                };
            } else if (val instanceof ArrayValue) {
                return {
                    arrayValue: this.toArrayValue(val)
                };
            } else if (val instanceof TimestampValue) {
                return {
                    timestampValue: this.toTimestamp(val.internalValue)
                };
            } else if (val instanceof GeoPointValue) {
                return {
                    geoPointValue: {
                        latitude: val.value().latitude,
                        longitude: val.value().longitude
                    }
                };
            } else if (val instanceof BlobValue) {
                return {
                    bytesValue: this.toBytes(val.value())
                };
            } else if (val instanceof RefValue) {
                return {
                    referenceValue: this.toResourceName(val.databaseId, val.key.path)
                };
            } else {
                return fail('Unknown FieldValue ' + JSON.stringify(val));
            }
        };

        JsonProtoSerializer.prototype.fromValue = function (obj) {
            var _this = this;

            var type = obj['value_type'];

            if (hasTag(obj, type, 'nullValue')) {
                return NullValue.INSTANCE;
            } else if (hasTag(obj, type, 'booleanValue')) {
                return BooleanValue.of(obj.booleanValue);
            } else if (hasTag(obj, type, 'integerValue')) {
                return new IntegerValue(parseInt64(obj.integerValue));
            } else if (hasTag(obj, type, 'doubleValue')) {
                if (this.options.useProto3Json) {
                    if (obj.doubleValue === 'NaN') {
                        return DoubleValue.NAN;
                    } else if (obj.doubleValue === 'Infinity') {
                        return DoubleValue.POSITIVE_INFINITY;
                    } else if (obj.doubleValue === '-Infinity') {
                        return DoubleValue.NEGATIVE_INFINITY;
                    }
                }

                return new DoubleValue(obj.doubleValue);
            } else if (hasTag(obj, type, 'stringValue')) {
                return new StringValue(obj.stringValue);
            } else if (hasTag(obj, type, 'mapValue')) {
                return this.fromFields(obj.mapValue.fields || {});
            } else if (hasTag(obj, type, 'arrayValue')) {
                assertPresent(obj.arrayValue, 'arrayValue');
                var values$$1 = obj.arrayValue.values || [];
                return new ArrayValue(values$$1.map(function (v) {
                    return _this.fromValue(v);
                }));
            } else if (hasTag(obj, type, 'timestampValue')) {
                assertPresent(obj.timestampValue, 'timestampValue');
                return new TimestampValue(this.fromTimestamp(obj.timestampValue));
            } else if (hasTag(obj, type, 'geoPointValue')) {
                assertPresent(obj.geoPointValue, 'geoPointValue');
                var latitude = obj.geoPointValue.latitude || 0;
                var longitude = obj.geoPointValue.longitude || 0;
                return new GeoPointValue(new GeoPoint(latitude, longitude));
            } else if (hasTag(obj, type, 'bytesValue')) {
                assertPresent(obj.bytesValue, 'bytesValue');
                var blob = this.fromBlob(obj.bytesValue);
                return new BlobValue(blob);
            } else if (hasTag(obj, type, 'referenceValue')) {
                assertPresent(obj.referenceValue, 'referenceValue');
                var resourceName = this.fromResourceName(obj.referenceValue);
                var dbId = new DatabaseId(resourceName.get(1), resourceName.get(3));
                var key = new DocumentKey(this.extractLocalPathFromResourceName(resourceName));
                return new RefValue(dbId, key);
            } else {
                return fail('Unknown Value proto ' + JSON.stringify(obj));
            }
        };

        JsonProtoSerializer.prototype.toMutationDocument = function (key, fields) {
            return {
                name: this.toName(key),
                fields: this.toFields(fields)
            };
        };

        JsonProtoSerializer.prototype.toDocument = function (document) {
            assert(!document.hasLocalMutations, "Can't serialize documents with mutations.");
            return {
                name: this.toName(document.key),
                fields: this.toFields(document.data),
                updateTime: this.toTimestamp(document.version.toTimestamp())
            };
        };

        JsonProtoSerializer.prototype.fromDocument = function (document, hasCommittedMutations) {
            return new Document(this.fromName(document.name), this.fromVersion(document.updateTime), this.fromFields(document.fields || {}), {
                hasCommittedMutations: !!hasCommittedMutations
            });
        };

        JsonProtoSerializer.prototype.toFields = function (fields) {
            var _this = this;

            var result = {};
            fields.forEach(function (key, value) {
                result[key] = _this.toValue(value);
            });
            return result;
        };

        JsonProtoSerializer.prototype.fromFields = function (object) {
            var _this = this;

            var map = object;
            var result = ObjectValue.EMPTY;
            forEach(map, function (key, value) {
                result = result.set(new FieldPath([key]), _this.fromValue(value));
            });
            return result;
        };

        JsonProtoSerializer.prototype.toMapValue = function (map) {
            return {
                fields: this.toFields(map)
            };
        };

        JsonProtoSerializer.prototype.toArrayValue = function (array) {
            var _this = this;

            var result = [];
            array.forEach(function (value) {
                result.push(_this.toValue(value));
            });
            return {
                values: result
            };
        };

        JsonProtoSerializer.prototype.fromFound = function (doc) {
            assert(!!doc.found, 'Tried to deserialize a found document from a missing document.');
            assertPresent(doc.found.name, 'doc.found.name');
            assertPresent(doc.found.updateTime, 'doc.found.updateTime');
            var key = this.fromName(doc.found.name);
            var version = this.fromVersion(doc.found.updateTime);
            var fields = this.fromFields(doc.found.fields || {});
            return new Document(key, version, fields, {});
        };

        JsonProtoSerializer.prototype.fromMissing = function (result) {
            assert(!!result.missing, 'Tried to deserialize a missing document from a found document.');
            assert(!!result.readTime, 'Tried to deserialize a missing document without a read time.');
            var key = this.fromName(result.missing);
            var version = this.fromVersion(result.readTime);
            return new NoDocument(key, version);
        };

        JsonProtoSerializer.prototype.fromMaybeDocument = function (result) {
            var type = result['result'];

            if (hasTag(result, type, 'found')) {
                return this.fromFound(result);
            } else if (hasTag(result, type, 'missing')) {
                return this.fromMissing(result);
            }

            return fail('invalid batch get response: ' + JSON.stringify(result));
        };

        JsonProtoSerializer.prototype.toWatchTargetChangeState = function (state) {
            switch (state) {
                case WatchTargetChangeState.Added:
                    return 'ADD';

                case WatchTargetChangeState.Current:
                    return 'CURRENT';

                case WatchTargetChangeState.NoChange:
                    return 'NO_CHANGE';

                case WatchTargetChangeState.Removed:
                    return 'REMOVE';

                case WatchTargetChangeState.Reset:
                    return 'RESET';

                default:
                    return fail('Unknown WatchTargetChangeState: ' + state);
            }
        };

        JsonProtoSerializer.prototype.toTestWatchChange = function (watchChange) {
            if (watchChange instanceof ExistenceFilterChange) {
                return {
                    filter: {
                        count: watchChange.existenceFilter.count,
                        targetId: watchChange.targetId
                    }
                };
            }

            if (watchChange instanceof DocumentWatchChange) {
                if (watchChange.newDoc instanceof Document) {
                    var doc = watchChange.newDoc;
                    return {
                        documentChange: {
                            document: {
                                name: this.toName(doc.key),
                                fields: this.toFields(doc.data),
                                updateTime: this.toVersion(doc.version)
                            },
                            targetIds: watchChange.updatedTargetIds,
                            removedTargetIds: watchChange.removedTargetIds
                        }
                    };
                } else if (watchChange.newDoc instanceof NoDocument) {
                    var doc = watchChange.newDoc;
                    return {
                        documentDelete: {
                            document: this.toName(doc.key),
                            readTime: this.toVersion(doc.version),
                            removedTargetIds: watchChange.removedTargetIds
                        }
                    };
                } else if (watchChange.newDoc === null) {
                    return {
                        documentRemove: {
                            document: this.toName(watchChange.key),
                            removedTargetIds: watchChange.removedTargetIds
                        }
                    };
                }
            }

            if (watchChange instanceof WatchTargetChange) {
                var cause = undefined;

                if (watchChange.cause) {
                    cause = {
                        code: mapRpcCodeFromCode(watchChange.cause.code),
                        message: watchChange.cause.message
                    };
                }

                return {
                    targetChange: {
                        targetChangeType: this.toWatchTargetChangeState(watchChange.state),
                        targetIds: watchChange.targetIds,
                        resumeToken: this.unsafeCastProtoByteString(watchChange.resumeToken),
                        cause: cause
                    }
                };
            }

            return fail('Unrecognized watch change: ' + JSON.stringify(watchChange));
        };

        JsonProtoSerializer.prototype.fromWatchChange = function (change) {
            var type = change['response_type'];
            var watchChange;

            if (hasTag(change, type, 'targetChange')) {
                assertPresent(change.targetChange, 'targetChange');
                var state = this.fromWatchTargetChangeState(change.targetChange.targetChangeType || 'NO_CHANGE');
                var targetIds = change.targetChange.targetIds || [];
                var resumeToken = change.targetChange.resumeToken || this.emptyByteString();
                var causeProto = change.targetChange.cause;
                var cause = causeProto && this.fromRpcStatus(causeProto);
                watchChange = new WatchTargetChange(state, targetIds, resumeToken, cause || null);
            } else if (hasTag(change, type, 'documentChange')) {
                assertPresent(change.documentChange, 'documentChange');
                assertPresent(change.documentChange.document, 'documentChange.name');
                assertPresent(change.documentChange.document.name, 'documentChange.document.name');
                assertPresent(change.documentChange.document.updateTime, 'documentChange.document.updateTime');
                var entityChange = change.documentChange;
                var key = this.fromName(entityChange.document.name);
                var version = this.fromVersion(entityChange.document.updateTime);
                var fields = this.fromFields(entityChange.document.fields || {});
                var doc = new Document(key, version, fields, {});
                var updatedTargetIds = entityChange.targetIds || [];
                var removedTargetIds = entityChange.removedTargetIds || [];
                watchChange = new DocumentWatchChange(updatedTargetIds, removedTargetIds, doc.key, doc);
            } else if (hasTag(change, type, 'documentDelete')) {
                assertPresent(change.documentDelete, 'documentDelete');
                assertPresent(change.documentDelete.document, 'documentDelete.document');
                var docDelete = change.documentDelete;
                var key = this.fromName(docDelete.document);
                var version = docDelete.readTime ? this.fromVersion(docDelete.readTime) : SnapshotVersion.forDeletedDoc();
                var doc = new NoDocument(key, version);
                var removedTargetIds = docDelete.removedTargetIds || [];
                watchChange = new DocumentWatchChange([], removedTargetIds, doc.key, doc);
            } else if (hasTag(change, type, 'documentRemove')) {
                assertPresent(change.documentRemove, 'documentRemove');
                assertPresent(change.documentRemove.document, 'documentRemove');
                var docRemove = change.documentRemove;
                var key = this.fromName(docRemove.document);
                var removedTargetIds = docRemove.removedTargetIds || [];
                watchChange = new DocumentWatchChange([], removedTargetIds, key, null);
            } else if (hasTag(change, type, 'filter')) {
                assertPresent(change.filter, 'filter');
                assertPresent(change.filter.targetId, 'filter.targetId');
                var filter = change.filter;
                var count = filter.count || 0;
                var existenceFilter = new ExistenceFilter(count);
                var targetId = filter.targetId;
                watchChange = new ExistenceFilterChange(targetId, existenceFilter);
            } else {
                return fail('Unknown change type ' + JSON.stringify(change));
            }

            return watchChange;
        };

        JsonProtoSerializer.prototype.fromWatchTargetChangeState = function (state) {
            if (state === 'NO_CHANGE') {
                return WatchTargetChangeState.NoChange;
            } else if (state === 'ADD') {
                return WatchTargetChangeState.Added;
            } else if (state === 'REMOVE') {
                return WatchTargetChangeState.Removed;
            } else if (state === 'CURRENT') {
                return WatchTargetChangeState.Current;
            } else if (state === 'RESET') {
                return WatchTargetChangeState.Reset;
            } else {
                return fail('Got unexpected TargetChange.state: ' + state);
            }
        };

        JsonProtoSerializer.prototype.versionFromListenResponse = function (change) {
            var type = change['response_type'];

            if (!hasTag(change, type, 'targetChange')) {
                return SnapshotVersion.MIN;
            }

            var targetChange = change.targetChange;

            if (targetChange.targetIds && targetChange.targetIds.length) {
                return SnapshotVersion.MIN;
            }

            if (!targetChange.readTime) {
                return SnapshotVersion.MIN;
            }

            return this.fromVersion(targetChange.readTime);
        };

        JsonProtoSerializer.prototype.toMutation = function (mutation) {
            var _this = this;

            var result;

            if (mutation instanceof SetMutation) {
                result = {
                    update: this.toMutationDocument(mutation.key, mutation.value)
                };
            } else if (mutation instanceof DeleteMutation) {
                result = {
                    delete: this.toName(mutation.key)
                };
            } else if (mutation instanceof PatchMutation) {
                result = {
                    update: this.toMutationDocument(mutation.key, mutation.data),
                    updateMask: this.toDocumentMask(mutation.fieldMask)
                };
            } else if (mutation instanceof TransformMutation) {
                result = {
                    transform: {
                        document: this.toName(mutation.key),
                        fieldTransforms: mutation.fieldTransforms.map(function (transform) {
                            return _this.toFieldTransform(transform);
                        })
                    }
                };
            } else {
                return fail('Unknown mutation type ' + mutation.type);
            }

            if (!mutation.precondition.isNone) {
                result.currentDocument = this.toPrecondition(mutation.precondition);
            }

            return result;
        };

        JsonProtoSerializer.prototype.fromMutation = function (proto) {
            var _this = this;

            var precondition = proto.currentDocument ? this.fromPrecondition(proto.currentDocument) : Precondition.NONE;

            if (proto.update) {
                assertPresent(proto.update.name, 'name');
                var key = this.fromName(proto.update.name);
                var value = this.fromFields(proto.update.fields || {});

                if (proto.updateMask) {
                    var fieldMask = this.fromDocumentMask(proto.updateMask);
                    return new PatchMutation(key, value, fieldMask, precondition);
                } else {
                    return new SetMutation(key, value, precondition);
                }
            } else if (proto.delete) {
                var key = this.fromName(proto.delete);
                return new DeleteMutation(key, precondition);
            } else if (proto.transform) {
                var key = this.fromName(proto.transform.document);
                var fieldTransforms = proto.transform.fieldTransforms.map(function (transform) {
                    return _this.fromFieldTransform(transform);
                });
                assert(precondition.exists === true, 'Transforms only support precondition "exists == true"');
                return new TransformMutation(key, fieldTransforms);
            } else {
                return fail('unknown mutation proto: ' + JSON.stringify(proto));
            }
        };

        JsonProtoSerializer.prototype.toPrecondition = function (precondition) {
            assert(!precondition.isNone, "Can't serialize an empty precondition");

            if (precondition.updateTime !== undefined) {
                return {
                    updateTime: this.toVersion(precondition.updateTime)
                };
            } else if (precondition.exists !== undefined) {
                return {
                    exists: precondition.exists
                };
            } else {
                return fail('Unknown precondition');
            }
        };

        JsonProtoSerializer.prototype.fromPrecondition = function (precondition) {
            if (precondition.updateTime !== undefined) {
                return Precondition.updateTime(this.fromVersion(precondition.updateTime));
            } else if (precondition.exists !== undefined) {
                return Precondition.exists(precondition.exists);
            } else {
                return Precondition.NONE;
            }
        };

        JsonProtoSerializer.prototype.fromWriteResult = function (proto, commitTime) {
            var _this = this;

            var version = proto.updateTime ? this.fromVersion(proto.updateTime) : this.fromVersion(commitTime);
            var transformResults = null;

            if (proto.transformResults && proto.transformResults.length > 0) {
                transformResults = proto.transformResults.map(function (result) {
                    return _this.fromValue(result);
                });
            }

            return new MutationResult(version, transformResults);
        };

        JsonProtoSerializer.prototype.fromWriteResults = function (protos, commitTime) {
            var _this = this;

            if (protos && protos.length > 0) {
                assert(commitTime !== undefined, 'Received a write result without a commit time');
                return protos.map(function (proto) {
                    return _this.fromWriteResult(proto, commitTime);
                });
            } else {
                return [];
            }
        };

        JsonProtoSerializer.prototype.toFieldTransform = function (fieldTransform) {
            var _this = this;

            var transform = fieldTransform.transform;

            if (transform instanceof ServerTimestampTransform) {
                return {
                    fieldPath: fieldTransform.field.canonicalString(),
                    setToServerValue: 'REQUEST_TIME'
                };
            } else if (transform instanceof ArrayUnionTransformOperation) {
                return {
                    fieldPath: fieldTransform.field.canonicalString(),
                    appendMissingElements: {
                        values: transform.elements.map(function (v) {
                            return _this.toValue(v);
                        })
                    }
                };
            } else if (transform instanceof ArrayRemoveTransformOperation) {
                return {
                    fieldPath: fieldTransform.field.canonicalString(),
                    removeAllFromArray: {
                        values: transform.elements.map(function (v) {
                            return _this.toValue(v);
                        })
                    }
                };
            } else {
                throw fail('Unknown transform: ' + fieldTransform.transform);
            }
        };

        JsonProtoSerializer.prototype.fromFieldTransform = function (proto) {
            var _this = this;

            var type = proto['transform_type'];
            var transform = null;

            if (hasTag(proto, type, 'setToServerValue')) {
                assert(proto.setToServerValue === 'REQUEST_TIME', 'Unknown server value transform proto: ' + JSON.stringify(proto));
                transform = ServerTimestampTransform.instance;
            } else if (hasTag(proto, type, 'appendMissingElements')) {
                var values$$1 = proto.appendMissingElements.values || [];
                transform = new ArrayUnionTransformOperation(values$$1.map(function (v) {
                    return _this.fromValue(v);
                }));
            } else if (hasTag(proto, type, 'removeAllFromArray')) {
                var values$$1 = proto.removeAllFromArray.values || [];
                transform = new ArrayRemoveTransformOperation(values$$1.map(function (v) {
                    return _this.fromValue(v);
                }));
            } else {
                fail('Unknown transform proto: ' + JSON.stringify(proto));
            }

            var fieldPath = FieldPath.fromServerFormat(proto.fieldPath);
            return new FieldTransform(fieldPath, transform);
        };

        JsonProtoSerializer.prototype.toDocumentsTarget = function (query) {
            return {
                documents: [this.toQueryPath(query.path)]
            };
        };

        JsonProtoSerializer.prototype.fromDocumentsTarget = function (documentsTarget) {
            var count = documentsTarget.documents.length;
            assert(count === 1, 'DocumentsTarget contained other than 1 document: ' + count);
            var name = documentsTarget.documents[0];
            return Query.atPath(this.fromQueryPath(name));
        };

        JsonProtoSerializer.prototype.toQueryTarget = function (query) {
            var result = {
                structuredQuery: {}
            };

            if (query.path.isEmpty()) {
                result.parent = this.toQueryPath(ResourcePath.EMPTY_PATH);
            } else {
                var path = query.path;
                assert(path.length % 2 !== 0, 'Document queries with filters are not supported.');
                result.parent = this.toQueryPath(path.popLast());
                result.structuredQuery.from = [{
                    collectionId: path.lastSegment()
                }];
            }

            var where = this.toFilter(query.filters);

            if (where) {
                result.structuredQuery.where = where;
            }

            var orderBy = this.toOrder(query.orderBy);

            if (orderBy) {
                result.structuredQuery.orderBy = orderBy;
            }

            var limit = this.toInt32Value(query.limit);

            if (limit !== undefined) {
                result.structuredQuery.limit = limit;
            }

            if (query.startAt) {
                result.structuredQuery.startAt = this.toCursor(query.startAt);
            }

            if (query.endAt) {
                result.structuredQuery.endAt = this.toCursor(query.endAt);
            }

            return result;
        };

        JsonProtoSerializer.prototype.fromQueryTarget = function (target) {
            var path = this.fromQueryPath(target.parent);
            var query = target.structuredQuery;
            var fromCount = query.from ? query.from.length : 0;

            if (fromCount > 0) {
                assert(fromCount === 1, 'StructuredQuery.from with more than one collection is not supported.');
                var from = query.from[0];
                path = path.child(from.collectionId);
            }

            var filterBy = [];

            if (query.where) {
                filterBy = this.fromFilter(query.where);
            }

            var orderBy = [];

            if (query.orderBy) {
                orderBy = this.fromOrder(query.orderBy);
            }

            var limit = null;

            if (query.limit) {
                limit = this.fromInt32Value(query.limit);
            }

            var startAt = null;

            if (query.startAt) {
                startAt = this.fromCursor(query.startAt);
            }

            var endAt = null;

            if (query.endAt) {
                endAt = this.fromCursor(query.endAt);
            }

            return new Query(path, orderBy, filterBy, limit, startAt, endAt);
        };

        JsonProtoSerializer.prototype.toListenRequestLabels = function (queryData) {
            var value = this.toLabel(queryData.purpose);

            if (value == null) {
                return null;
            } else {
                return {
                    'goog-listen-tags': value
                };
            }
        };

        JsonProtoSerializer.prototype.toLabel = function (purpose) {
            switch (purpose) {
                case QueryPurpose.Listen:
                    return null;

                case QueryPurpose.ExistenceFilterMismatch:
                    return 'existence-filter-mismatch';

                case QueryPurpose.LimboResolution:
                    return 'limbo-document';

                default:
                    return fail('Unrecognized query purpose: ' + purpose);
            }
        };

        JsonProtoSerializer.prototype.toTarget = function (queryData) {
            var result;
            var query = queryData.query;

            if (query.isDocumentQuery()) {
                result = {
                    documents: this.toDocumentsTarget(query)
                };
            } else {
                result = {
                    query: this.toQueryTarget(query)
                };
            }

            result.targetId = queryData.targetId;

            if (queryData.resumeToken.length > 0) {
                result.resumeToken = this.unsafeCastProtoByteString(queryData.resumeToken);
            }

            return result;
        };

        JsonProtoSerializer.prototype.toFilter = function (filters) {
            var _this = this;

            if (filters.length === 0) return;
            var protos = filters.map(function (filter) {
                return filter instanceof RelationFilter ? _this.toRelationFilter(filter) : _this.toUnaryFilter(filter);
            });

            if (protos.length === 1) {
                return protos[0];
            }

            return {
                compositeFilter: {
                    op: 'AND',
                    filters: protos
                }
            };
        };

        JsonProtoSerializer.prototype.fromFilter = function (filter) {
            var _this = this;

            if (!filter) {
                return [];
            } else if (filter.unaryFilter !== undefined) {
                return [this.fromUnaryFilter(filter)];
            } else if (filter.fieldFilter !== undefined) {
                return [this.fromRelationFilter(filter)];
            } else if (filter.compositeFilter !== undefined) {
                return filter.compositeFilter.filters.map(function (f) {
                    return _this.fromFilter(f);
                }).reduce(function (accum, current) {
                    return accum.concat(current);
                });
            } else {
                return fail('Unknown filter: ' + JSON.stringify(filter));
            }
        };

        JsonProtoSerializer.prototype.toOrder = function (orderBys) {
            var _this = this;

            if (orderBys.length === 0) return;
            return orderBys.map(function (order) {
                return _this.toPropertyOrder(order);
            });
        };

        JsonProtoSerializer.prototype.fromOrder = function (orderBys) {
            var _this = this;

            return orderBys.map(function (order) {
                return _this.fromPropertyOrder(order);
            });
        };

        JsonProtoSerializer.prototype.toCursor = function (cursor) {
            var _this = this;

            return {
                before: cursor.before,
                values: cursor.position.map(function (component) {
                    return _this.toValue(component);
                })
            };
        };

        JsonProtoSerializer.prototype.fromCursor = function (cursor) {
            var _this = this;

            var before = !!cursor.before;
            var position = cursor.values.map(function (component) {
                return _this.fromValue(component);
            });
            return new Bound(position, before);
        };

        JsonProtoSerializer.prototype.toDirection = function (dir) {
            return DIRECTIONS[dir.name];
        };

        JsonProtoSerializer.prototype.fromDirection = function (dir) {
            switch (dir) {
                case 'ASCENDING':
                    return Direction.ASCENDING;

                case 'DESCENDING':
                    return Direction.DESCENDING;

                default:
                    return undefined;
            }
        };

        JsonProtoSerializer.prototype.toOperatorName = function (op) {
            return OPERATORS[op.name];
        };

        JsonProtoSerializer.prototype.fromOperatorName = function (op) {
            switch (op) {
                case 'EQUAL':
                    return RelationOp.EQUAL;

                case 'GREATER_THAN':
                    return RelationOp.GREATER_THAN;

                case 'GREATER_THAN_OR_EQUAL':
                    return RelationOp.GREATER_THAN_OR_EQUAL;

                case 'LESS_THAN':
                    return RelationOp.LESS_THAN;

                case 'LESS_THAN_OR_EQUAL':
                    return RelationOp.LESS_THAN_OR_EQUAL;

                case 'ARRAY_CONTAINS':
                    return RelationOp.ARRAY_CONTAINS;

                case 'OPERATOR_UNSPECIFIED':
                    return fail('Unspecified relation');

                default:
                    return fail('Unknown relation');
            }
        };

        JsonProtoSerializer.prototype.toFieldPathReference = function (path) {
            return {
                fieldPath: path.canonicalString()
            };
        };

        JsonProtoSerializer.prototype.fromFieldPathReference = function (fieldReference) {
            return FieldPath.fromServerFormat(fieldReference.fieldPath);
        };

        JsonProtoSerializer.prototype.toPropertyOrder = function (orderBy) {
            return {
                field: this.toFieldPathReference(orderBy.field),
                direction: this.toDirection(orderBy.dir)
            };
        };

        JsonProtoSerializer.prototype.fromPropertyOrder = function (orderBy) {
            return new OrderBy(this.fromFieldPathReference(orderBy.field), this.fromDirection(orderBy.direction));
        };

        JsonProtoSerializer.prototype.toRelationFilter = function (filter) {
            if (filter instanceof RelationFilter) {
                return {
                    fieldFilter: {
                        field: this.toFieldPathReference(filter.field),
                        op: this.toOperatorName(filter.op),
                        value: this.toValue(filter.value)
                    }
                };
            } else {
                return fail('Unrecognized filter: ' + JSON.stringify(filter));
            }
        };

        JsonProtoSerializer.prototype.fromRelationFilter = function (filter) {
            return new RelationFilter(this.fromFieldPathReference(filter.fieldFilter.field), this.fromOperatorName(filter.fieldFilter.op), this.fromValue(filter.fieldFilter.value));
        };

        JsonProtoSerializer.prototype.toUnaryFilter = function (filter) {
            if (filter instanceof NanFilter) {
                return {
                    unaryFilter: {
                        field: this.toFieldPathReference(filter.field),
                        op: 'IS_NAN'
                    }
                };
            } else if (filter instanceof NullFilter) {
                return {
                    unaryFilter: {
                        field: this.toFieldPathReference(filter.field),
                        op: 'IS_NULL'
                    }
                };
            } else {
                return fail('Unrecognized filter: ' + JSON.stringify(filter));
            }
        };

        JsonProtoSerializer.prototype.fromUnaryFilter = function (filter) {
            switch (filter.unaryFilter.op) {
                case 'IS_NAN':
                    var nanField = this.fromFieldPathReference(filter.unaryFilter.field);
                    return new NanFilter(nanField);

                case 'IS_NULL':
                    var nullField = this.fromFieldPathReference(filter.unaryFilter.field);
                    return new NullFilter(nullField);

                case 'OPERATOR_UNSPECIFIED':
                    return fail('Unspecified filter');

                default:
                    return fail('Unknown filter');
            }
        };

        JsonProtoSerializer.prototype.toDocumentMask = function (fieldMask) {
            return {
                fieldPaths: fieldMask.fields.map(function (field) {
                    return field.canonicalString();
                })
            };
        };

        JsonProtoSerializer.prototype.fromDocumentMask = function (proto) {
            var paths = proto.fieldPaths || [];
            var fields = paths.map(function (path) {
                return FieldPath.fromServerFormat(path);
            });
            return new FieldMask(fields);
        };

        return JsonProtoSerializer;
    }();

    function hasTag(obj, type, tag) {
        return type === tag || !type && tag in obj;
    }

    var isReactNative = function isReactNative() {
        return typeof navigator === 'object' && navigator['product'] === 'ReactNative';
    };

    var ERROR_NAME = 'FirebaseError';
    var captureStackTrace = Error.captureStackTrace;

    var FirebaseError = function () {
        function FirebaseError(code, message) {
            this.code = code;
            this.message = message;

            if (captureStackTrace) {
                captureStackTrace(this, ErrorFactory.prototype.create);
            } else {
                try {
                    throw Error.apply(this, arguments);
                } catch (err) {
                    this.name = ERROR_NAME;
                    Object.defineProperty(this, 'stack', {
                        get: function get() {
                            return err.stack;
                        }
                    });
                }
            }
        }

        return FirebaseError;
    }();

    FirebaseError.prototype = Object.create(Error.prototype);
    FirebaseError.prototype.constructor = FirebaseError;
    FirebaseError.prototype.name = ERROR_NAME;

    var ErrorFactory = function () {
        function ErrorFactory(service, serviceName, errors) {
            this.service = service;
            this.serviceName = serviceName;
            this.errors = errors;
            this.pattern = /\{\$([^}]+)}/g;
        }

        ErrorFactory.prototype.create = function (code, data) {
            if (data === undefined) {
                data = {};
            }

            var template = this.errors[code];
            var fullCode = this.service + '/' + code;
            var message;

            if (template === undefined) {
                message = 'Error';
            } else {
                message = template.replace(this.pattern, function (match, key) {
                    var value = data[key];
                    return value !== undefined ? value.toString() : '<' + key + '?>';
                });
            }

            message = this.serviceName + ': ' + message + ' (' + fullCode + ').';
            var err = new FirebaseError(fullCode, message);

            for (var prop in data) {
                if (!data.hasOwnProperty(prop) || prop.slice(-1) === '_') {
                    continue;
                }

                err[prop] = data[prop];
            }

            return err;
        };

        return ErrorFactory;
    }();

    var Hash = function () {
        function Hash() {
            this.blockSize = -1;
        }

        return Hash;
    }();

    var Sha1 = function (_super) {
        tslib_1.__extends(Sha1, _super);

        function Sha1() {
            var _this = _super.call(this) || this;

            _this.chain_ = [];
            _this.buf_ = [];
            _this.W_ = [];
            _this.pad_ = [];
            _this.inbuf_ = 0;
            _this.total_ = 0;
            _this.blockSize = 512 / 8;
            _this.pad_[0] = 128;

            for (var i = 1; i < _this.blockSize; ++i) {
                _this.pad_[i] = 0;
            }

            _this.reset();

            return _this;
        }

        Sha1.prototype.reset = function () {
            this.chain_[0] = 0x67452301;
            this.chain_[1] = 0xefcdab89;
            this.chain_[2] = 0x98badcfe;
            this.chain_[3] = 0x10325476;
            this.chain_[4] = 0xc3d2e1f0;
            this.inbuf_ = 0;
            this.total_ = 0;
        };

        Sha1.prototype.compress_ = function (buf, opt_offset) {
            if (!opt_offset) {
                opt_offset = 0;
            }

            var W = this.W_;

            if (typeof buf === 'string') {
                for (var i = 0; i < 16; i++) {
                    W[i] = buf.charCodeAt(opt_offset) << 24 | buf.charCodeAt(opt_offset + 1) << 16 | buf.charCodeAt(opt_offset + 2) << 8 | buf.charCodeAt(opt_offset + 3);
                    opt_offset += 4;
                }
            } else {
                for (var i = 0; i < 16; i++) {
                    W[i] = buf[opt_offset] << 24 | buf[opt_offset + 1] << 16 | buf[opt_offset + 2] << 8 | buf[opt_offset + 3];
                    opt_offset += 4;
                }
            }

            for (var i = 16; i < 80; i++) {
                var t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                W[i] = (t << 1 | t >>> 31) & 0xffffffff;
            }

            var a = this.chain_[0];
            var b = this.chain_[1];
            var c = this.chain_[2];
            var d = this.chain_[3];
            var e = this.chain_[4];
            var f, k;

            for (var i = 0; i < 80; i++) {
                if (i < 40) {
                    if (i < 20) {
                        f = d ^ b & (c ^ d);
                        k = 0x5a827999;
                    } else {
                        f = b ^ c ^ d;
                        k = 0x6ed9eba1;
                    }
                } else {
                    if (i < 60) {
                        f = b & c | d & (b | c);
                        k = 0x8f1bbcdc;
                    } else {
                        f = b ^ c ^ d;
                        k = 0xca62c1d6;
                    }
                }

                var t = (a << 5 | a >>> 27) + f + e + k + W[i] & 0xffffffff;
                e = d;
                d = c;
                c = (b << 30 | b >>> 2) & 0xffffffff;
                b = a;
                a = t;
            }

            this.chain_[0] = this.chain_[0] + a & 0xffffffff;
            this.chain_[1] = this.chain_[1] + b & 0xffffffff;
            this.chain_[2] = this.chain_[2] + c & 0xffffffff;
            this.chain_[3] = this.chain_[3] + d & 0xffffffff;
            this.chain_[4] = this.chain_[4] + e & 0xffffffff;
        };

        Sha1.prototype.update = function (bytes, opt_length) {
            if (bytes == null) {
                return;
            }

            if (opt_length === undefined) {
                opt_length = bytes.length;
            }

            var lengthMinusBlock = opt_length - this.blockSize;
            var n = 0;
            var buf = this.buf_;
            var inbuf = this.inbuf_;

            while (n < opt_length) {
                if (inbuf == 0) {
                    while (n <= lengthMinusBlock) {
                        this.compress_(bytes, n);
                        n += this.blockSize;
                    }
                }

                if (typeof bytes === 'string') {
                    while (n < opt_length) {
                        buf[inbuf] = bytes.charCodeAt(n);
                        ++inbuf;
                        ++n;

                        if (inbuf == this.blockSize) {
                            this.compress_(buf);
                            inbuf = 0;
                            break;
                        }
                    }
                } else {
                    while (n < opt_length) {
                        buf[inbuf] = bytes[n];
                        ++inbuf;
                        ++n;

                        if (inbuf == this.blockSize) {
                            this.compress_(buf);
                            inbuf = 0;
                            break;
                        }
                    }
                }
            }

            this.inbuf_ = inbuf;
            this.total_ += opt_length;
        };

        Sha1.prototype.digest = function () {
            var digest = [];
            var totalBits = this.total_ * 8;

            if (this.inbuf_ < 56) {
                this.update(this.pad_, 56 - this.inbuf_);
            } else {
                this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
            }

            for (var i = this.blockSize - 1; i >= 56; i--) {
                this.buf_[i] = totalBits & 255;
                totalBits /= 256;
            }

            this.compress_(this.buf_);
            var n = 0;

            for (var i = 0; i < 5; i++) {
                for (var j = 24; j >= 0; j -= 8) {
                    digest[n] = this.chain_[i] >> j & 255;
                    ++n;
                }
            }

            return digest;
        };

        return Sha1;
    }(Hash);

    var StreamBridge = function () {
        function StreamBridge(args) {
            this.sendFn = args.sendFn;
            this.closeFn = args.closeFn;
        }

        StreamBridge.prototype.onOpen = function (callback) {
            assert(!this.wrappedOnOpen, 'Called onOpen on stream twice!');
            this.wrappedOnOpen = callback;
        };

        StreamBridge.prototype.onClose = function (callback) {
            assert(!this.wrappedOnClose, 'Called onClose on stream twice!');
            this.wrappedOnClose = callback;
        };

        StreamBridge.prototype.onMessage = function (callback) {
            assert(!this.wrappedOnMessage, 'Called onMessage on stream twice!');
            this.wrappedOnMessage = callback;
        };

        StreamBridge.prototype.close = function () {
            this.closeFn();
        };

        StreamBridge.prototype.send = function (msg) {
            this.sendFn(msg);
        };

        StreamBridge.prototype.callOnOpen = function () {
            assert(this.wrappedOnOpen !== undefined, 'Cannot call onOpen because no callback was set');
            this.wrappedOnOpen();
        };

        StreamBridge.prototype.callOnClose = function (err) {
            assert(this.wrappedOnClose !== undefined, 'Cannot call onClose because no callback was set');
            this.wrappedOnClose(err);
        };

        StreamBridge.prototype.callOnMessage = function (msg) {
            assert(this.wrappedOnMessage !== undefined, 'Cannot call onMessage because no callback was set');
            this.wrappedOnMessage(msg);
        };

        return StreamBridge;
    }();

    var LOG_TAG = 'Connection';
    var RPC_STREAM_SERVICE = 'google.firestore.v1beta1.Firestore';
    var RPC_URL_VERSION = 'v1beta1';
    var RPC_NAME_REST_MAPPING = {
        BatchGetDocuments: 'batchGet',
        Commit: 'commit'
    };
    var X_GOOG_API_CLIENT_VALUE = 'gl-js/ fire/' + SDK_VERSION;
    var XHR_TIMEOUT_SECS = 15;

    var WebChannelConnection = function () {
        function WebChannelConnection(info) {
            this.databaseId = info.databaseId;
            this.pool = new webchannelWrapper.XhrIoPool();
            var proto = info.ssl ? 'https' : 'http';
            this.baseUrl = proto + '://' + info.host;
        }

        WebChannelConnection.prototype.modifyHeadersForRequest = function (headers, token) {
            if (token) {
                for (var header in token.authHeaders) {
                    if (token.authHeaders.hasOwnProperty(header)) {
                        headers[header] = token.authHeaders[header];
                    }
                }
            }

            headers['X-Goog-Api-Client'] = X_GOOG_API_CLIENT_VALUE;
        };

        WebChannelConnection.prototype.invokeRPC = function (rpcName, request, token) {
            var _this = this;

            var url = this.makeUrl(rpcName);
            return new Promise(function (resolve, reject) {
                _this.pool.getObject(function (xhr) {
                    xhr.listenOnce(webchannelWrapper.EventType.COMPLETE, function () {
                        try {
                            switch (xhr.getLastErrorCode()) {
                                case webchannelWrapper.ErrorCode.NO_ERROR:
                                    var json = xhr.getResponseJson();
                                    debug(LOG_TAG, 'XHR received:', JSON.stringify(json));
                                    resolve(json);
                                    break;

                                case webchannelWrapper.ErrorCode.TIMEOUT:
                                    debug(LOG_TAG, 'RPC "' + rpcName + '" timed out');
                                    reject(new FirestoreError(Code.DEADLINE_EXCEEDED, 'Request time out'));
                                    break;

                                case webchannelWrapper.ErrorCode.HTTP_ERROR:
                                    var status_1 = xhr.getStatus();
                                    debug(LOG_TAG, 'RPC "' + rpcName + '" failed with status:', status_1, 'response text:', xhr.getResponseText());

                                    if (status_1 > 0) {
                                        reject(new FirestoreError(mapCodeFromHttpStatus(status_1), 'Server responded with status ' + xhr.getStatusText()));
                                    } else {
                                        debug(LOG_TAG, 'RPC "' + rpcName + '" failed');
                                        reject(new FirestoreError(Code.UNAVAILABLE, 'Connection failed.'));
                                    }

                                    break;

                                default:
                                    fail('RPC "' + rpcName + '" failed with unanticipated ' + 'webchannel error ' + xhr.getLastErrorCode() + ': ' + xhr.getLastError() + ', giving up.');
                            }
                        } finally {
                            debug(LOG_TAG, 'RPC "' + rpcName + '" completed.');

                            _this.pool.releaseObject(xhr);
                        }
                    });
                    var requestString = JSON.stringify(request);
                    debug(LOG_TAG, 'XHR sending: ', url + ' ' + requestString);
                    var headers = {
                        'Content-Type': 'text/plain'
                    };

                    _this.modifyHeadersForRequest(headers, token);

                    xhr.send(url, 'POST', requestString, headers, XHR_TIMEOUT_SECS);
                });
            });
        };

        WebChannelConnection.prototype.invokeStreamingRPC = function (rpcName, request, token) {
            return this.invokeRPC(rpcName, request, token);
        };

        WebChannelConnection.prototype.openStream = function (rpcName, token) {
            var urlParts = [this.baseUrl, '/', RPC_STREAM_SERVICE, '/', rpcName, '/channel'];
            var webchannelTransport = webchannelWrapper.createWebChannelTransport();
            var request = {
                backgroundChannelTest: true,
                httpSessionIdParam: 'gsessionid',
                initMessageHeaders: {},
                messageUrlParams: {
                    database: "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database
                },
                sendRawJson: true,
                supportsCrossDomainXhr: true
            };
            this.modifyHeadersForRequest(request.initMessageHeaders, token);

            if (!isReactNative()) {
                request['httpHeadersOverwriteParam'] = '$httpHeaders';
            }

            var url = urlParts.join('');
            debug(LOG_TAG, 'Creating WebChannel: ' + url + ' ' + request);
            var channel = webchannelTransport.createWebChannel(url, request);
            var opened = false;
            var closed = false;
            var streamBridge = new StreamBridge({
                sendFn: function sendFn(msg) {
                    if (!closed) {
                        if (!opened) {
                            debug(LOG_TAG, 'Opening WebChannel transport.');
                            channel.open();
                            opened = true;
                        }

                        debug(LOG_TAG, 'WebChannel sending:', msg);
                        channel.send(msg);
                    } else {
                        debug(LOG_TAG, 'Not sending because WebChannel is closed:', msg);
                    }
                },
                closeFn: function closeFn() {
                    return channel.close();
                }
            });

            var unguardedEventListen = function unguardedEventListen(type, fn) {
                channel.listen(type, function (param) {
                    try {
                        fn(param);
                    } catch (e) {
                        setTimeout(function () {
                            throw e;
                        }, 0);
                    }
                });
            };

            unguardedEventListen(webchannelWrapper.WebChannel.EventType.OPEN, function () {
                if (!closed) {
                    debug(LOG_TAG, 'WebChannel transport opened.');
                }
            });
            unguardedEventListen(webchannelWrapper.WebChannel.EventType.CLOSE, function () {
                if (!closed) {
                    closed = true;
                    debug(LOG_TAG, 'WebChannel transport closed');
                    streamBridge.callOnClose();
                }
            });
            unguardedEventListen(webchannelWrapper.WebChannel.EventType.ERROR, function (err) {
                if (!closed) {
                    closed = true;
                    debug(LOG_TAG, 'WebChannel transport errored:', err);
                    streamBridge.callOnClose(new FirestoreError(Code.UNAVAILABLE, 'The operation could not be completed'));
                }
            });
            unguardedEventListen(webchannelWrapper.WebChannel.EventType.MESSAGE, function (msg) {
                if (!closed) {
                    var msgData = msg.data[0];
                    assert(!!msgData, 'Got a webchannel message without data.');
                    var error$$1 = msgData.error || msgData[0] && msgData[0].error;

                    if (error$$1) {
                        debug(LOG_TAG, 'WebChannel received error:', error$$1);
                        var status_2 = error$$1.status;
                        var code = mapCodeFromRpcStatus(status_2);
                        var message = error$$1.message;

                        if (code === undefined) {
                            code = Code.INTERNAL;
                            message = 'Unknown error status: ' + status_2 + ' with message ' + error$$1.message;
                        }

                        closed = true;
                        streamBridge.callOnClose(new FirestoreError(code, message));
                        channel.close();
                    } else {
                        debug(LOG_TAG, 'WebChannel received:', msgData);
                        streamBridge.callOnMessage(msgData);
                    }
                }
            });
            setTimeout(function () {
                streamBridge.callOnOpen();
            }, 0);
            return streamBridge;
        };

        WebChannelConnection.prototype.makeUrl = function (rpcName) {
            var urlRpcName = RPC_NAME_REST_MAPPING[rpcName];
            assert(urlRpcName !== undefined, 'Unknown REST mapping for: ' + rpcName);
            var url = [this.baseUrl, '/', RPC_URL_VERSION];
            url.push('/projects/');
            url.push(this.databaseId.projectId);
            url.push('/databases/');
            url.push(this.databaseId.database);
            url.push('/documents');
            url.push(':');
            url.push(urlRpcName);
            return url.join('');
        };

        return WebChannelConnection;
    }();

    var BrowserPlatform = function () {
        function BrowserPlatform() {
            this.emptyByteString = '';
            this.base64Available = typeof atob !== 'undefined';
        }

        Object.defineProperty(BrowserPlatform.prototype, "document", {
            get: function get() {
                return typeof document !== 'undefined' ? document : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BrowserPlatform.prototype, "window", {
            get: function get() {
                return typeof window !== 'undefined' ? window : null;
            },
            enumerable: true,
            configurable: true
        });

        BrowserPlatform.prototype.loadConnection = function (databaseInfo) {
            return Promise.resolve(new WebChannelConnection(databaseInfo));
        };

        BrowserPlatform.prototype.newSerializer = function (databaseId) {
            return new JsonProtoSerializer(databaseId, {
                useProto3Json: true
            });
        };

        BrowserPlatform.prototype.formatJSON = function (value) {
            return JSON.stringify(value);
        };

        BrowserPlatform.prototype.atob = function (encoded) {
            return atob(encoded);
        };

        BrowserPlatform.prototype.btoa = function (raw) {
            return btoa(raw);
        };

        return BrowserPlatform;
    }();

    PlatformSupport.setPlatform(new BrowserPlatform());

    var ListenSequence = function () {
        function ListenSequence(previousValue, sequenceNumberSyncer) {
            var _this = this;

            this.previousValue = previousValue;

            if (sequenceNumberSyncer) {
                sequenceNumberSyncer.sequenceNumberHandler = function (sequenceNumber) {
                    return _this.setPreviousValue(sequenceNumber);
                };

                this.writeNewSequenceNumber = function (sequenceNumber) {
                    return sequenceNumberSyncer.writeSequenceNumber(sequenceNumber);
                };
            }
        }

        ListenSequence.prototype.setPreviousValue = function (externalPreviousValue) {
            this.previousValue = Math.max(externalPreviousValue, this.previousValue);
            return this.previousValue;
        };

        ListenSequence.prototype.next = function () {
            var nextValue = ++this.previousValue;

            if (this.writeNewSequenceNumber) {
                this.writeNewSequenceNumber(nextValue);
            }

            return nextValue;
        };

        ListenSequence.INVALID = -1;
        return ListenSequence;
    }();

    var Deferred$1 = function () {
        function Deferred() {
            var _this = this;

            this.promise = new Promise(function (resolve, reject) {
                _this.resolve = resolve;
                _this.reject = reject;
            });
        }

        return Deferred;
    }();

    var TimerId;

    (function (TimerId) {
        TimerId["All"] = "all";
        TimerId["ListenStreamIdle"] = "listen_stream_idle";
        TimerId["ListenStreamConnectionBackoff"] = "listen_stream_connection_backoff";
        TimerId["WriteStreamIdle"] = "write_stream_idle";
        TimerId["WriteStreamConnectionBackoff"] = "write_stream_connection_backoff";
        TimerId["OnlineStateTimeout"] = "online_state_timeout";
        TimerId["ClientMetadataRefresh"] = "client_metadata_refresh";
    })(TimerId || (TimerId = {}));

    var DelayedOperation = function () {
        function DelayedOperation(asyncQueue, timerId, targetTimeMs, op, removalCallback) {
            this.asyncQueue = asyncQueue;
            this.timerId = timerId;
            this.targetTimeMs = targetTimeMs;
            this.op = op;
            this.removalCallback = removalCallback;
            this.deferred = new Deferred$1();
            this.then = this.deferred.promise.then.bind(this.deferred.promise);
            this.catch = this.deferred.promise.catch.bind(this.deferred.promise);
            this.deferred.promise.catch(function (err) {});
        }

        DelayedOperation.createAndSchedule = function (asyncQueue, timerId, delayMs, op, removalCallback) {
            var targetTime = Date.now() + delayMs;
            var delayedOp = new DelayedOperation(asyncQueue, timerId, targetTime, op, removalCallback);
            delayedOp.start(delayMs);
            return delayedOp;
        };

        DelayedOperation.prototype.start = function (delayMs) {
            var _this = this;

            this.timerHandle = setTimeout(function () {
                return _this.handleDelayElapsed();
            }, delayMs);
        };

        DelayedOperation.prototype.skipDelay = function () {
            return this.handleDelayElapsed();
        };

        DelayedOperation.prototype.cancel = function (reason) {
            if (this.timerHandle !== null) {
                this.clearTimeout();
                this.deferred.reject(new FirestoreError(Code.CANCELLED, 'Operation cancelled' + (reason ? ': ' + reason : '')));
            }
        };

        DelayedOperation.prototype.handleDelayElapsed = function () {
            var _this = this;

            this.asyncQueue.enqueueAndForget(function () {
                if (_this.timerHandle !== null) {
                    _this.clearTimeout();

                    return _this.op().then(function (result) {
                        return _this.deferred.resolve(result);
                    });
                } else {
                    return Promise.resolve();
                }
            });
        };

        DelayedOperation.prototype.clearTimeout = function () {
            if (this.timerHandle !== null) {
                this.removalCallback(this);
                clearTimeout(this.timerHandle);
                this.timerHandle = null;
            }
        };

        return DelayedOperation;
    }();

    var AsyncQueue = function () {
        function AsyncQueue() {
            this.tail = Promise.resolve();
            this.delayedOperations = [];
            this.operationInProgress = false;
        }

        AsyncQueue.prototype.enqueueAndForget = function (op) {
            this.enqueue(op);
        };

        AsyncQueue.prototype.enqueue = function (op) {
            var _this = this;

            this.verifyNotFailed();
            var newTail = this.tail.then(function () {
                _this.operationInProgress = true;
                return op().catch(function (error$$1) {
                    _this.failure = error$$1;
                    _this.operationInProgress = false;
                    var message = error$$1.stack || error$$1.message || '';
                    error('INTERNAL UNHANDLED ERROR: ', message);

                    if (message.indexOf('Firestore Test Simulated Error') < 0) {
                        setTimeout(function () {
                            throw error$$1;
                        }, 0);
                    }

                    throw error$$1;
                }).then(function (result) {
                    _this.operationInProgress = false;
                    return result;
                });
            });
            this.tail = newTail;
            return newTail;
        };

        AsyncQueue.prototype.enqueueAfterDelay = function (timerId, delayMs, op) {
            var _this = this;

            this.verifyNotFailed();
            assert(delayMs >= 0, "Attempted to schedule an operation with a negative delay of " + delayMs);
            assert(!this.containsDelayedOperation(timerId), "Attempted to schedule multiple operations with timer id " + timerId + ".");
            var delayedOp = DelayedOperation.createAndSchedule(this, timerId, delayMs, op, function (op) {
                return _this.removeDelayedOperation(op);
            });
            this.delayedOperations.push(delayedOp);
            return delayedOp;
        };

        AsyncQueue.prototype.verifyNotFailed = function () {
            if (this.failure) {
                fail('AsyncQueue is already failed: ' + (this.failure.stack || this.failure.message));
            }
        };

        AsyncQueue.prototype.verifyOperationInProgress = function () {
            assert(this.operationInProgress, 'verifyOpInProgress() called when no op in progress on this queue.');
        };

        AsyncQueue.prototype.drain = function () {
            return this.enqueue(function () {
                return Promise.resolve();
            });
        };

        AsyncQueue.prototype.containsDelayedOperation = function (timerId) {
            return this.delayedOperations.findIndex(function (op) {
                return op.timerId === timerId;
            }) >= 0;
        };

        AsyncQueue.prototype.runDelayedOperationsEarly = function (lastTimerId) {
            var _this = this;

            return this.drain().then(function () {
                assert(lastTimerId === TimerId.All || _this.containsDelayedOperation(lastTimerId), "Attempted to drain to missing operation " + lastTimerId);

                _this.delayedOperations.sort(function (a, b) {
                    return a.targetTimeMs - b.targetTimeMs;
                });

                for (var _i = 0, _a = _this.delayedOperations; _i < _a.length; _i++) {
                    var op = _a[_i];
                    op.skipDelay();

                    if (lastTimerId !== TimerId.All && op.timerId === lastTimerId) {
                        break;
                    }
                }

                return _this.drain();
            });
        };

        AsyncQueue.prototype.removeDelayedOperation = function (op) {
            var index = this.delayedOperations.indexOf(op);
            assert(index >= 0, 'Delayed operation not found.');
            this.delayedOperations.splice(index, 1);
        };

        return AsyncQueue;
    }();

    var escapeChar = "\x01";
    var encodedSeparatorChar = "\x01";
    var encodedNul = "\x10";
    var encodedEscape = "\x11";

    function encode(path) {
        var result = '';

        for (var i = 0; i < path.length; i++) {
            if (result.length > 0) {
                result = encodeSeparator(result);
            }

            result = encodeSegment(path.get(i), result);
        }

        return encodeSeparator(result);
    }

    function encodeSegment(segment, resultBuf) {
        var result = resultBuf;
        var length = segment.length;

        for (var i = 0; i < length; i++) {
            var c = segment.charAt(i);

            switch (c) {
                case '\0':
                    result += escapeChar + encodedNul;
                    break;

                case escapeChar:
                    result += escapeChar + encodedEscape;
                    break;

                default:
                    result += c;
            }
        }

        return result;
    }

    function encodeSeparator(result) {
        return result + escapeChar + encodedSeparatorChar;
    }

    function decode$1(path) {
        var length = path.length;
        assert(length >= 2, 'Invalid path ' + path);

        if (length === 2) {
            assert(path.charAt(0) === escapeChar && path.charAt(1) === encodedSeparatorChar, 'Non-empty path ' + path + ' had length 2');
            return ResourcePath.EMPTY_PATH;
        }

        var lastReasonableEscapeIndex = length - 2;
        var segments = [];
        var segmentBuilder = '';

        for (var start = 0; start < length;) {
            var end = path.indexOf(escapeChar, start);

            if (end < 0 || end > lastReasonableEscapeIndex) {
                fail('Invalid encoded resource path: "' + path + '"');
            }

            var next = path.charAt(end + 1);

            switch (next) {
                case encodedSeparatorChar:
                    var currentPiece = path.substring(start, end);
                    var segment = void 0;

                    if (segmentBuilder.length === 0) {
                        segment = currentPiece;
                    } else {
                        segmentBuilder += currentPiece;
                        segment = segmentBuilder;
                        segmentBuilder = '';
                    }

                    segments.push(segment);
                    break;

                case encodedNul:
                    segmentBuilder += path.substring(start, end);
                    segmentBuilder += '\0';
                    break;

                case encodedEscape:
                    segmentBuilder += path.substring(start, end + 1);
                    break;

                default:
                    fail('Invalid encoded resource path: "' + path + '"');
            }

            start = end + 2;
        }

        return new ResourcePath(segments);
    }

    var BATCHID_UNKNOWN = -1;

    var MutationBatch = function () {
        function MutationBatch(batchId, localWriteTime, mutations) {
            this.batchId = batchId;
            this.localWriteTime = localWriteTime;
            this.mutations = mutations;
        }

        MutationBatch.prototype.applyToRemoteDocument = function (docKey, maybeDoc, batchResult) {
            if (maybeDoc) {
                assert(maybeDoc.key.isEqual(docKey), "applyToRemoteDocument: key " + docKey + " should match maybeDoc key\n        " + maybeDoc.key);
            }

            var mutationResults = batchResult.mutationResults;
            assert(mutationResults.length === this.mutations.length, "Mismatch between mutations length\n      (" + this.mutations.length + ") and mutation results length\n      (" + mutationResults.length + ").");

            for (var i = 0; i < this.mutations.length; i++) {
                var mutation = this.mutations[i];

                if (mutation.key.isEqual(docKey)) {
                    var mutationResult = mutationResults[i];
                    maybeDoc = mutation.applyToRemoteDocument(maybeDoc, mutationResult);
                }
            }

            return maybeDoc;
        };

        MutationBatch.prototype.applyToLocalView = function (docKey, maybeDoc) {
            if (maybeDoc) {
                assert(maybeDoc.key.isEqual(docKey), "applyToLocalDocument: key " + docKey + " should match maybeDoc key\n        " + maybeDoc.key);
            }

            var baseDoc = maybeDoc;

            for (var i = 0; i < this.mutations.length; i++) {
                var mutation = this.mutations[i];

                if (mutation.key.isEqual(docKey)) {
                    maybeDoc = mutation.applyToLocalView(maybeDoc, baseDoc, this.localWriteTime);
                }
            }

            return maybeDoc;
        };

        MutationBatch.prototype.keys = function () {
            var keySet = documentKeySet();

            for (var _i = 0, _a = this.mutations; _i < _a.length; _i++) {
                var mutation = _a[_i];
                keySet = keySet.add(mutation.key);
            }

            return keySet;
        };

        MutationBatch.prototype.isEqual = function (other) {
            return this.batchId === other.batchId && arrayEquals(this.mutations, other.mutations);
        };

        MutationBatch.prototype.isTombstone = function () {
            return this.mutations.length === 0;
        };

        MutationBatch.prototype.toTombstone = function () {
            return new MutationBatch(this.batchId, this.localWriteTime, []);
        };

        return MutationBatch;
    }();

    var MutationBatchResult = function () {
        function MutationBatchResult(batch, commitVersion, mutationResults, streamToken, docVersions) {
            this.batch = batch;
            this.commitVersion = commitVersion;
            this.mutationResults = mutationResults;
            this.streamToken = streamToken;
            this.docVersions = docVersions;
        }

        MutationBatchResult.from = function (batch, commitVersion, results, streamToken) {
            assert(batch.mutations.length === results.length, 'Mutations sent ' + batch.mutations.length + ' must equal results received ' + results.length);
            var versionMap = documentVersionMap();
            var mutations = batch.mutations;

            for (var i = 0; i < mutations.length; i++) {
                versionMap = versionMap.insert(mutations[i].key, results[i].version);
            }

            return new MutationBatchResult(batch, commitVersion, results, streamToken, versionMap);
        };

        return MutationBatchResult;
    }();

    var PersistencePromise = function () {
        function PersistencePromise(callback) {
            var _this = this;

            this.nextCallback = null;
            this.catchCallback = null;
            this.result = undefined;
            this.error = undefined;
            this.isDone = false;
            this.callbackAttached = false;
            callback(function (value) {
                _this.isDone = true;
                _this.result = value;

                if (_this.nextCallback) {
                    _this.nextCallback(value);
                }
            }, function (error) {
                _this.isDone = true;
                _this.error = error;

                if (_this.catchCallback) {
                    _this.catchCallback(error);
                }
            });
        }

        PersistencePromise.prototype.catch = function (fn) {
            return this.next(undefined, fn);
        };

        PersistencePromise.prototype.next = function (nextFn, catchFn) {
            var _this = this;

            if (this.callbackAttached) {
                fail('Called next() or catch() twice for PersistencePromise');
            }

            this.callbackAttached = true;

            if (this.isDone) {
                if (!this.error) {
                    return this.wrapSuccess(nextFn, this.result);
                } else {
                    return this.wrapFailure(catchFn, this.error);
                }
            } else {
                return new PersistencePromise(function (resolve, reject) {
                    _this.nextCallback = function (value) {
                        _this.wrapSuccess(nextFn, value).next(resolve, reject);
                    };

                    _this.catchCallback = function (error) {
                        _this.wrapFailure(catchFn, error).next(resolve, reject);
                    };
                });
            }
        };

        PersistencePromise.prototype.toPromise = function () {
            var _this = this;

            return new Promise(function (resolve, reject) {
                _this.next(resolve, reject);
            });
        };

        PersistencePromise.prototype.wrapUserFunction = function (fn) {
            try {
                var result = fn();

                if (result instanceof PersistencePromise) {
                    return result;
                } else {
                    return PersistencePromise.resolve(result);
                }
            } catch (e) {
                return PersistencePromise.reject(e);
            }
        };

        PersistencePromise.prototype.wrapSuccess = function (nextFn, value) {
            if (nextFn) {
                return this.wrapUserFunction(function () {
                    return nextFn(value);
                });
            } else {
                return PersistencePromise.resolve(value);
            }
        };

        PersistencePromise.prototype.wrapFailure = function (catchFn, error) {
            if (catchFn) {
                return this.wrapUserFunction(function () {
                    return catchFn(error);
                });
            } else {
                return PersistencePromise.reject(error);
            }
        };

        PersistencePromise.resolve = function (result) {
            return new PersistencePromise(function (resolve, reject) {
                resolve(result);
            });
        };

        PersistencePromise.reject = function (error) {
            return new PersistencePromise(function (resolve, reject) {
                reject(error);
            });
        };

        PersistencePromise.waitFor = function (all) {
            var it = all[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]();
            return new PersistencePromise(function (resolve, reject) {
                var expectedCount = 0;
                var resolvedCount = 0;
                var result = it.next();

                while (!result.done) {
                    ++expectedCount;
                    result.value.next(function () {
                        ++resolvedCount;

                        if (result.done && resolvedCount === expectedCount) {
                            resolve();
                        }
                    }, function (err) {
                        return reject(err);
                    });
                    result = it.next();
                }

                if (resolvedCount === expectedCount) {
                    resolve();
                }
            });
        };

        PersistencePromise.map = function (all) {
            var results = [];
            var promises = [];
            var it = all[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]();
            var result = it.next();
            var count = 0;

            var _loop_1 = function _loop_1() {
                var value = result.value;
                var index = count;
                promises.push(value.next(function (val) {
                    results[index] = val;
                }));
                result = it.next();
                ++count;
            };

            while (!result.done) {
                _loop_1();
            }

            return PersistencePromise.waitFor(promises).next(function () {
                return results;
            });
        };

        PersistencePromise.or = function (predicates) {
            var p = PersistencePromise.resolve(false);

            var _loop_2 = function _loop_2(predicate) {
                p = p.next(function (isTrue) {
                    if (isTrue) {
                        return PersistencePromise.resolve(isTrue);
                    } else {
                        return predicate();
                    }
                });
            };

            for (var _i = 0, predicates_1 = predicates; _i < predicates_1.length; _i++) {
                var predicate = predicates_1[_i];

                _loop_2(predicate);
            }

            return p;
        };

        PersistencePromise.forEach = function (collection, f) {
            var it = collection[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]();
            var promises = [];
            var result = it.next();

            while (!result.done) {
                var value = result.value;
                promises.push(f(value));
                result = it.next();
            }

            return this.waitFor(promises);
        };

        return PersistencePromise;
    }();

    var SCHEMA_VERSION = 5;

    var SchemaConverter = function () {
        function SchemaConverter(serializer) {
            this.serializer = serializer;
        }

        SchemaConverter.prototype.createOrUpgrade = function (db, txn, fromVersion, toVersion) {
            var _this = this;

            assert(fromVersion < toVersion && fromVersion >= 0 && toVersion <= SCHEMA_VERSION, "Unexpected schema upgrade from v" + fromVersion + " to v{toVersion}.");

            if (fromVersion < 1 && toVersion >= 1) {
                createPrimaryClientStore(db);
                createMutationQueue(db);
                createQueryCache(db);
                createRemoteDocumentCache(db);
            }

            var p = PersistencePromise.resolve();

            if (fromVersion < 3 && toVersion >= 3) {
                if (fromVersion !== 0) {
                    dropQueryCache(db);
                    createQueryCache(db);
                }

                p = p.next(function () {
                    return writeEmptyTargetGlobalEntry(txn);
                });
            }

            if (fromVersion < 4 && toVersion >= 4) {
                if (fromVersion !== 0) {
                    p = p.next(function () {
                        return upgradeMutationBatchSchemaAndMigrateData(db, txn);
                    });
                }

                p = p.next(function () {
                    createClientMetadataStore(db);
                    createRemoteDocumentChangesStore(db);
                });
            }

            if (fromVersion < 5 && toVersion >= 5) {
                p = p.next(function () {
                    return _this.removeAcknowledgedMutations(txn);
                });
            }

            return p;
        };

        SchemaConverter.prototype.removeAcknowledgedMutations = function (txn) {
            var _this = this;

            var queuesStore = txn.store(DbMutationQueue.store);
            var mutationsStore = txn.store(DbMutationBatch.store);
            return queuesStore.loadAll().next(function (queues) {
                return PersistencePromise.forEach(queues, function (queue) {
                    var range = IDBKeyRange.bound([queue.userId, BATCHID_UNKNOWN], [queue.userId, queue.lastAcknowledgedBatchId]);
                    return mutationsStore.loadAll(DbMutationBatch.userMutationsIndex, range).next(function (dbBatches) {
                        return PersistencePromise.forEach(dbBatches, function (dbBatch) {
                            assert(dbBatch.userId === queue.userId, "Cannot process batch " + dbBatch.batchId + " from unexpected user");

                            var batch = _this.serializer.fromDbMutationBatch(dbBatch);

                            return removeMutationBatch(txn, queue.userId, batch).next();
                        });
                    });
                });
            });
        };

        return SchemaConverter;
    }();

    var DbTimestamp = function () {
        function DbTimestamp(seconds, nanoseconds) {
            this.seconds = seconds;
            this.nanoseconds = nanoseconds;
        }

        return DbTimestamp;
    }();

    var DbPrimaryClient = function () {
        function DbPrimaryClient(ownerId, allowTabSynchronization, leaseTimestampMs) {
            this.ownerId = ownerId;
            this.allowTabSynchronization = allowTabSynchronization;
            this.leaseTimestampMs = leaseTimestampMs;
        }

        DbPrimaryClient.store = 'owner';
        DbPrimaryClient.key = 'owner';
        return DbPrimaryClient;
    }();

    function createPrimaryClientStore(db) {
        db.createObjectStore(DbPrimaryClient.store);
    }

    var DbMutationQueue = function () {
        function DbMutationQueue(userId, lastAcknowledgedBatchId, lastStreamToken) {
            this.userId = userId;
            this.lastAcknowledgedBatchId = lastAcknowledgedBatchId;
            this.lastStreamToken = lastStreamToken;
        }

        DbMutationQueue.store = 'mutationQueues';
        DbMutationQueue.keyPath = 'userId';
        return DbMutationQueue;
    }();

    var DbMutationBatch = function () {
        function DbMutationBatch(userId, batchId, localWriteTimeMs, mutations) {
            this.userId = userId;
            this.batchId = batchId;
            this.localWriteTimeMs = localWriteTimeMs;
            this.mutations = mutations;
        }

        DbMutationBatch.store = 'mutations';
        DbMutationBatch.keyPath = 'batchId';
        DbMutationBatch.userMutationsIndex = 'userMutationsIndex';
        DbMutationBatch.userMutationsKeyPath = ['userId', 'batchId'];
        return DbMutationBatch;
    }();

    function createMutationQueue(db) {
        db.createObjectStore(DbMutationQueue.store, {
            keyPath: DbMutationQueue.keyPath
        });
        var mutationBatchesStore = db.createObjectStore(DbMutationBatch.store, {
            keyPath: DbMutationBatch.keyPath,
            autoIncrement: true
        });
        mutationBatchesStore.createIndex(DbMutationBatch.userMutationsIndex, DbMutationBatch.userMutationsKeyPath, {
            unique: true
        });
        db.createObjectStore(DbDocumentMutation.store);
    }

    function upgradeMutationBatchSchemaAndMigrateData(db, txn) {
        var v1MutationsStore = txn.store(DbMutationBatch.store);
        return v1MutationsStore.loadAll().next(function (existingMutations) {
            db.deleteObjectStore(DbMutationBatch.store);
            var mutationsStore = db.createObjectStore(DbMutationBatch.store, {
                keyPath: DbMutationBatch.keyPath,
                autoIncrement: true
            });
            mutationsStore.createIndex(DbMutationBatch.userMutationsIndex, DbMutationBatch.userMutationsKeyPath, {
                unique: true
            });
            var v3MutationsStore = txn.store(DbMutationBatch.store);
            var writeAll = existingMutations.map(function (mutation) {
                return v3MutationsStore.put(mutation);
            });
            return PersistencePromise.waitFor(writeAll);
        });
    }

    var DbDocumentMutation = function () {
        function DbDocumentMutation() {}

        DbDocumentMutation.prefixForUser = function (userId) {
            return [userId];
        };

        DbDocumentMutation.prefixForPath = function (userId, path) {
            return [userId, encode(path)];
        };

        DbDocumentMutation.key = function (userId, path, batchId) {
            return [userId, encode(path), batchId];
        };

        DbDocumentMutation.store = 'documentMutations';
        DbDocumentMutation.PLACEHOLDER = new DbDocumentMutation();
        return DbDocumentMutation;
    }();

    function createRemoteDocumentCache(db) {
        db.createObjectStore(DbRemoteDocument.store);
    }

    var DbNoDocument = function () {
        function DbNoDocument(path, readTime) {
            this.path = path;
            this.readTime = readTime;
        }

        return DbNoDocument;
    }();

    var DbUnknownDocument = function () {
        function DbUnknownDocument(path, version) {
            this.path = path;
            this.version = version;
        }

        return DbUnknownDocument;
    }();

    var DbRemoteDocument = function () {
        function DbRemoteDocument(unknownDocument, noDocument, document, hasCommittedMutations) {
            this.unknownDocument = unknownDocument;
            this.noDocument = noDocument;
            this.document = document;
            this.hasCommittedMutations = hasCommittedMutations;
        }

        DbRemoteDocument.store = 'remoteDocuments';
        return DbRemoteDocument;
    }();

    var DbTarget = function () {
        function DbTarget(targetId, canonicalId, readTime, resumeToken, lastListenSequenceNumber, query) {
            this.targetId = targetId;
            this.canonicalId = canonicalId;
            this.readTime = readTime;
            this.resumeToken = resumeToken;
            this.lastListenSequenceNumber = lastListenSequenceNumber;
            this.query = query;
        }

        DbTarget.store = 'targets';
        DbTarget.keyPath = 'targetId';
        DbTarget.queryTargetsIndexName = 'queryTargetsIndex';
        DbTarget.queryTargetsKeyPath = ['canonicalId', 'targetId'];
        return DbTarget;
    }();

    var DbTargetDocument = function () {
        function DbTargetDocument(targetId, path, sequenceNumber) {
            this.targetId = targetId;
            this.path = path;
            this.sequenceNumber = sequenceNumber;
            assert(targetId === 0 === (sequenceNumber !== undefined), 'A target-document row must either have targetId == 0 and a defined sequence number, or a non-zero targetId and no sequence number');
        }

        DbTargetDocument.store = 'targetDocuments';
        DbTargetDocument.keyPath = ['targetId', 'path'];
        DbTargetDocument.documentTargetsIndex = 'documentTargetsIndex';
        DbTargetDocument.documentTargetsKeyPath = ['path', 'targetId'];
        return DbTargetDocument;
    }();

    var DbTargetGlobal = function () {
        function DbTargetGlobal(highestTargetId, highestListenSequenceNumber, lastRemoteSnapshotVersion, targetCount) {
            this.highestTargetId = highestTargetId;
            this.highestListenSequenceNumber = highestListenSequenceNumber;
            this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;
            this.targetCount = targetCount;
        }

        DbTargetGlobal.key = 'targetGlobalKey';
        DbTargetGlobal.store = 'targetGlobal';
        return DbTargetGlobal;
    }();

    function createQueryCache(db) {
        var targetDocumentsStore = db.createObjectStore(DbTargetDocument.store, {
            keyPath: DbTargetDocument.keyPath
        });
        targetDocumentsStore.createIndex(DbTargetDocument.documentTargetsIndex, DbTargetDocument.documentTargetsKeyPath, {
            unique: true
        });
        var targetStore = db.createObjectStore(DbTarget.store, {
            keyPath: DbTarget.keyPath
        });
        targetStore.createIndex(DbTarget.queryTargetsIndexName, DbTarget.queryTargetsKeyPath, {
            unique: true
        });
        db.createObjectStore(DbTargetGlobal.store);
    }

    function dropQueryCache(db) {
        db.deleteObjectStore(DbTargetDocument.store);
        db.deleteObjectStore(DbTarget.store);
        db.deleteObjectStore(DbTargetGlobal.store);
    }

    function writeEmptyTargetGlobalEntry(txn) {
        var globalStore = txn.store(DbTargetGlobal.store);
        var metadata = new DbTargetGlobal(0, 0, SnapshotVersion.MIN.toTimestamp(), 0);
        return globalStore.put(DbTargetGlobal.key, metadata);
    }

    var DbRemoteDocumentChanges = function () {
        function DbRemoteDocumentChanges(changes) {
            this.changes = changes;
        }

        DbRemoteDocumentChanges.store = 'remoteDocumentChanges';
        DbRemoteDocumentChanges.keyPath = 'id';
        return DbRemoteDocumentChanges;
    }();

    function createRemoteDocumentChangesStore(db) {
        db.createObjectStore(DbRemoteDocumentChanges.store, {
            keyPath: 'id',
            autoIncrement: true
        });
    }

    var DbClientMetadata = function () {
        function DbClientMetadata(clientId, updateTimeMs, networkEnabled, inForeground, lastProcessedDocumentChangeId) {
            this.clientId = clientId;
            this.updateTimeMs = updateTimeMs;
            this.networkEnabled = networkEnabled;
            this.inForeground = inForeground;
            this.lastProcessedDocumentChangeId = lastProcessedDocumentChangeId;
        }

        DbClientMetadata.store = 'clientMetadata';
        DbClientMetadata.keyPath = 'clientId';
        return DbClientMetadata;
    }();

    function createClientMetadataStore(db) {
        db.createObjectStore(DbClientMetadata.store, {
            keyPath: DbClientMetadata.keyPath
        });
    }

    var V1_STORES = [DbMutationQueue.store, DbMutationBatch.store, DbDocumentMutation.store, DbRemoteDocument.store, DbTarget.store, DbPrimaryClient.store, DbTargetGlobal.store, DbTargetDocument.store];
    var V3_STORES = V1_STORES;
    var V4_STORES = V3_STORES.concat([DbClientMetadata.store, DbRemoteDocumentChanges.store]);
    var ALL_STORES = V4_STORES;

    var IndexedDbMutationQueue = function () {
        function IndexedDbMutationQueue(userId, serializer, referenceDelegate) {
            this.userId = userId;
            this.serializer = serializer;
            this.referenceDelegate = referenceDelegate;
            this.documentKeysByBatchId = {};
        }

        IndexedDbMutationQueue.forUser = function (user, serializer, referenceDelegate) {
            assert(user.uid !== '', 'UserID must not be an empty string.');
            var userId = user.isAuthenticated() ? user.uid : '';
            return new IndexedDbMutationQueue(userId, serializer, referenceDelegate);
        };

        IndexedDbMutationQueue.prototype.checkEmpty = function (transaction) {
            var empty = true;
            var range = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
            return mutationsStore(transaction).iterate({
                index: DbMutationBatch.userMutationsIndex,
                range: range
            }, function (key, value, control) {
                empty = false;
                control.done();
            }).next(function () {
                return empty;
            });
        };

        IndexedDbMutationQueue.prototype.acknowledgeBatch = function (transaction, batch, streamToken) {
            return this.getMutationQueueMetadata(transaction).next(function (metadata) {
                var batchId = batch.batchId;
                assert(batchId > metadata.lastAcknowledgedBatchId, 'Mutation batchIDs must be acknowledged in order');
                metadata.lastAcknowledgedBatchId = batchId;
                metadata.lastStreamToken = convertStreamToken(streamToken);
                return mutationQueuesStore(transaction).put(metadata);
            });
        };

        IndexedDbMutationQueue.prototype.getLastStreamToken = function (transaction) {
            return this.getMutationQueueMetadata(transaction).next(function (metadata) {
                return metadata.lastStreamToken;
            });
        };

        IndexedDbMutationQueue.prototype.setLastStreamToken = function (transaction, streamToken) {
            return this.getMutationQueueMetadata(transaction).next(function (metadata) {
                metadata.lastStreamToken = convertStreamToken(streamToken);
                return mutationQueuesStore(transaction).put(metadata);
            });
        };

        IndexedDbMutationQueue.prototype.addMutationBatch = function (transaction, localWriteTime, mutations) {
            var _this = this;

            var documentStore = documentMutationsStore(transaction);
            var mutationStore = mutationsStore(transaction);
            return mutationStore.add({}).next(function (batchId) {
                assert(typeof batchId === 'number', 'Auto-generated key is not a number');
                var batch = new MutationBatch(batchId, localWriteTime, mutations);

                var dbBatch = _this.serializer.toDbMutationBatch(_this.userId, batch);

                _this.documentKeysByBatchId[batchId] = batch.keys();
                var promises = [];

                for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {
                    var mutation = mutations_1[_i];
                    var indexKey = DbDocumentMutation.key(_this.userId, mutation.key.path, batchId);
                    promises.push(mutationStore.put(dbBatch));
                    promises.push(documentStore.put(indexKey, DbDocumentMutation.PLACEHOLDER));
                }

                return PersistencePromise.waitFor(promises).next(function () {
                    return batch;
                });
            });
        };

        IndexedDbMutationQueue.prototype.lookupMutationBatch = function (transaction, batchId) {
            var _this = this;

            return mutationsStore(transaction).get(batchId).next(function (dbBatch) {
                if (dbBatch) {
                    assert(dbBatch.userId === _this.userId, "Unexpected user '" + dbBatch.userId + "' for mutation batch " + batchId);
                    return _this.serializer.fromDbMutationBatch(dbBatch);
                }

                return null;
            });
        };

        IndexedDbMutationQueue.prototype.lookupMutationKeys = function (transaction, batchId) {
            var _this = this;

            if (this.documentKeysByBatchId[batchId]) {
                return PersistencePromise.resolve(this.documentKeysByBatchId[batchId]);
            } else {
                return this.lookupMutationBatch(transaction, batchId).next(function (batch) {
                    if (batch) {
                        var keys = batch.keys();
                        _this.documentKeysByBatchId[batchId] = keys;
                        return keys;
                    } else {
                        return null;
                    }
                });
            }
        };

        IndexedDbMutationQueue.prototype.getNextMutationBatchAfterBatchId = function (transaction, batchId) {
            var _this = this;

            return this.getMutationQueueMetadata(transaction).next(function (metadata) {
                var nextBatchId = Math.max(batchId, metadata.lastAcknowledgedBatchId) + 1;
                var range = IDBKeyRange.lowerBound([_this.userId, nextBatchId]);
                var foundBatch = null;
                return mutationsStore(transaction).iterate({
                    index: DbMutationBatch.userMutationsIndex,
                    range: range
                }, function (key, dbBatch, control) {
                    if (dbBatch.userId === _this.userId) {
                        assert(dbBatch.batchId >= nextBatchId, 'Should have found mutation after ' + nextBatchId);
                        foundBatch = _this.serializer.fromDbMutationBatch(dbBatch);
                    }

                    control.done();
                }).next(function () {
                    return foundBatch;
                });
            });
        };

        IndexedDbMutationQueue.prototype.getAllMutationBatches = function (transaction) {
            var _this = this;

            var range = IDBKeyRange.bound([this.userId, BATCHID_UNKNOWN], [this.userId, Number.POSITIVE_INFINITY]);
            return mutationsStore(transaction).loadAll(DbMutationBatch.userMutationsIndex, range).next(function (dbBatches) {
                return dbBatches.map(function (dbBatch) {
                    return _this.serializer.fromDbMutationBatch(dbBatch);
                });
            });
        };

        IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKey = function (transaction, documentKey) {
            var _this = this;

            var indexPrefix = DbDocumentMutation.prefixForPath(this.userId, documentKey.path);
            var indexStart = IDBKeyRange.lowerBound(indexPrefix);
            var results = [];
            return documentMutationsStore(transaction).iterate({
                range: indexStart
            }, function (indexKey, _, control) {
                var userID = indexKey[0],
                    encodedPath = indexKey[1],
                    batchId = indexKey[2];
                var path = decode$1(encodedPath);

                if (userID !== _this.userId || !documentKey.path.isEqual(path)) {
                    control.done();
                    return;
                }

                return mutationsStore(transaction).get(batchId).next(function (mutation) {
                    if (!mutation) {
                        throw fail('Dangling document-mutation reference found: ' + indexKey + ' which points to ' + batchId);
                    }

                    assert(mutation.userId === _this.userId, "Unexpected user '" + mutation.userId + "' for mutation batch " + batchId);
                    results.push(_this.serializer.fromDbMutationBatch(mutation));
                });
            }).next(function () {
                return results;
            });
        };

        IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKeys = function (transaction, documentKeys) {
            var _this = this;

            var uniqueBatchIDs = new SortedSet(primitiveComparator);
            var promises = [];
            documentKeys.forEach(function (documentKey) {
                var indexStart = DbDocumentMutation.prefixForPath(_this.userId, documentKey.path);
                var range = IDBKeyRange.lowerBound(indexStart);
                var promise = documentMutationsStore(transaction).iterate({
                    range: range
                }, function (indexKey, _, control) {
                    var userID = indexKey[0],
                        encodedPath = indexKey[1],
                        batchID = indexKey[2];
                    var path = decode$1(encodedPath);

                    if (userID !== _this.userId || !documentKey.path.isEqual(path)) {
                        control.done();
                        return;
                    }

                    uniqueBatchIDs = uniqueBatchIDs.add(batchID);
                });
                promises.push(promise);
            });
            return PersistencePromise.waitFor(promises).next(function () {
                return _this.lookupMutationBatches(transaction, uniqueBatchIDs);
            });
        };

        IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingQuery = function (transaction, query) {
            var _this = this;

            assert(!query.isDocumentQuery(), "Document queries shouldn't go down this path");
            var queryPath = query.path;
            var immediateChildrenLength = queryPath.length + 1;
            var indexPrefix = DbDocumentMutation.prefixForPath(this.userId, queryPath);
            var indexStart = IDBKeyRange.lowerBound(indexPrefix);
            var uniqueBatchIDs = new SortedSet(primitiveComparator);
            return documentMutationsStore(transaction).iterate({
                range: indexStart
            }, function (indexKey, _, control) {
                var userID = indexKey[0],
                    encodedPath = indexKey[1],
                    batchID = indexKey[2];
                var path = decode$1(encodedPath);

                if (userID !== _this.userId || !queryPath.isPrefixOf(path)) {
                    control.done();
                    return;
                }

                if (path.length !== immediateChildrenLength) {
                    return;
                }

                uniqueBatchIDs = uniqueBatchIDs.add(batchID);
            }).next(function () {
                return _this.lookupMutationBatches(transaction, uniqueBatchIDs);
            });
        };

        IndexedDbMutationQueue.prototype.lookupMutationBatches = function (transaction, batchIDs) {
            var _this = this;

            var results = [];
            var promises = [];
            batchIDs.forEach(function (batchId) {
                promises.push(mutationsStore(transaction).get(batchId).next(function (mutation) {
                    if (mutation === null) {
                        throw fail('Dangling document-mutation reference found, ' + 'which points to ' + batchId);
                    }

                    assert(mutation.userId === _this.userId, "Unexpected user '" + mutation.userId + "' for mutation batch " + batchId);
                    results.push(_this.serializer.fromDbMutationBatch(mutation));
                }));
            });
            return PersistencePromise.waitFor(promises).next(function () {
                return results;
            });
        };

        IndexedDbMutationQueue.prototype.removeMutationBatch = function (transaction, batch) {
            var _this = this;

            return removeMutationBatch(transaction.simpleDbTransaction, this.userId, batch).next(function (removedDocuments) {
                _this.removeCachedMutationKeys(batch.batchId);

                return PersistencePromise.forEach(removedDocuments, function (key) {
                    return _this.referenceDelegate.removeMutationReference(transaction, key);
                });
            });
        };

        IndexedDbMutationQueue.prototype.removeCachedMutationKeys = function (batchId) {
            delete this.documentKeysByBatchId[batchId];
        };

        IndexedDbMutationQueue.prototype.performConsistencyCheck = function (txn) {
            var _this = this;

            return this.checkEmpty(txn).next(function (empty) {
                if (!empty) {
                    return PersistencePromise.resolve();
                }

                var startRange = IDBKeyRange.lowerBound(DbDocumentMutation.prefixForUser(_this.userId));
                var danglingMutationReferences = [];
                return documentMutationsStore(txn).iterate({
                    range: startRange
                }, function (key, _, control) {
                    var userID = key[0];

                    if (userID !== _this.userId) {
                        control.done();
                        return;
                    } else {
                        var path = decode$1(key[1]);
                        danglingMutationReferences.push(path);
                    }
                }).next(function () {
                    assert(danglingMutationReferences.length === 0, 'Document leak -- detected dangling mutation references when queue is empty. ' + 'Dangling keys: ' + danglingMutationReferences.map(function (p) {
                        return p.canonicalString();
                    }));
                });
            });
        };

        IndexedDbMutationQueue.prototype.containsKey = function (txn, key) {
            return mutationQueueContainsKey(txn, this.userId, key);
        };

        IndexedDbMutationQueue.prototype.getMutationQueueMetadata = function (transaction) {
            var _this = this;

            return mutationQueuesStore(transaction).get(this.userId).next(function (metadata) {
                return metadata || new DbMutationQueue(_this.userId, BATCHID_UNKNOWN, '');
            });
        };

        return IndexedDbMutationQueue;
    }();

    function mutationQueueContainsKey(txn, userId, key) {
        var indexKey = DbDocumentMutation.prefixForPath(userId, key.path);
        var encodedPath = indexKey[1];
        var startRange = IDBKeyRange.lowerBound(indexKey);
        var containsKey = false;
        return documentMutationsStore(txn).iterate({
            range: startRange,
            keysOnly: true
        }, function (key, value, control) {
            var userID = key[0],
                keyPath = key[1],
                _ = key[2];

            if (userID === userId && keyPath === encodedPath) {
                containsKey = true;
            }

            control.done();
        }).next(function () {
            return containsKey;
        });
    }

    function mutationQueuesContainKey(txn, docKey) {
        var found = false;
        return mutationQueuesStore(txn).iterateSerial(function (userId) {
            return mutationQueueContainsKey(txn, userId, docKey).next(function (containsKey) {
                if (containsKey) {
                    found = true;
                }

                return PersistencePromise.resolve(!containsKey);
            });
        }).next(function () {
            return found;
        });
    }

    function removeMutationBatch(txn, userId, batch) {
        var mutationStore = txn.store(DbMutationBatch.store);
        var indexTxn = txn.store(DbDocumentMutation.store);
        var promises = [];
        var range = IDBKeyRange.only(batch.batchId);
        var numDeleted = 0;
        var removePromise = mutationStore.iterate({
            range: range
        }, function (key, value, control) {
            numDeleted++;
            return control.delete();
        });
        promises.push(removePromise.next(function () {
            assert(numDeleted === 1, 'Dangling document-mutation reference found: Missing batch ' + batch.batchId);
        }));
        var removedDocuments = [];

        for (var _i = 0, _a = batch.mutations; _i < _a.length; _i++) {
            var mutation = _a[_i];
            var indexKey = DbDocumentMutation.key(userId, mutation.key.path, batch.batchId);
            promises.push(indexTxn.delete(indexKey));
            removedDocuments.push(mutation.key);
        }

        return PersistencePromise.waitFor(promises).next(function () {
            return removedDocuments;
        });
    }

    function convertStreamToken(token) {
        if (token instanceof Uint8Array) {
            assert(process.env.USE_MOCK_PERSISTENCE === 'YES', 'Persisting non-string stream tokens is only supported with mock persistence.');
            return token.toString();
        } else {
            return token;
        }
    }

    function mutationsStore(txn) {
        return IndexedDbPersistence.getStore(txn, DbMutationBatch.store);
    }

    function documentMutationsStore(txn) {
        return IndexedDbPersistence.getStore(txn, DbDocumentMutation.store);
    }

    function mutationQueuesStore(txn) {
        return IndexedDbPersistence.getStore(txn, DbMutationQueue.store);
    }

    var RESERVED_BITS = 1;
    var GeneratorIds;

    (function (GeneratorIds) {
        GeneratorIds[GeneratorIds["QueryCache"] = 0] = "QueryCache";
        GeneratorIds[GeneratorIds["SyncEngine"] = 1] = "SyncEngine";
    })(GeneratorIds || (GeneratorIds = {}));

    var TargetIdGenerator = function () {
        function TargetIdGenerator(generatorId, seed) {
            this.generatorId = generatorId;
            assert((generatorId & RESERVED_BITS) === generatorId, "Generator ID " + generatorId + " contains more than " + RESERVED_BITS + " reserved bits");
            this.seek(seed !== undefined ? seed : this.generatorId);
        }

        TargetIdGenerator.prototype.next = function () {
            var nextId = this.nextId;
            this.nextId += 1 << RESERVED_BITS;
            return nextId;
        };

        TargetIdGenerator.prototype.after = function (targetId) {
            this.seek(targetId + (1 << RESERVED_BITS));
            return this.next();
        };

        TargetIdGenerator.prototype.seek = function (targetId) {
            assert((targetId & RESERVED_BITS) === this.generatorId, 'Cannot supply target ID from different generator ID');
            this.nextId = targetId;
        };

        TargetIdGenerator.forQueryCache = function () {
            var targetIdGenerator = new TargetIdGenerator(GeneratorIds.QueryCache, 2);
            return targetIdGenerator;
        };

        TargetIdGenerator.forSyncEngine = function () {
            return new TargetIdGenerator(GeneratorIds.SyncEngine);
        };

        return TargetIdGenerator;
    }();

    var LOG_TAG$1 = 'SimpleDb';

    var SimpleDb = function () {
        function SimpleDb(db) {
            this.db = db;
        }

        SimpleDb.openOrCreate = function (name, version, schemaConverter) {
            assert(SimpleDb.isAvailable(), 'IndexedDB not supported in current environment.');
            debug(LOG_TAG$1, 'Opening database:', name);
            return new PersistencePromise(function (resolve, reject) {
                var request = window.indexedDB.open(name, version);

                request.onsuccess = function (event) {
                    var db = event.target.result;
                    resolve(new SimpleDb(db));
                };

                request.onblocked = function () {
                    reject(new FirestoreError(Code.FAILED_PRECONDITION, 'Cannot upgrade IndexedDB schema while another tab is open. ' + 'Close all tabs that access Firestore and reload this page to proceed.'));
                };

                request.onerror = function (event) {
                    reject(event.target.error);
                };

                request.onupgradeneeded = function (event) {
                    debug(LOG_TAG$1, 'Database "' + name + '" requires upgrade from version:', event.oldVersion);
                    var db = event.target.result;
                    var txn = new SimpleDbTransaction(request.transaction);
                    schemaConverter.createOrUpgrade(db, txn, event.oldVersion, SCHEMA_VERSION).next(function () {
                        debug(LOG_TAG$1, 'Database upgrade to version ' + SCHEMA_VERSION + ' complete');
                    });
                };
            }).toPromise();
        };

        SimpleDb.delete = function (name) {
            debug(LOG_TAG$1, 'Removing database:', name);
            return wrapRequest(window.indexedDB.deleteDatabase(name)).toPromise();
        };

        SimpleDb.isAvailable = function () {
            if (typeof window === 'undefined' || window.indexedDB == null) {
                return false;
            }

            if (window.navigator === undefined) {
                return process.env.USE_MOCK_PERSISTENCE === 'YES';
            }

            var ua = window.navigator.userAgent;

            if (ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0) {
                return false;
            } else {
                return true;
            }
        };

        SimpleDb.getStore = function (txn, store) {
            return txn.store(store);
        };

        SimpleDb.prototype.runTransaction = function (mode, objectStores, transactionFn) {
            var transaction = SimpleDbTransaction.open(this.db, mode, objectStores);
            var transactionFnResult = transactionFn(transaction).catch(function (error$$1) {
                transaction.abort(error$$1);
            }).toPromise();
            return transaction.completionPromise.then(function () {
                return transactionFnResult;
            });
        };

        SimpleDb.prototype.close = function () {
            this.db.close();
        };

        return SimpleDb;
    }();

    var IterationController = function () {
        function IterationController(dbCursor) {
            this.dbCursor = dbCursor;
            this.shouldStop = false;
            this.nextKey = null;
        }

        Object.defineProperty(IterationController.prototype, "isDone", {
            get: function get() {
                return this.shouldStop;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IterationController.prototype, "skipToKey", {
            get: function get() {
                return this.nextKey;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IterationController.prototype, "cursor", {
            set: function set(value) {
                this.dbCursor = value;
            },
            enumerable: true,
            configurable: true
        });

        IterationController.prototype.done = function () {
            this.shouldStop = true;
        };

        IterationController.prototype.skip = function (key) {
            this.nextKey = key;
        };

        IterationController.prototype.delete = function () {
            return wrapRequest(this.dbCursor.delete());
        };

        return IterationController;
    }();

    var SimpleDbTransaction = function () {
        function SimpleDbTransaction(transaction) {
            var _this = this;

            this.transaction = transaction;
            this.aborted = false;
            this.completionDeferred = new Deferred$1();

            this.transaction.oncomplete = function () {
                _this.completionDeferred.resolve();
            };

            this.transaction.onabort = function () {
                if (transaction.error) {
                    _this.completionDeferred.reject(transaction.error);
                } else {
                    _this.completionDeferred.resolve();
                }
            };

            this.transaction.onerror = function (event) {
                _this.completionDeferred.reject(event.target.error);
            };
        }

        SimpleDbTransaction.open = function (db, mode, objectStoreNames) {
            return new SimpleDbTransaction(db.transaction(objectStoreNames, mode));
        };

        Object.defineProperty(SimpleDbTransaction.prototype, "completionPromise", {
            get: function get() {
                return this.completionDeferred.promise;
            },
            enumerable: true,
            configurable: true
        });

        SimpleDbTransaction.prototype.abort = function (error$$1) {
            if (error$$1) {
                this.completionDeferred.reject(error$$1);
            }

            if (!this.aborted) {
                debug(LOG_TAG$1, 'Aborting transaction:', error$$1 ? error$$1.message : 'Client-initiated abort');
                this.aborted = true;
                this.transaction.abort();
            }
        };

        SimpleDbTransaction.prototype.store = function (storeName) {
            var store = this.transaction.objectStore(storeName);
            assert(!!store, 'Object store not part of transaction: ' + storeName);
            return new SimpleDbStore(store);
        };

        return SimpleDbTransaction;
    }();

    var SimpleDbStore = function () {
        function SimpleDbStore(store) {
            this.store = store;
        }

        SimpleDbStore.prototype.put = function (keyOrValue, value) {
            var request;

            if (value !== undefined) {
                debug(LOG_TAG$1, 'PUT', this.store.name, keyOrValue, value);
                request = this.store.put(value, keyOrValue);
            } else {
                debug(LOG_TAG$1, 'PUT', this.store.name, '<auto-key>', keyOrValue);
                request = this.store.put(keyOrValue);
            }

            return wrapRequest(request);
        };

        SimpleDbStore.prototype.add = function (value) {
            debug(LOG_TAG$1, 'ADD', this.store.name, value, value);
            var request = this.store.add(value);
            return wrapRequest(request);
        };

        SimpleDbStore.prototype.get = function (key) {
            var _this = this;

            var request = this.store.get(key);
            return wrapRequest(request).next(function (result) {
                if (result === undefined) {
                    result = null;
                }

                debug(LOG_TAG$1, 'GET', _this.store.name, key, result);
                return result;
            });
        };

        SimpleDbStore.prototype.delete = function (key) {
            debug(LOG_TAG$1, 'DELETE', this.store.name, key);
            var request = this.store.delete(key);
            return wrapRequest(request);
        };

        SimpleDbStore.prototype.count = function () {
            debug(LOG_TAG$1, 'COUNT', this.store.name);
            var request = this.store.count();
            return wrapRequest(request);
        };

        SimpleDbStore.prototype.loadAll = function (indexOrRange, range) {
            var cursor = this.cursor(this.options(indexOrRange, range));
            var results = [];
            return this.iterateCursor(cursor, function (key, value) {
                results.push(value);
            }).next(function () {
                return results;
            });
        };

        SimpleDbStore.prototype.deleteAll = function (indexOrRange, range) {
            debug(LOG_TAG$1, 'DELETE ALL', this.store.name);
            var options = this.options(indexOrRange, range);
            options.keysOnly = false;
            var cursor = this.cursor(options);
            return this.iterateCursor(cursor, function (key, value, control) {
                return control.delete();
            });
        };

        SimpleDbStore.prototype.iterate = function (optionsOrCallback, callback) {
            var options;

            if (!callback) {
                options = {};
                callback = optionsOrCallback;
            } else {
                options = optionsOrCallback;
            }

            var cursor = this.cursor(options);
            return this.iterateCursor(cursor, callback);
        };

        SimpleDbStore.prototype.iterateSerial = function (callback) {
            var cursorRequest = this.cursor({});
            return new PersistencePromise(function (resolve, reject) {
                cursorRequest.onerror = function (event) {
                    reject(event.target.error);
                };

                cursorRequest.onsuccess = function (event) {
                    var cursor = event.target.result;

                    if (!cursor) {
                        resolve();
                        return;
                    }

                    callback(cursor.primaryKey, cursor.value).next(function (shouldContinue) {
                        if (shouldContinue) {
                            cursor.continue();
                        } else {
                            resolve();
                        }
                    });
                };
            });
        };

        SimpleDbStore.prototype.iterateCursor = function (cursorRequest, fn) {
            var results = [];
            return new PersistencePromise(function (resolve, reject) {
                cursorRequest.onerror = function (event) {
                    reject(event.target.error);
                };

                cursorRequest.onsuccess = function (event) {
                    var cursor = event.target.result;

                    if (!cursor) {
                        resolve();
                        return;
                    }

                    var controller = new IterationController(cursor);
                    var userResult = fn(cursor.primaryKey, cursor.value, controller);

                    if (userResult instanceof PersistencePromise) {
                        var userPromise = userResult.catch(function (err) {
                            controller.done();
                            return PersistencePromise.reject(err);
                        });
                        results.push(userPromise);
                    }

                    if (controller.isDone) {
                        resolve();
                    } else if (controller.skipToKey === null) {
                        cursor.continue();
                    } else {
                        cursor.continue(controller.skipToKey);
                    }
                };
            }).next(function () {
                return PersistencePromise.waitFor(results);
            });
        };

        SimpleDbStore.prototype.options = function (indexOrRange, range) {
            var indexName = undefined;

            if (indexOrRange !== undefined) {
                if (typeof indexOrRange === 'string') {
                    indexName = indexOrRange;
                } else {
                    assert(range === undefined, '3rd argument must not be defined if 2nd is a range.');
                    range = indexOrRange;
                }
            }

            return {
                index: indexName,
                range: range
            };
        };

        SimpleDbStore.prototype.cursor = function (options) {
            var direction = 'next';

            if (options.reverse) {
                direction = 'prev';
            }

            if (options.index) {
                var index = this.store.index(options.index);

                if (options.keysOnly) {
                    return index.openKeyCursor(options.range, direction);
                } else {
                    return index.openCursor(options.range, direction);
                }
            } else {
                return this.store.openCursor(options.range, direction);
            }
        };

        return SimpleDbStore;
    }();

    function wrapRequest(request) {
        return new PersistencePromise(function (resolve, reject) {
            request.onsuccess = function (event) {
                var result = event.target.result;
                resolve(result);
            };

            request.onerror = function (event) {
                reject(event.target.error);
            };
        });
    }

    var IndexedDbQueryCache = function () {
        function IndexedDbQueryCache(referenceDelegate, serializer) {
            this.referenceDelegate = referenceDelegate;
            this.serializer = serializer;
            this.targetIdGenerator = TargetIdGenerator.forQueryCache();
        }

        IndexedDbQueryCache.prototype.allocateTargetId = function (transaction) {
            var _this = this;

            return this.retrieveMetadata(transaction).next(function (metadata) {
                metadata.highestTargetId = _this.targetIdGenerator.after(metadata.highestTargetId);
                return _this.saveMetadata(transaction, metadata).next(function () {
                    return metadata.highestTargetId;
                });
            });
        };

        IndexedDbQueryCache.prototype.getLastRemoteSnapshotVersion = function (transaction) {
            return this.retrieveMetadata(transaction).next(function (metadata) {
                return SnapshotVersion.fromTimestamp(new Timestamp(metadata.lastRemoteSnapshotVersion.seconds, metadata.lastRemoteSnapshotVersion.nanoseconds));
            });
        };

        IndexedDbQueryCache.prototype.getHighestSequenceNumber = function (transaction) {
            return getHighestListenSequenceNumber(transaction.simpleDbTransaction);
        };

        IndexedDbQueryCache.prototype.setTargetsMetadata = function (transaction, highestListenSequenceNumber, lastRemoteSnapshotVersion) {
            var _this = this;

            return this.retrieveMetadata(transaction).next(function (metadata) {
                metadata.highestListenSequenceNumber = highestListenSequenceNumber;

                if (lastRemoteSnapshotVersion) {
                    metadata.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion.toTimestamp();
                }

                if (highestListenSequenceNumber > metadata.highestListenSequenceNumber) {
                    metadata.highestListenSequenceNumber = highestListenSequenceNumber;
                }

                return _this.saveMetadata(transaction, metadata);
            });
        };

        IndexedDbQueryCache.prototype.addQueryData = function (transaction, queryData) {
            var _this = this;

            return this.saveQueryData(transaction, queryData).next(function () {
                return _this.retrieveMetadata(transaction).next(function (metadata) {
                    metadata.targetCount += 1;

                    _this.updateMetadataFromQueryData(queryData, metadata);

                    return _this.saveMetadata(transaction, metadata);
                });
            });
        };

        IndexedDbQueryCache.prototype.updateQueryData = function (transaction, queryData) {
            return this.saveQueryData(transaction, queryData);
        };

        IndexedDbQueryCache.prototype.removeQueryData = function (transaction, queryData) {
            var _this = this;

            return this.removeMatchingKeysForTargetId(transaction, queryData.targetId).next(function () {
                return targetsStore(transaction).delete(queryData.targetId);
            }).next(function () {
                return _this.retrieveMetadata(transaction);
            }).next(function (metadata) {
                assert(metadata.targetCount > 0, 'Removing from an empty query cache');
                metadata.targetCount -= 1;
                return _this.saveMetadata(transaction, metadata);
            });
        };

        IndexedDbQueryCache.prototype.removeTargets = function (txn, upperBound, activeTargetIds) {
            var _this = this;

            var count = 0;
            var promises = [];
            return targetsStore(txn).iterate(function (key, value) {
                var queryData = _this.serializer.fromDbTarget(value);

                if (queryData.sequenceNumber <= upperBound && activeTargetIds[queryData.targetId] === undefined) {
                    count++;
                    promises.push(_this.removeQueryData(txn, queryData));
                }
            }).next(function () {
                return PersistencePromise.waitFor(promises);
            }).next(function () {
                return count;
            });
        };

        IndexedDbQueryCache.prototype.forEachTarget = function (txn, f) {
            var _this = this;

            return targetsStore(txn).iterate(function (key, value) {
                var queryData = _this.serializer.fromDbTarget(value);

                f(queryData);
            });
        };

        IndexedDbQueryCache.prototype.retrieveMetadata = function (transaction) {
            return retrieveMetadata(transaction.simpleDbTransaction);
        };

        IndexedDbQueryCache.prototype.saveMetadata = function (transaction, metadata) {
            return globalTargetStore(transaction).put(DbTargetGlobal.key, metadata);
        };

        IndexedDbQueryCache.prototype.saveQueryData = function (transaction, queryData) {
            return targetsStore(transaction).put(this.serializer.toDbTarget(queryData));
        };

        IndexedDbQueryCache.prototype.updateMetadataFromQueryData = function (queryData, metadata) {
            var updated = false;

            if (queryData.targetId > metadata.highestTargetId) {
                metadata.highestTargetId = queryData.targetId;
                updated = true;
            }

            if (queryData.sequenceNumber > metadata.highestListenSequenceNumber) {
                metadata.highestListenSequenceNumber = queryData.sequenceNumber;
                updated = true;
            }

            return updated;
        };

        IndexedDbQueryCache.prototype.getQueryCount = function (transaction) {
            return this.retrieveMetadata(transaction).next(function (metadata) {
                return metadata.targetCount;
            });
        };

        IndexedDbQueryCache.prototype.getQueryData = function (transaction, query) {
            var _this = this;

            var canonicalId = query.canonicalId();
            var range = IDBKeyRange.bound([canonicalId, Number.NEGATIVE_INFINITY], [canonicalId, Number.POSITIVE_INFINITY]);
            var result = null;
            return targetsStore(transaction).iterate({
                range: range,
                index: DbTarget.queryTargetsIndexName
            }, function (key, value, control) {
                var found = _this.serializer.fromDbTarget(value);

                if (query.isEqual(found.query)) {
                    result = found;
                    control.done();
                }
            }).next(function () {
                return result;
            });
        };

        IndexedDbQueryCache.prototype.addMatchingKeys = function (txn, keys, targetId) {
            var _this = this;

            var promises = [];
            var store = documentTargetStore(txn);
            keys.forEach(function (key) {
                var path = encode(key.path);
                promises.push(store.put(new DbTargetDocument(targetId, path)));
                promises.push(_this.referenceDelegate.addReference(txn, key));
            });
            return PersistencePromise.waitFor(promises);
        };

        IndexedDbQueryCache.prototype.removeMatchingKeys = function (txn, keys, targetId) {
            var _this = this;

            var store = documentTargetStore(txn);
            return PersistencePromise.forEach(keys, function (key) {
                var path = encode(key.path);
                return PersistencePromise.waitFor([store.delete([targetId, path]), _this.referenceDelegate.removeReference(txn, key)]);
            });
        };

        IndexedDbQueryCache.prototype.removeMatchingKeysForTargetId = function (txn, targetId) {
            var store = documentTargetStore(txn);
            var range = IDBKeyRange.bound([targetId], [targetId + 1], false, true);
            return store.delete(range);
        };

        IndexedDbQueryCache.prototype.getMatchingKeysForTargetId = function (txn, targetId) {
            var range = IDBKeyRange.bound([targetId], [targetId + 1], false, true);
            var store = documentTargetStore(txn);
            var result = documentKeySet();
            return store.iterate({
                range: range,
                keysOnly: true
            }, function (key, _, control) {
                var path = decode$1(key[1]);
                var docKey = new DocumentKey(path);
                result = result.add(docKey);
            }).next(function () {
                return result;
            });
        };

        IndexedDbQueryCache.prototype.containsKey = function (txn, key) {
            var path = encode(key.path);
            var range = IDBKeyRange.bound([path], [immediateSuccessor(path)], false, true);
            var count = 0;
            return documentTargetStore(txn).iterate({
                index: DbTargetDocument.documentTargetsIndex,
                keysOnly: true,
                range: range
            }, function (_a, _, control) {
                var targetId = _a[0],
                    path = _a[1];

                if (targetId !== 0) {
                    count++;
                    control.done();
                }
            }).next(function () {
                return count > 0;
            });
        };

        IndexedDbQueryCache.prototype.getQueryDataForTarget = function (transaction, targetId) {
            var _this = this;

            return targetsStore(transaction).get(targetId).next(function (found) {
                if (found) {
                    return _this.serializer.fromDbTarget(found);
                } else {
                    return null;
                }
            });
        };

        return IndexedDbQueryCache;
    }();

    function targetsStore(txn) {
        return IndexedDbPersistence.getStore(txn, DbTarget.store);
    }

    function globalTargetStore(txn) {
        return IndexedDbPersistence.getStore(txn, DbTargetGlobal.store);
    }

    function retrieveMetadata(txn) {
        var globalStore = SimpleDb.getStore(txn, DbTargetGlobal.store);
        return globalStore.get(DbTargetGlobal.key).next(function (metadata) {
            assert(metadata !== null, 'Missing metadata row.');
            return metadata;
        });
    }

    function getHighestListenSequenceNumber(txn) {
        return retrieveMetadata(txn).next(function (targetGlobal) {
            return targetGlobal.highestListenSequenceNumber;
        });
    }

    function documentTargetStore(txn) {
        return IndexedDbPersistence.getStore(txn, DbTargetDocument.store);
    }

    var REMOTE_DOCUMENT_CHANGE_MISSING_ERR_MSG = 'The remote document changelog no longer contains all changes for all ' + 'local query views. It may be necessary to rebuild these views.';

    var IndexedDbRemoteDocumentCache = function () {
        function IndexedDbRemoteDocumentCache(serializer, keepDocumentChangeLog) {
            this.serializer = serializer;
            this.keepDocumentChangeLog = keepDocumentChangeLog;
            this._lastProcessedDocumentChangeId = 0;
        }

        Object.defineProperty(IndexedDbRemoteDocumentCache.prototype, "lastProcessedDocumentChangeId", {
            get: function get() {
                return this._lastProcessedDocumentChangeId;
            },
            enumerable: true,
            configurable: true
        });

        IndexedDbRemoteDocumentCache.prototype.start = function (transaction) {
            var store = SimpleDb.getStore(transaction, DbRemoteDocumentChanges.store);
            return this.synchronizeLastDocumentChangeId(store);
        };

        IndexedDbRemoteDocumentCache.prototype.addEntries = function (transaction, maybeDocuments) {
            var promises = [];

            if (maybeDocuments.length > 0) {
                var documentStore = remoteDocumentsStore(transaction);
                var changedKeys = documentKeySet();

                for (var _i = 0, maybeDocuments_1 = maybeDocuments; _i < maybeDocuments_1.length; _i++) {
                    var maybeDocument = maybeDocuments_1[_i];
                    promises.push(documentStore.put(dbKey(maybeDocument.key), this.serializer.toDbRemoteDocument(maybeDocument)));
                    changedKeys = changedKeys.add(maybeDocument.key);
                }

                if (this.keepDocumentChangeLog) {
                    promises.push(documentChangesStore(transaction).put({
                        changes: this.serializer.toDbResourcePaths(changedKeys)
                    }));
                }
            }

            return PersistencePromise.waitFor(promises);
        };

        IndexedDbRemoteDocumentCache.prototype.removeEntry = function (transaction, documentKey) {
            return remoteDocumentsStore(transaction).delete(dbKey(documentKey));
        };

        IndexedDbRemoteDocumentCache.prototype.getEntry = function (transaction, documentKey) {
            var _this = this;

            return remoteDocumentsStore(transaction).get(dbKey(documentKey)).next(function (dbRemoteDoc) {
                return dbRemoteDoc ? _this.serializer.fromDbRemoteDocument(dbRemoteDoc) : null;
            });
        };

        IndexedDbRemoteDocumentCache.prototype.getDocumentsMatchingQuery = function (transaction, query) {
            var _this = this;

            var results = documentMap();
            var startKey = query.path.toArray();
            var range = IDBKeyRange.lowerBound(startKey);
            return remoteDocumentsStore(transaction).iterate({
                range: range
            }, function (key, dbRemoteDoc, control) {
                var maybeDoc = _this.serializer.fromDbRemoteDocument(dbRemoteDoc);

                if (!query.path.isPrefixOf(maybeDoc.key.path)) {
                    control.done();
                } else if (maybeDoc instanceof Document && query.matches(maybeDoc)) {
                    results = results.insert(maybeDoc.key, maybeDoc);
                }
            }).next(function () {
                return results;
            });
        };

        IndexedDbRemoteDocumentCache.prototype.getNewDocumentChanges = function (transaction) {
            var _this = this;

            assert(this.keepDocumentChangeLog, 'Can only call getNewDocumentChanges() when document change log is enabled');
            var changedKeys = documentKeySet();
            var changedDocs = maybeDocumentMap();
            var range = IDBKeyRange.lowerBound(this._lastProcessedDocumentChangeId + 1);
            var firstIteration = true;
            var changesStore = documentChangesStore(transaction);
            return changesStore.iterate({
                range: range
            }, function (_, documentChange) {
                if (firstIteration) {
                    firstIteration = false;

                    if (_this._lastProcessedDocumentChangeId + 1 !== documentChange.id) {
                        return _this.synchronizeLastDocumentChangeId(changesStore).next(function () {
                            return PersistencePromise.reject(new FirestoreError(Code.DATA_LOSS, REMOTE_DOCUMENT_CHANGE_MISSING_ERR_MSG));
                        });
                    }
                }

                changedKeys = changedKeys.unionWith(_this.serializer.fromDbResourcePaths(documentChange.changes));
                _this._lastProcessedDocumentChangeId = documentChange.id;
            }).next(function () {
                var documentPromises = [];
                changedKeys.forEach(function (key) {
                    documentPromises.push(_this.getEntry(transaction, key).next(function (maybeDoc) {
                        changedDocs = changedDocs.insert(key, maybeDoc || new NoDocument(key, SnapshotVersion.forDeletedDoc()));
                    }));
                });
                return PersistencePromise.waitFor(documentPromises);
            }).next(function () {
                return changedDocs;
            });
        };

        IndexedDbRemoteDocumentCache.prototype.removeDocumentChangesThroughChangeId = function (transaction, changeId) {
            var range = IDBKeyRange.upperBound(changeId);
            return documentChangesStore(transaction).delete(range);
        };

        IndexedDbRemoteDocumentCache.prototype.synchronizeLastDocumentChangeId = function (documentChangesStore) {
            var _this = this;

            this._lastProcessedDocumentChangeId = 0;
            return documentChangesStore.iterate({
                keysOnly: true,
                reverse: true
            }, function (key, value, control) {
                _this._lastProcessedDocumentChangeId = key;
                control.done();
            });
        };

        return IndexedDbRemoteDocumentCache;
    }();

    function isDocumentChangeMissingError(err) {
        return err.code === Code.DATA_LOSS && err.message === REMOTE_DOCUMENT_CHANGE_MISSING_ERR_MSG;
    }

    function remoteDocumentsStore(txn) {
        return IndexedDbPersistence.getStore(txn, DbRemoteDocument.store);
    }

    function documentChangesStore(txn) {
        return IndexedDbPersistence.getStore(txn, DbRemoteDocumentChanges.store);
    }

    function dbKey(docKey) {
        return docKey.path.toArray();
    }

    var LocalSerializer = function () {
        function LocalSerializer(remoteSerializer) {
            this.remoteSerializer = remoteSerializer;
        }

        LocalSerializer.prototype.fromDbRemoteDocument = function (remoteDoc) {
            if (remoteDoc.document) {
                return this.remoteSerializer.fromDocument(remoteDoc.document, !!remoteDoc.hasCommittedMutations);
            } else if (remoteDoc.noDocument) {
                var key = DocumentKey.fromSegments(remoteDoc.noDocument.path);
                var version = this.fromDbTimestamp(remoteDoc.noDocument.readTime);
                return new NoDocument(key, version, {
                    hasCommittedMutations: !!remoteDoc.hasCommittedMutations
                });
            } else if (remoteDoc.unknownDocument) {
                var key = DocumentKey.fromSegments(remoteDoc.unknownDocument.path);
                var version = this.fromDbTimestamp(remoteDoc.unknownDocument.version);
                return new UnknownDocument(key, version);
            } else {
                return fail('Unexpected DbRemoteDocument');
            }
        };

        LocalSerializer.prototype.toDbRemoteDocument = function (maybeDoc) {
            if (maybeDoc instanceof Document) {
                var doc = this.remoteSerializer.toDocument(maybeDoc);
                var hasCommittedMutations = maybeDoc.hasCommittedMutations;
                return new DbRemoteDocument(null, null, doc, hasCommittedMutations);
            } else if (maybeDoc instanceof NoDocument) {
                var path = maybeDoc.key.path.toArray();
                var readTime = this.toDbTimestamp(maybeDoc.version);
                var hasCommittedMutations = maybeDoc.hasCommittedMutations;
                return new DbRemoteDocument(null, new DbNoDocument(path, readTime), null, hasCommittedMutations);
            } else if (maybeDoc instanceof UnknownDocument) {
                var path = maybeDoc.key.path.toArray();
                var readTime = this.toDbTimestamp(maybeDoc.version);
                return new DbRemoteDocument(new DbUnknownDocument(path, readTime), null, null, true);
            } else {
                return fail('Unexpected MaybeDocumment');
            }
        };

        LocalSerializer.prototype.toDbTimestamp = function (snapshotVersion) {
            var timestamp = snapshotVersion.toTimestamp();
            return new DbTimestamp(timestamp.seconds, timestamp.nanoseconds);
        };

        LocalSerializer.prototype.fromDbTimestamp = function (dbTimestamp) {
            var timestamp = new Timestamp(dbTimestamp.seconds, dbTimestamp.nanoseconds);
            return SnapshotVersion.fromTimestamp(timestamp);
        };

        LocalSerializer.prototype.toDbMutationBatch = function (userId, batch) {
            var _this = this;

            var serializedMutations = batch.mutations.map(function (m) {
                return _this.remoteSerializer.toMutation(m);
            });
            return new DbMutationBatch(userId, batch.batchId, batch.localWriteTime.toMillis(), serializedMutations);
        };

        LocalSerializer.prototype.fromDbMutationBatch = function (dbBatch) {
            var _this = this;

            var mutations = dbBatch.mutations.map(function (m) {
                return _this.remoteSerializer.fromMutation(m);
            });
            var timestamp = Timestamp.fromMillis(dbBatch.localWriteTimeMs);
            return new MutationBatch(dbBatch.batchId, timestamp, mutations);
        };

        LocalSerializer.prototype.toDbResourcePaths = function (keys) {
            var encodedKeys = [];
            keys.forEach(function (key) {
                encodedKeys.push(encode(key.path));
            });
            return encodedKeys;
        };

        LocalSerializer.prototype.fromDbResourcePaths = function (encodedPaths) {
            var keys = documentKeySet();

            for (var _i = 0, encodedPaths_1 = encodedPaths; _i < encodedPaths_1.length; _i++) {
                var documentKey = encodedPaths_1[_i];
                keys = keys.add(new DocumentKey(decode$1(documentKey)));
            }

            return keys;
        };

        LocalSerializer.prototype.fromDbTarget = function (dbTarget) {
            var version = this.fromDbTimestamp(dbTarget.readTime);
            var query;

            if (isDocumentQuery(dbTarget.query)) {
                query = this.remoteSerializer.fromDocumentsTarget(dbTarget.query);
            } else {
                query = this.remoteSerializer.fromQueryTarget(dbTarget.query);
            }

            return new QueryData(query, dbTarget.targetId, QueryPurpose.Listen, dbTarget.lastListenSequenceNumber, version, dbTarget.resumeToken);
        };

        LocalSerializer.prototype.toDbTarget = function (queryData) {
            assert(QueryPurpose.Listen === queryData.purpose, 'Only queries with purpose ' + QueryPurpose.Listen + ' may be stored, got ' + queryData.purpose);
            var dbTimestamp = this.toDbTimestamp(queryData.snapshotVersion);
            var queryProto;

            if (queryData.query.isDocumentQuery()) {
                queryProto = this.remoteSerializer.toDocumentsTarget(queryData.query);
            } else {
                queryProto = this.remoteSerializer.toQueryTarget(queryData.query);
            }

            var resumeToken;

            if (queryData.resumeToken instanceof Uint8Array) {
                assert(process.env.USE_MOCK_PERSISTENCE === 'YES', 'Persisting non-string stream tokens is only supported with mock persistence .');
                resumeToken = queryData.resumeToken.toString();
            } else {
                resumeToken = queryData.resumeToken;
            }

            return new DbTarget(queryData.targetId, queryData.query.canonicalId(), dbTimestamp, resumeToken, queryData.sequenceNumber, queryProto);
        };

        return LocalSerializer;
    }();

    function isDocumentQuery(dbQuery) {
        return dbQuery.documents !== undefined;
    }

    function bufferEntryComparator(_a, _b) {
        var aSequence = _a[0],
            aIndex = _a[1];
        var bSequence = _b[0],
            bIndex = _b[1];
        var seqCmp = primitiveComparator(aSequence, bSequence);

        if (seqCmp === 0) {
            return primitiveComparator(aIndex, bIndex);
        } else {
            return seqCmp;
        }
    }

    var RollingSequenceNumberBuffer = function () {
        function RollingSequenceNumberBuffer(maxElements) {
            this.maxElements = maxElements;
            this.buffer = new SortedSet(bufferEntryComparator);
            this.previousIndex = 0;
        }

        RollingSequenceNumberBuffer.prototype.nextIndex = function () {
            return ++this.previousIndex;
        };

        RollingSequenceNumberBuffer.prototype.addElement = function (sequenceNumber) {
            var entry = [sequenceNumber, this.nextIndex()];

            if (this.buffer.size < this.maxElements) {
                this.buffer = this.buffer.add(entry);
            } else {
                var highestValue = this.buffer.last();

                if (bufferEntryComparator(entry, highestValue) < 0) {
                    this.buffer = this.buffer.delete(highestValue).add(entry);
                }
            }
        };

        Object.defineProperty(RollingSequenceNumberBuffer.prototype, "maxValue", {
            get: function get() {
                return this.buffer.last()[0];
            },
            enumerable: true,
            configurable: true
        });
        return RollingSequenceNumberBuffer;
    }();

    var LruGarbageCollector = function () {
        function LruGarbageCollector(delegate) {
            this.delegate = delegate;
        }

        LruGarbageCollector.prototype.calculateTargetCount = function (txn, percentile) {
            return this.delegate.getTargetCount(txn).next(function (targetCount) {
                return Math.floor(percentile / 100.0 * targetCount);
            });
        };

        LruGarbageCollector.prototype.nthSequenceNumber = function (txn, n) {
            var _this = this;

            if (n === 0) {
                return PersistencePromise.resolve(ListenSequence.INVALID);
            }

            var buffer = new RollingSequenceNumberBuffer(n);
            return this.delegate.forEachTarget(txn, function (target) {
                return buffer.addElement(target.sequenceNumber);
            }).next(function () {
                return _this.delegate.forEachOrphanedDocumentSequenceNumber(txn, function (sequenceNumber) {
                    return buffer.addElement(sequenceNumber);
                });
            }).next(function () {
                return buffer.maxValue;
            });
        };

        LruGarbageCollector.prototype.removeTargets = function (txn, upperBound, activeTargetIds) {
            return this.delegate.removeTargets(txn, upperBound, activeTargetIds);
        };

        LruGarbageCollector.prototype.removeOrphanedDocuments = function (txn, upperBound) {
            return this.delegate.removeOrphanedDocuments(txn, upperBound);
        };

        return LruGarbageCollector;
    }();

    var PersistenceTransaction = function () {
        function PersistenceTransaction() {}

        return PersistenceTransaction;
    }();

    var LOG_TAG$2 = 'IndexedDbPersistence';
    var MAX_CLIENT_AGE_MS = 30 * 60 * 1000;
    var MAX_PRIMARY_ELIGIBLE_AGE_MS = 5000;
    var CLIENT_METADATA_REFRESH_INTERVAL_MS = 4000;
    var PRIMARY_LEASE_LOST_ERROR_MSG = 'The current tab is not in the required state to perform this operation. ' + 'It might be necessary to refresh the browser tab.';
    var PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG = 'Another tab has exclusive access to the persistence layer. ' + 'To allow shared access, make sure to invoke ' + '`enablePersistence()` with `experimentalTabSynchronization:true` in all tabs.';
    var UNSUPPORTED_PLATFORM_ERROR_MSG = 'This platform is either missing' + ' IndexedDB or is known to have an incomplete implementation. Offline' + ' persistence has been disabled.';
    var ZOMBIED_CLIENTS_KEY_PREFIX = 'firestore_zombie';

    var IndexedDbTransaction = function (_super) {
        tslib_1.__extends(IndexedDbTransaction, _super);

        function IndexedDbTransaction(simpleDbTransaction, currentSequenceNumber) {
            var _this = _super.call(this) || this;

            _this.simpleDbTransaction = simpleDbTransaction;
            _this.currentSequenceNumber = currentSequenceNumber;
            return _this;
        }

        return IndexedDbTransaction;
    }(PersistenceTransaction);

    var IndexedDbPersistence = function () {
        function IndexedDbPersistence(persistenceKey, clientId, platform, queue, serializer, multiClientParams) {
            this.persistenceKey = persistenceKey;
            this.clientId = clientId;
            this.queue = queue;
            this.multiClientParams = multiClientParams;
            this._started = false;
            this.isPrimary = false;
            this.networkEnabled = true;
            this.inForeground = false;
            this.lastGarbageCollectionTime = Number.NEGATIVE_INFINITY;

            this.primaryStateListener = function (_) {
                return Promise.resolve();
            };

            if (!IndexedDbPersistence.isAvailable()) {
                throw new FirestoreError(Code.UNIMPLEMENTED, UNSUPPORTED_PLATFORM_ERROR_MSG);
            }

            this.referenceDelegate = new IndexedDbLruDelegate(this);
            this.dbName = persistenceKey + IndexedDbPersistence.MAIN_DATABASE;
            this.serializer = new LocalSerializer(serializer);
            this.document = platform.document;
            this.allowTabSynchronization = multiClientParams !== undefined;
            this.queryCache = new IndexedDbQueryCache(this.referenceDelegate, this.serializer);
            this.remoteDocumentCache = new IndexedDbRemoteDocumentCache(this.serializer, this.allowTabSynchronization);

            if (platform.window && platform.window.localStorage) {
                this.window = platform.window;
                this.webStorage = this.window.localStorage;
            } else {
                throw new FirestoreError(Code.UNIMPLEMENTED, 'IndexedDB persistence is only available on platforms that support LocalStorage.');
            }
        }

        IndexedDbPersistence.getStore = function (txn, store) {
            if (txn instanceof IndexedDbTransaction) {
                return SimpleDb.getStore(txn.simpleDbTransaction, store);
            } else {
                throw fail('IndexedDbPersistence must use instances of IndexedDbTransaction');
            }
        };

        IndexedDbPersistence.createIndexedDbPersistence = function (persistenceKey, clientId, platform, queue, serializer) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var persistence;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            persistence = new IndexedDbPersistence(persistenceKey, clientId, platform, queue, serializer);
                            return [4, persistence.start()];

                        case 1:
                            _a.sent();

                            return [2, persistence];
                    }
                });
            });
        };

        IndexedDbPersistence.createMultiClientIndexedDbPersistence = function (persistenceKey, clientId, platform, queue, serializer, multiClientParams) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var persistence;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            persistence = new IndexedDbPersistence(persistenceKey, clientId, platform, queue, serializer, multiClientParams);
                            return [4, persistence.start()];

                        case 1:
                            _a.sent();

                            return [2, persistence];
                    }
                });
            });
        };

        IndexedDbPersistence.prototype.start = function () {
            var _this = this;

            assert(!this.started, 'IndexedDbPersistence double-started!');
            assert(this.window !== null, "Expected 'window' to be defined");
            return SimpleDb.openOrCreate(this.dbName, SCHEMA_VERSION, new SchemaConverter(this.serializer)).then(function (db) {
                _this.simpleDb = db;
            }).then(function () {
                return _this.startRemoteDocumentCache();
            }).then(function () {
                _this.attachVisibilityHandler();

                _this.attachWindowUnloadHook();

                return _this.updateClientMetadataAndTryBecomePrimary().then(function () {
                    return _this.scheduleClientMetadataAndPrimaryLeaseRefreshes();
                });
            }).then(function () {
                return _this.simpleDb.runTransaction('readonly', [DbTargetGlobal.store], function (txn) {
                    return getHighestListenSequenceNumber(txn).next(function (highestListenSequenceNumber) {
                        var sequenceNumberSyncer = _this.multiClientParams ? _this.multiClientParams.sequenceNumberSyncer : undefined;
                        _this.listenSequence = new ListenSequence(highestListenSequenceNumber, sequenceNumberSyncer);
                    });
                });
            }).then(function () {
                _this._started = true;
            }).catch(function (reason) {
                _this.simpleDb && _this.simpleDb.close();
                return Promise.reject(reason);
            });
        };

        IndexedDbPersistence.prototype.startRemoteDocumentCache = function () {
            var _this = this;

            return this.simpleDb.runTransaction('readonly', ALL_STORES, function (txn) {
                return _this.remoteDocumentCache.start(txn);
            });
        };

        IndexedDbPersistence.prototype.setPrimaryStateListener = function (primaryStateListener) {
            var _this = this;

            this.primaryStateListener = function (primaryState) {
                return tslib_1.__awaiter(_this, void 0, void 0, function () {
                    return tslib_1.__generator(this, function (_a) {
                        if (this.started) {
                            return [2, primaryStateListener(primaryState)];
                        }

                        return [2];
                    });
                });
            };

            return primaryStateListener(this.isPrimary);
        };

        IndexedDbPersistence.prototype.setNetworkEnabled = function (networkEnabled) {
            var _this = this;

            if (this.networkEnabled !== networkEnabled) {
                this.networkEnabled = networkEnabled;
                this.queue.enqueueAndForget(function () {
                    return tslib_1.__awaiter(_this, void 0, void 0, function () {
                        return tslib_1.__generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!this.started) return [3, 2];
                                    return [4, this.updateClientMetadataAndTryBecomePrimary()];

                                case 1:
                                    _a.sent();

                                    _a.label = 2;

                                case 2:
                                    return [2];
                            }
                        });
                    });
                });
            }
        };

        IndexedDbPersistence.prototype.updateClientMetadataAndTryBecomePrimary = function () {
            var _this = this;

            return this.simpleDb.runTransaction('readwrite', ALL_STORES, function (txn) {
                var metadataStore = clientMetadataStore(txn);
                return metadataStore.put(new DbClientMetadata(_this.clientId, Date.now(), _this.networkEnabled, _this.inForeground, _this.remoteDocumentCache.lastProcessedDocumentChangeId)).next(function () {
                    if (_this.isPrimary) {
                        return _this.verifyPrimaryLease(txn).next(function (success) {
                            if (!success) {
                                _this.isPrimary = false;

                                _this.queue.enqueueAndForget(function () {
                                    return _this.primaryStateListener(false);
                                });
                            }
                        });
                    }
                }).next(function () {
                    return _this.canActAsPrimary(txn);
                }).next(function (canActAsPrimary) {
                    var wasPrimary = _this.isPrimary;
                    _this.isPrimary = canActAsPrimary;

                    if (wasPrimary !== _this.isPrimary) {
                        _this.queue.enqueueAndForget(function () {
                            return _this.primaryStateListener(_this.isPrimary);
                        });
                    }

                    if (wasPrimary && !_this.isPrimary) {
                        return _this.releasePrimaryLeaseIfHeld(txn);
                    } else if (_this.isPrimary) {
                        return _this.acquireOrExtendPrimaryLease(txn);
                    }
                });
            });
        };

        IndexedDbPersistence.prototype.verifyPrimaryLease = function (txn) {
            var _this = this;

            var store = primaryClientStore(txn);
            return store.get(DbPrimaryClient.key).next(function (primaryClient) {
                return PersistencePromise.resolve(_this.isLocalClient(primaryClient));
            });
        };

        IndexedDbPersistence.prototype.removeClientMetadata = function (txn) {
            var metadataStore = clientMetadataStore(txn);
            return metadataStore.delete(this.clientId);
        };

        IndexedDbPersistence.prototype.maybeGarbageCollectMultiClientState = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var _this = this;

                var activeClients_1, inactiveClients_1;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!(this.isPrimary && !this.isWithinAge(this.lastGarbageCollectionTime, MAX_CLIENT_AGE_MS))) return [3, 2];
                            this.lastGarbageCollectionTime = Date.now();
                            inactiveClients_1 = [];
                            return [4, this.runTransaction('maybeGarbageCollectMultiClientState', 'readwrite-primary', function (txn) {
                                var metadataStore = IndexedDbPersistence.getStore(txn, DbClientMetadata.store);
                                return metadataStore.loadAll().next(function (existingClients) {
                                    activeClients_1 = _this.filterActiveClients(existingClients, MAX_CLIENT_AGE_MS);
                                    inactiveClients_1 = existingClients.filter(function (client) {
                                        return activeClients_1.indexOf(client) === -1;
                                    });
                                }).next(function () {
                                    return PersistencePromise.forEach(inactiveClients_1, function (inactiveClient) {
                                        return metadataStore.delete(inactiveClient.clientId);
                                    });
                                }).next(function () {
                                    activeClients_1 = activeClients_1.filter(function (client) {
                                        return client.clientId !== _this.clientId;
                                    });

                                    if (activeClients_1.length > 0) {
                                        var processedChangeIds = activeClients_1.map(function (client) {
                                            return client.lastProcessedDocumentChangeId || 0;
                                        });
                                        var oldestChangeId = Math.min.apply(Math, processedChangeIds);
                                        return _this.remoteDocumentCache.removeDocumentChangesThroughChangeId(txn, oldestChangeId);
                                    }
                                });
                            })];

                        case 1:
                            _a.sent();

                            inactiveClients_1.forEach(function (inactiveClient) {
                                _this.window.localStorage.removeItem(_this.zombiedClientLocalStorageKey(inactiveClient.clientId));
                            });
                            _a.label = 2;

                        case 2:
                            return [2];
                    }
                });
            });
        };

        IndexedDbPersistence.prototype.scheduleClientMetadataAndPrimaryLeaseRefreshes = function () {
            var _this = this;

            this.clientMetadataRefresher = this.queue.enqueueAfterDelay(TimerId.ClientMetadataRefresh, CLIENT_METADATA_REFRESH_INTERVAL_MS, function () {
                return _this.updateClientMetadataAndTryBecomePrimary().then(function () {
                    return _this.maybeGarbageCollectMultiClientState();
                }).then(function () {
                    return _this.scheduleClientMetadataAndPrimaryLeaseRefreshes();
                });
            });
        };

        IndexedDbPersistence.prototype.isLocalClient = function (client) {
            return client ? client.ownerId === this.clientId : false;
        };

        IndexedDbPersistence.prototype.canActAsPrimary = function (txn) {
            var _this = this;

            var store = primaryClientStore(txn);
            return store.get(DbPrimaryClient.key).next(function (currentPrimary) {
                var currentLeaseIsValid = currentPrimary !== null && _this.isWithinAge(currentPrimary.leaseTimestampMs, MAX_PRIMARY_ELIGIBLE_AGE_MS) && !_this.isClientZombied(currentPrimary.ownerId);

                if (currentLeaseIsValid) {
                    if (_this.isLocalClient(currentPrimary) && _this.networkEnabled) {
                        return true;
                    }

                    if (!_this.isLocalClient(currentPrimary)) {
                        if (!currentPrimary.allowTabSynchronization) {
                            throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);
                        }

                        return false;
                    }
                }

                if (_this.networkEnabled && _this.inForeground) {
                    return true;
                }

                return clientMetadataStore(txn).loadAll().next(function (existingClients) {
                    var preferredCandidate = _this.filterActiveClients(existingClients, MAX_PRIMARY_ELIGIBLE_AGE_MS).find(function (otherClient) {
                        if (_this.clientId !== otherClient.clientId) {
                            var otherClientHasBetterNetworkState = !_this.networkEnabled && otherClient.networkEnabled;
                            var otherClientHasBetterVisibility = !_this.inForeground && otherClient.inForeground;
                            var otherClientHasSameNetworkState = _this.networkEnabled === otherClient.networkEnabled;

                            if (otherClientHasBetterNetworkState || otherClientHasBetterVisibility && otherClientHasSameNetworkState) {
                                return true;
                            }
                        }

                        return false;
                    });

                    return preferredCandidate === undefined;
                });
            }).next(function (canActAsPrimary) {
                if (_this.isPrimary !== canActAsPrimary) {
                    debug(LOG_TAG$2, "Client " + (canActAsPrimary ? 'is' : 'is not') + " eligible for a primary lease.");
                }

                return canActAsPrimary;
            });
        };

        IndexedDbPersistence.prototype.shutdown = function (deleteData) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var _this = this;

                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this._started = false;
                            this.markClientZombied();

                            if (this.clientMetadataRefresher) {
                                this.clientMetadataRefresher.cancel();
                            }

                            this.detachVisibilityHandler();
                            this.detachWindowUnloadHook();
                            return [4, this.simpleDb.runTransaction('readwrite', [DbPrimaryClient.store, DbClientMetadata.store], function (txn) {
                                return _this.releasePrimaryLeaseIfHeld(txn).next(function () {
                                    return _this.removeClientMetadata(txn);
                                });
                            })];

                        case 1:
                            _a.sent();

                            this.simpleDb.close();
                            this.removeClientZombiedEntry();
                            if (!deleteData) return [3, 3];
                            return [4, SimpleDb.delete(this.dbName)];

                        case 2:
                            _a.sent();

                            _a.label = 3;

                        case 3:
                            return [2];
                    }
                });
            });
        };

        IndexedDbPersistence.prototype.filterActiveClients = function (clients, activityThresholdMs) {
            var _this = this;

            return clients.filter(function (client) {
                return _this.isWithinAge(client.updateTimeMs, activityThresholdMs) && !_this.isClientZombied(client.clientId);
            });
        };

        IndexedDbPersistence.prototype.getActiveClients = function () {
            var _this = this;

            return this.simpleDb.runTransaction('readonly', [DbClientMetadata.store], function (txn) {
                return clientMetadataStore(txn).loadAll().next(function (clients) {
                    return _this.filterActiveClients(clients, MAX_CLIENT_AGE_MS).map(function (clientMetadata) {
                        return clientMetadata.clientId;
                    });
                });
            });
        };

        Object.defineProperty(IndexedDbPersistence.prototype, "started", {
            get: function get() {
                return this._started;
            },
            enumerable: true,
            configurable: true
        });

        IndexedDbPersistence.prototype.getMutationQueue = function (user) {
            assert(this.started, 'Cannot initialize MutationQueue before persistence is started.');
            return IndexedDbMutationQueue.forUser(user, this.serializer, this.referenceDelegate);
        };

        IndexedDbPersistence.prototype.getQueryCache = function () {
            assert(this.started, 'Cannot initialize QueryCache before persistence is started.');
            return this.queryCache;
        };

        IndexedDbPersistence.prototype.getRemoteDocumentCache = function () {
            assert(this.started, 'Cannot initialize RemoteDocumentCache before persistence is started.');
            return this.remoteDocumentCache;
        };

        IndexedDbPersistence.prototype.runTransaction = function (action, mode, transactionOperation) {
            var _this = this;

            debug(LOG_TAG$2, 'Starting transaction:', action);
            return this.simpleDb.runTransaction(mode === 'readonly' ? 'readonly' : 'readwrite', ALL_STORES, function (simpleDbTxn) {
                if (mode === 'readwrite-primary') {
                    return _this.verifyPrimaryLease(simpleDbTxn).next(function (success) {
                        if (!success) {
                            error("Failed to obtain primary lease for action '" + action + "'.");
                            _this.isPrimary = false;

                            _this.queue.enqueueAndForget(function () {
                                return _this.primaryStateListener(false);
                            });

                            throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_LOST_ERROR_MSG);
                        }

                        return transactionOperation(new IndexedDbTransaction(simpleDbTxn, _this.listenSequence.next()));
                    }).next(function (result) {
                        return _this.acquireOrExtendPrimaryLease(simpleDbTxn).next(function () {
                            return result;
                        });
                    });
                } else {
                    return _this.verifyAllowTabSynchronization(simpleDbTxn).next(function () {
                        return transactionOperation(new IndexedDbTransaction(simpleDbTxn, _this.listenSequence.next()));
                    });
                }
            });
        };

        IndexedDbPersistence.prototype.verifyAllowTabSynchronization = function (txn) {
            var _this = this;

            var store = primaryClientStore(txn);
            return store.get(DbPrimaryClient.key).next(function (currentPrimary) {
                var currentLeaseIsValid = currentPrimary !== null && _this.isWithinAge(currentPrimary.leaseTimestampMs, MAX_PRIMARY_ELIGIBLE_AGE_MS) && !_this.isClientZombied(currentPrimary.ownerId);

                if (currentLeaseIsValid && !_this.isLocalClient(currentPrimary)) {
                    if (!currentPrimary.allowTabSynchronization) {
                        throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);
                    }
                }
            });
        };

        IndexedDbPersistence.prototype.acquireOrExtendPrimaryLease = function (txn) {
            var newPrimary = new DbPrimaryClient(this.clientId, this.allowTabSynchronization, Date.now());
            return primaryClientStore(txn).put(DbPrimaryClient.key, newPrimary);
        };

        IndexedDbPersistence.isAvailable = function () {
            return SimpleDb.isAvailable();
        };

        IndexedDbPersistence.buildStoragePrefix = function (databaseInfo) {
            var database = databaseInfo.databaseId.projectId;

            if (!databaseInfo.databaseId.isDefaultDatabase) {
                database += '.' + databaseInfo.databaseId.database;
            }

            return 'firestore/' + databaseInfo.persistenceKey + '/' + database + '/';
        };

        IndexedDbPersistence.prototype.releasePrimaryLeaseIfHeld = function (txn) {
            var _this = this;

            var store = primaryClientStore(txn);
            return store.get(DbPrimaryClient.key).next(function (primaryClient) {
                if (_this.isLocalClient(primaryClient)) {
                    debug(LOG_TAG$2, 'Releasing primary lease.');
                    return store.delete(DbPrimaryClient.key);
                } else {
                    return PersistencePromise.resolve();
                }
            });
        };

        IndexedDbPersistence.prototype.isWithinAge = function (updateTimeMs, maxAgeMs) {
            var now = Date.now();
            var minAcceptable = now - maxAgeMs;
            var maxAcceptable = now;

            if (updateTimeMs < minAcceptable) {
                return false;
            } else if (updateTimeMs > maxAcceptable) {
                error("Detected an update time that is in the future: " + updateTimeMs + " > " + maxAcceptable);
                return false;
            }

            return true;
        };

        IndexedDbPersistence.prototype.attachVisibilityHandler = function () {
            var _this = this;

            if (this.document !== null && typeof this.document.addEventListener === 'function') {
                this.documentVisibilityHandler = function () {
                    _this.queue.enqueueAndForget(function () {
                        _this.inForeground = _this.document.visibilityState === 'visible';
                        return _this.updateClientMetadataAndTryBecomePrimary();
                    });
                };

                this.document.addEventListener('visibilitychange', this.documentVisibilityHandler);
                this.inForeground = this.document.visibilityState === 'visible';
            }
        };

        IndexedDbPersistence.prototype.detachVisibilityHandler = function () {
            if (this.documentVisibilityHandler) {
                assert(this.document !== null && typeof this.document.addEventListener === 'function', "Expected 'document.addEventListener' to be a function");
                this.document.removeEventListener('visibilitychange', this.documentVisibilityHandler);
                this.documentVisibilityHandler = null;
            }
        };

        IndexedDbPersistence.prototype.attachWindowUnloadHook = function () {
            var _this = this;

            if (typeof this.window.addEventListener === 'function') {
                this.windowUnloadHandler = function () {
                    _this.markClientZombied();

                    _this.queue.enqueueAndForget(function () {
                        return _this.shutdown();
                    });
                };

                this.window.addEventListener('unload', this.windowUnloadHandler);
            }
        };

        IndexedDbPersistence.prototype.detachWindowUnloadHook = function () {
            if (this.windowUnloadHandler) {
                assert(typeof this.window.removeEventListener === 'function', "Expected 'window.removeEventListener' to be a function");
                this.window.removeEventListener('unload', this.windowUnloadHandler);
                this.windowUnloadHandler = null;
            }
        };

        IndexedDbPersistence.prototype.isClientZombied = function (clientId) {
            try {
                var isZombied = this.webStorage.getItem(this.zombiedClientLocalStorageKey(clientId)) !== null;
                debug(LOG_TAG$2, "Client '" + clientId + "' " + (isZombied ? 'is' : 'is not') + " zombied in LocalStorage");
                return isZombied;
            } catch (e) {
                error(LOG_TAG$2, 'Failed to get zombied client id.', e);
                return false;
            }
        };

        IndexedDbPersistence.prototype.markClientZombied = function () {
            try {
                this.webStorage.setItem(this.zombiedClientLocalStorageKey(this.clientId), String(Date.now()));
            } catch (e) {
                error('Failed to set zombie client id.', e);
            }
        };

        IndexedDbPersistence.prototype.removeClientZombiedEntry = function () {
            try {
                this.webStorage.removeItem(this.zombiedClientLocalStorageKey(this.clientId));
            } catch (e) {}
        };

        IndexedDbPersistence.prototype.zombiedClientLocalStorageKey = function (clientId) {
            return ZOMBIED_CLIENTS_KEY_PREFIX + "_" + this.persistenceKey + "_" + clientId;
        };

        IndexedDbPersistence.MAIN_DATABASE = 'main';
        return IndexedDbPersistence;
    }();

    function isPrimaryLeaseLostError(err) {
        return err.code === Code.FAILED_PRECONDITION && err.message === PRIMARY_LEASE_LOST_ERROR_MSG;
    }

    function primaryClientStore(txn) {
        return txn.store(DbPrimaryClient.store);
    }

    function clientMetadataStore(txn) {
        return txn.store(DbClientMetadata.store);
    }

    var IndexedDbLruDelegate = function () {
        function IndexedDbLruDelegate(db) {
            this.db = db;
            this.garbageCollector = new LruGarbageCollector(this);
        }

        IndexedDbLruDelegate.prototype.getTargetCount = function (txn) {
            return this.db.getQueryCache().getQueryCount(txn);
        };

        IndexedDbLruDelegate.prototype.forEachTarget = function (txn, f) {
            return this.db.getQueryCache().forEachTarget(txn, f);
        };

        IndexedDbLruDelegate.prototype.forEachOrphanedDocumentSequenceNumber = function (txn, f) {
            return this.forEachOrphanedDocument(txn, function (docKey, sequenceNumber) {
                return f(sequenceNumber);
            });
        };

        IndexedDbLruDelegate.prototype.setInMemoryPins = function (inMemoryPins) {
            this.inMemoryPins = inMemoryPins;
        };

        IndexedDbLruDelegate.prototype.addReference = function (txn, key) {
            return writeSentinelKey(txn, key);
        };

        IndexedDbLruDelegate.prototype.removeReference = function (txn, key) {
            return writeSentinelKey(txn, key);
        };

        IndexedDbLruDelegate.prototype.removeTargets = function (txn, upperBound, activeTargetIds) {
            return this.db.getQueryCache().removeTargets(txn, upperBound, activeTargetIds);
        };

        IndexedDbLruDelegate.prototype.removeMutationReference = function (txn, key) {
            return writeSentinelKey(txn, key);
        };

        IndexedDbLruDelegate.prototype.isPinned = function (txn, docKey) {
            if (this.inMemoryPins.containsKey(docKey)) {
                return PersistencePromise.resolve(true);
            } else {
                return mutationQueuesContainKey(txn, docKey);
            }
        };

        IndexedDbLruDelegate.prototype.removeOrphanedDocuments = function (txn, upperBound) {
            var _this = this;

            var count = 0;
            var promises = [];
            var iteration = this.forEachOrphanedDocument(txn, function (docKey, sequenceNumber) {
                if (sequenceNumber <= upperBound) {
                    var p = _this.isPinned(txn, docKey).next(function (isPinned) {
                        if (!isPinned) {
                            count++;
                            return _this.removeOrphanedDocument(txn, docKey);
                        }
                    });

                    promises.push(p);
                }
            });
            return iteration.next(function () {
                return PersistencePromise.waitFor(promises);
            }).next(function () {
                return count;
            });
        };

        IndexedDbLruDelegate.prototype.removeOrphanedDocument = function (txn, docKey) {
            return PersistencePromise.waitFor([documentTargetStore(txn).delete(sentinelKey(docKey)), this.db.getRemoteDocumentCache().removeEntry(txn, docKey)]);
        };

        IndexedDbLruDelegate.prototype.removeTarget = function (txn, queryData) {
            var updated = queryData.copy({
                sequenceNumber: txn.currentSequenceNumber
            });
            return this.db.getQueryCache().updateQueryData(txn, updated);
        };

        IndexedDbLruDelegate.prototype.updateLimboDocument = function (txn, key) {
            return writeSentinelKey(txn, key);
        };

        IndexedDbLruDelegate.prototype.forEachOrphanedDocument = function (txn, f) {
            var store = documentTargetStore(txn);
            var nextToReport = ListenSequence.INVALID;
            var nextPath;
            return store.iterate({
                index: DbTargetDocument.documentTargetsIndex
            }, function (_a, _b) {
                var targetId = _a[0],
                    docKey = _a[1];
                var path = _b.path,
                    sequenceNumber = _b.sequenceNumber;

                if (targetId === 0) {
                    if (nextToReport !== ListenSequence.INVALID) {
                        f(new DocumentKey(decode$1(nextPath)), nextToReport);
                    }

                    nextToReport = sequenceNumber;
                    nextPath = path;
                } else {
                    nextToReport = ListenSequence.INVALID;
                }
            }).next(function () {
                if (nextToReport !== ListenSequence.INVALID) {
                    f(new DocumentKey(decode$1(nextPath)), nextToReport);
                }
            });
        };

        return IndexedDbLruDelegate;
    }();

    function sentinelKey(key) {
        return [0, encode(key.path)];
    }

    function sentinelRow(key, sequenceNumber) {
        return new DbTargetDocument(0, encode(key.path), sequenceNumber);
    }

    function writeSentinelKey(txn, key) {
        return documentTargetStore(txn).put(sentinelRow(key, txn.currentSequenceNumber));
    }

    var LocalDocumentsView = function () {
        function LocalDocumentsView(remoteDocumentCache, mutationQueue) {
            this.remoteDocumentCache = remoteDocumentCache;
            this.mutationQueue = mutationQueue;
        }

        LocalDocumentsView.prototype.getDocument = function (transaction, key) {
            var _this = this;

            return this.mutationQueue.getAllMutationBatchesAffectingDocumentKey(transaction, key).next(function (batches) {
                return _this.getDocumentInternal(transaction, key, batches);
            });
        };

        LocalDocumentsView.prototype.getDocumentInternal = function (transaction, key, inBatches) {
            return this.remoteDocumentCache.getEntry(transaction, key).next(function (doc) {
                for (var _i = 0, inBatches_1 = inBatches; _i < inBatches_1.length; _i++) {
                    var batch = inBatches_1[_i];
                    doc = batch.applyToLocalView(key, doc);
                }

                return doc;
            });
        };

        LocalDocumentsView.prototype.getDocuments = function (transaction, keys) {
            var _this = this;

            return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(transaction, keys).next(function (batches) {
                var promises = [];
                var results = maybeDocumentMap();
                keys.forEach(function (key) {
                    promises.push(_this.getDocumentInternal(transaction, key, batches).next(function (maybeDoc) {
                        if (!maybeDoc) {
                            maybeDoc = new NoDocument(key, SnapshotVersion.forDeletedDoc());
                        }

                        results = results.insert(key, maybeDoc);
                    }));
                });
                return PersistencePromise.waitFor(promises).next(function () {
                    return results;
                });
            });
        };

        LocalDocumentsView.prototype.getDocumentsMatchingQuery = function (transaction, query) {
            if (DocumentKey.isDocumentKey(query.path)) {
                return this.getDocumentsMatchingDocumentQuery(transaction, query.path);
            } else {
                return this.getDocumentsMatchingCollectionQuery(transaction, query);
            }
        };

        LocalDocumentsView.prototype.getDocumentsMatchingDocumentQuery = function (transaction, docPath) {
            return this.getDocument(transaction, new DocumentKey(docPath)).next(function (maybeDoc) {
                var result = documentMap();

                if (maybeDoc instanceof Document) {
                    result = result.insert(maybeDoc.key, maybeDoc);
                }

                return result;
            });
        };

        LocalDocumentsView.prototype.getDocumentsMatchingCollectionQuery = function (transaction, query) {
            var _this = this;

            var results;
            return this.remoteDocumentCache.getDocumentsMatchingQuery(transaction, query).next(function (queryResults) {
                results = queryResults;
                return _this.mutationQueue.getAllMutationBatchesAffectingQuery(transaction, query);
            }).next(function (matchingMutationBatches) {
                for (var _i = 0, matchingMutationBatches_1 = matchingMutationBatches; _i < matchingMutationBatches_1.length; _i++) {
                    var batch = matchingMutationBatches_1[_i];

                    for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {
                        var mutation = _b[_a];
                        var key = mutation.key;

                        if (!query.path.isImmediateParentOf(key.path)) {
                            continue;
                        }

                        var baseDoc = results.get(key);
                        var mutatedDoc = mutation.applyToLocalView(baseDoc, baseDoc, batch.localWriteTime);

                        if (mutatedDoc instanceof Document) {
                            results = results.insert(key, mutatedDoc);
                        } else {
                            results = results.remove(key);
                        }
                    }
                }
            }).next(function () {
                results.forEach(function (key, doc) {
                    if (!query.matches(doc)) {
                        results = results.remove(key);
                    }
                });
                return results;
            });
        };

        return LocalDocumentsView;
    }();

    var ReferenceSet = function () {
        function ReferenceSet() {
            this.refsByKey = new SortedSet(DocReference.compareByKey);
            this.refsByTarget = new SortedSet(DocReference.compareByTargetId);
        }

        ReferenceSet.prototype.isEmpty = function () {
            return this.refsByKey.isEmpty();
        };

        ReferenceSet.prototype.addReference = function (key, id) {
            var ref = new DocReference(key, id);
            this.refsByKey = this.refsByKey.add(ref);
            this.refsByTarget = this.refsByTarget.add(ref);
        };

        ReferenceSet.prototype.addReferences = function (keys, id) {
            var _this = this;

            keys.forEach(function (key) {
                return _this.addReference(key, id);
            });
        };

        ReferenceSet.prototype.removeReference = function (key, id) {
            this.removeRef(new DocReference(key, id));
        };

        ReferenceSet.prototype.removeReferences = function (keys, id) {
            var _this = this;

            keys.forEach(function (key) {
                return _this.removeReference(key, id);
            });
        };

        ReferenceSet.prototype.removeReferencesForId = function (id) {
            var _this = this;

            var emptyKey = DocumentKey.EMPTY;
            var startRef = new DocReference(emptyKey, id);
            var endRef = new DocReference(emptyKey, id + 1);
            var keys = [];
            this.refsByTarget.forEachInRange([startRef, endRef], function (ref) {
                _this.removeRef(ref);

                keys.push(ref.key);
            });
            return keys;
        };

        ReferenceSet.prototype.removeAllReferences = function () {
            var _this = this;

            this.refsByKey.forEach(function (ref) {
                return _this.removeRef(ref);
            });
        };

        ReferenceSet.prototype.removeRef = function (ref) {
            this.refsByKey = this.refsByKey.delete(ref);
            this.refsByTarget = this.refsByTarget.delete(ref);
        };

        ReferenceSet.prototype.referencesForId = function (id) {
            var emptyKey = DocumentKey.EMPTY;
            var startRef = new DocReference(emptyKey, id);
            var endRef = new DocReference(emptyKey, id + 1);
            var keys = documentKeySet();
            this.refsByTarget.forEachInRange([startRef, endRef], function (ref) {
                keys = keys.add(ref.key);
            });
            return keys;
        };

        ReferenceSet.prototype.containsKey = function (key) {
            var ref = new DocReference(key, 0);
            var firstRef = this.refsByKey.firstAfterOrEqual(ref);
            return firstRef !== null && key.isEqual(firstRef.key);
        };

        return ReferenceSet;
    }();

    var DocReference = function () {
        function DocReference(key, targetOrBatchId) {
            this.key = key;
            this.targetOrBatchId = targetOrBatchId;
        }

        DocReference.compareByKey = function (left, right) {
            return DocumentKey.comparator(left.key, right.key) || primitiveComparator(left.targetOrBatchId, right.targetOrBatchId);
        };

        DocReference.compareByTargetId = function (left, right) {
            return primitiveComparator(left.targetOrBatchId, right.targetOrBatchId) || DocumentKey.comparator(left.key, right.key);
        };

        return DocReference;
    }();

    var RemoteDocumentChangeBuffer = function () {
        function RemoteDocumentChangeBuffer(remoteDocumentCache) {
            this.remoteDocumentCache = remoteDocumentCache;
            this.changes = maybeDocumentMap();
        }

        RemoteDocumentChangeBuffer.prototype.addEntry = function (maybeDocument) {
            var changes = this.assertChanges();
            this.changes = changes.insert(maybeDocument.key, maybeDocument);
        };

        RemoteDocumentChangeBuffer.prototype.getEntry = function (transaction, documentKey) {
            var changes = this.assertChanges();
            var bufferedEntry = changes.get(documentKey);

            if (bufferedEntry) {
                return PersistencePromise.resolve(bufferedEntry);
            } else {
                return this.remoteDocumentCache.getEntry(transaction, documentKey);
            }
        };

        RemoteDocumentChangeBuffer.prototype.apply = function (transaction) {
            var docs = [];
            var changes = this.assertChanges();
            changes.forEach(function (key, maybeDoc) {
                docs.push(maybeDoc);
            });
            this.changes = null;
            return this.remoteDocumentCache.addEntries(transaction, docs);
        };

        RemoteDocumentChangeBuffer.prototype.assertChanges = function () {
            assert(this.changes !== null, 'Changes have already been applied.');
            return this.changes;
        };

        return RemoteDocumentChangeBuffer;
    }();

    var LOG_TAG$3 = 'LocalStore';

    var LocalStore = function () {
        function LocalStore(persistence, initialUser) {
            this.persistence = persistence;
            this.localViewReferences = new ReferenceSet();
            this.queryDataByTarget = {};
            assert(persistence.started, 'LocalStore was passed an unstarted persistence implementation');
            this.persistence.referenceDelegate.setInMemoryPins(this.localViewReferences);
            this.mutationQueue = persistence.getMutationQueue(initialUser);
            this.remoteDocuments = persistence.getRemoteDocumentCache();
            this.queryCache = persistence.getQueryCache();
            this.localDocuments = new LocalDocumentsView(this.remoteDocuments, this.mutationQueue);
        }

        LocalStore.prototype.handleUserChange = function (user) {
            var _this = this;

            return this.persistence.runTransaction('Handle user change', 'readonly', function (txn) {
                var oldBatches;
                return _this.mutationQueue.getAllMutationBatches(txn).next(function (promisedOldBatches) {
                    oldBatches = promisedOldBatches;
                    _this.mutationQueue = _this.persistence.getMutationQueue(user);
                    _this.localDocuments = new LocalDocumentsView(_this.remoteDocuments, _this.mutationQueue);
                    return _this.mutationQueue.getAllMutationBatches(txn);
                }).next(function (newBatches) {
                    var removedBatchIds = [];
                    var addedBatchIds = [];
                    var changedKeys = documentKeySet();

                    for (var _i = 0, oldBatches_1 = oldBatches; _i < oldBatches_1.length; _i++) {
                        var batch = oldBatches_1[_i];
                        removedBatchIds.push(batch.batchId);

                        for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {
                            var mutation = _b[_a];
                            changedKeys = changedKeys.add(mutation.key);
                        }
                    }

                    for (var _c = 0, newBatches_1 = newBatches; _c < newBatches_1.length; _c++) {
                        var batch = newBatches_1[_c];
                        addedBatchIds.push(batch.batchId);

                        for (var _d = 0, _e = batch.mutations; _d < _e.length; _d++) {
                            var mutation = _e[_d];
                            changedKeys = changedKeys.add(mutation.key);
                        }
                    }

                    return _this.localDocuments.getDocuments(txn, changedKeys).next(function (affectedDocuments) {
                        return {
                            affectedDocuments: affectedDocuments,
                            removedBatchIds: removedBatchIds,
                            addedBatchIds: addedBatchIds
                        };
                    });
                });
            });
        };

        LocalStore.prototype.localWrite = function (mutations) {
            var _this = this;

            return this.persistence.runTransaction('Locally write mutations', 'readwrite', function (txn) {
                var batch;
                var localWriteTime = Timestamp.now();
                return _this.mutationQueue.addMutationBatch(txn, localWriteTime, mutations).next(function (promisedBatch) {
                    batch = promisedBatch;
                    var keys = batch.keys();
                    return _this.localDocuments.getDocuments(txn, keys);
                }).next(function (changedDocuments) {
                    return {
                        batchId: batch.batchId,
                        changes: changedDocuments
                    };
                });
            });
        };

        LocalStore.prototype.lookupMutationDocuments = function (batchId) {
            var _this = this;

            return this.persistence.runTransaction('Lookup mutation documents', 'readonly', function (txn) {
                return _this.mutationQueue.lookupMutationKeys(txn, batchId).next(function (keys) {
                    if (keys) {
                        return _this.localDocuments.getDocuments(txn, keys);
                    } else {
                        return PersistencePromise.resolve(null);
                    }
                });
            });
        };

        LocalStore.prototype.acknowledgeBatch = function (batchResult) {
            var _this = this;

            return this.persistence.runTransaction('Acknowledge batch', 'readwrite-primary', function (txn) {
                var affected = batchResult.batch.keys();
                var documentBuffer = new RemoteDocumentChangeBuffer(_this.remoteDocuments);
                return _this.mutationQueue.acknowledgeBatch(txn, batchResult.batch, batchResult.streamToken).next(function () {
                    return _this.applyWriteToRemoteDocuments(txn, batchResult, documentBuffer);
                }).next(function () {
                    return documentBuffer.apply(txn);
                }).next(function () {
                    return _this.mutationQueue.performConsistencyCheck(txn);
                }).next(function () {
                    return _this.localDocuments.getDocuments(txn, affected);
                });
            });
        };

        LocalStore.prototype.rejectBatch = function (batchId) {
            var _this = this;

            return this.persistence.runTransaction('Reject batch', 'readwrite-primary', function (txn) {
                var affectedKeys;
                return _this.mutationQueue.lookupMutationBatch(txn, batchId).next(function (batch) {
                    assert(batch !== null, 'Attempt to reject nonexistent batch!');
                    affectedKeys = batch.keys();
                    return _this.mutationQueue.removeMutationBatch(txn, batch);
                }).next(function () {
                    return _this.mutationQueue.performConsistencyCheck(txn);
                }).next(function () {
                    return _this.localDocuments.getDocuments(txn, affectedKeys);
                });
            });
        };

        LocalStore.prototype.getLastStreamToken = function () {
            var _this = this;

            return this.persistence.runTransaction('Get last stream token', 'readonly', function (txn) {
                return _this.mutationQueue.getLastStreamToken(txn);
            });
        };

        LocalStore.prototype.setLastStreamToken = function (streamToken) {
            var _this = this;

            return this.persistence.runTransaction('Set last stream token', 'readwrite-primary', function (txn) {
                return _this.mutationQueue.setLastStreamToken(txn, streamToken);
            });
        };

        LocalStore.prototype.getLastRemoteSnapshotVersion = function () {
            var _this = this;

            return this.persistence.runTransaction('Get last remote snapshot version', 'readonly', function (txn) {
                return _this.queryCache.getLastRemoteSnapshotVersion(txn);
            });
        };

        LocalStore.prototype.applyRemoteEvent = function (remoteEvent) {
            var _this = this;

            var documentBuffer = new RemoteDocumentChangeBuffer(this.remoteDocuments);
            return this.persistence.runTransaction('Apply remote event', 'readwrite-primary', function (txn) {
                var promises = [];
                var authoritativeUpdates = documentKeySet();
                forEachNumber(remoteEvent.targetChanges, function (targetId, change) {
                    var queryData = _this.queryDataByTarget[targetId];
                    if (!queryData) return;
                    change.addedDocuments.forEach(function (key) {
                        authoritativeUpdates = authoritativeUpdates.add(key);
                    });
                    change.modifiedDocuments.forEach(function (key) {
                        authoritativeUpdates = authoritativeUpdates.add(key);
                    });
                    promises.push(_this.queryCache.removeMatchingKeys(txn, change.removedDocuments, targetId).next(function () {
                        return _this.queryCache.addMatchingKeys(txn, change.addedDocuments, targetId);
                    }));
                    var resumeToken = change.resumeToken;

                    if (resumeToken.length > 0) {
                        var oldQueryData = queryData;
                        queryData = queryData.copy({
                            resumeToken: resumeToken,
                            snapshotVersion: remoteEvent.snapshotVersion
                        });
                        _this.queryDataByTarget[targetId] = queryData;

                        if (LocalStore.shouldPersistQueryData(oldQueryData, queryData, change)) {
                            promises.push(_this.queryCache.updateQueryData(txn, queryData));
                        }
                    }
                });
                var changedDocKeys = documentKeySet();
                remoteEvent.documentUpdates.forEach(function (key, doc) {
                    changedDocKeys = changedDocKeys.add(key);
                    promises.push(documentBuffer.getEntry(txn, key).next(function (existingDoc) {
                        if (existingDoc == null || doc.version.isEqual(SnapshotVersion.MIN) || authoritativeUpdates.has(doc.key) && !existingDoc.hasPendingWrites || doc.version.compareTo(existingDoc.version) >= 0) {
                            documentBuffer.addEntry(doc);
                        } else {
                            debug(LOG_TAG$3, 'Ignoring outdated watch update for ', key, '. Current version:', existingDoc.version, ' Watch version:', doc.version);
                        }
                    }));

                    if (remoteEvent.resolvedLimboDocuments.has(key)) {
                        promises.push(_this.persistence.referenceDelegate.updateLimboDocument(txn, key));
                    }
                });
                var remoteVersion = remoteEvent.snapshotVersion;

                if (!remoteVersion.isEqual(SnapshotVersion.MIN)) {
                    var updateRemoteVersion = _this.queryCache.getLastRemoteSnapshotVersion(txn).next(function (lastRemoteVersion) {
                        assert(remoteVersion.compareTo(lastRemoteVersion) >= 0, 'Watch stream reverted to previous snapshot?? ' + remoteVersion + ' < ' + lastRemoteVersion);
                        return _this.queryCache.setTargetsMetadata(txn, txn.currentSequenceNumber, remoteVersion);
                    });

                    promises.push(updateRemoteVersion);
                }

                return PersistencePromise.waitFor(promises).next(function () {
                    return documentBuffer.apply(txn);
                }).next(function () {
                    return _this.localDocuments.getDocuments(txn, changedDocKeys);
                });
            });
        };

        LocalStore.shouldPersistQueryData = function (oldQueryData, newQueryData, change) {
            if (newQueryData.resumeToken.length === 0) return false;
            if (oldQueryData.resumeToken.length === 0) return true;
            var timeDelta = newQueryData.snapshotVersion.toMicroseconds() - oldQueryData.snapshotVersion.toMicroseconds();
            if (timeDelta >= this.RESUME_TOKEN_MAX_AGE_MICROS) return true;
            var changes = change.addedDocuments.size + change.modifiedDocuments.size + change.removedDocuments.size;
            return changes > 0;
        };

        LocalStore.prototype.notifyLocalViewChanges = function (viewChanges) {
            var _this = this;

            return this.persistence.runTransaction('notifyLocalViewChanges', 'readwrite', function (txn) {
                return PersistencePromise.forEach(viewChanges, function (viewChange) {
                    _this.localViewReferences.addReferences(viewChange.addedKeys, viewChange.targetId);

                    _this.localViewReferences.removeReferences(viewChange.removedKeys, viewChange.targetId);

                    return PersistencePromise.forEach(viewChange.removedKeys, function (key) {
                        return _this.persistence.referenceDelegate.removeReference(txn, key);
                    });
                });
            });
        };

        LocalStore.prototype.nextMutationBatch = function (afterBatchId) {
            var _this = this;

            return this.persistence.runTransaction('Get next mutation batch', 'readonly', function (txn) {
                if (afterBatchId === undefined) {
                    afterBatchId = BATCHID_UNKNOWN;
                }

                return _this.mutationQueue.getNextMutationBatchAfterBatchId(txn, afterBatchId);
            });
        };

        LocalStore.prototype.readDocument = function (key) {
            var _this = this;

            return this.persistence.runTransaction('read document', 'readonly', function (txn) {
                return _this.localDocuments.getDocument(txn, key);
            });
        };

        LocalStore.prototype.allocateQuery = function (query) {
            var _this = this;

            return this.persistence.runTransaction('Allocate query', 'readwrite', function (txn) {
                var queryData;
                return _this.queryCache.getQueryData(txn, query).next(function (cached) {
                    if (cached) {
                        queryData = cached;
                        return PersistencePromise.resolve();
                    } else {
                        return _this.queryCache.allocateTargetId(txn).next(function (targetId) {
                            queryData = new QueryData(query, targetId, QueryPurpose.Listen, txn.currentSequenceNumber);
                            return _this.queryCache.addQueryData(txn, queryData);
                        });
                    }
                }).next(function () {
                    assert(!_this.queryDataByTarget[queryData.targetId], 'Tried to allocate an already allocated query: ' + query);
                    _this.queryDataByTarget[queryData.targetId] = queryData;
                    return queryData;
                });
            });
        };

        LocalStore.prototype.releaseQuery = function (query, keepPersistedQueryData) {
            var _this = this;

            var mode = keepPersistedQueryData ? 'readwrite' : 'readwrite-primary';
            return this.persistence.runTransaction('Release query', mode, function (txn) {
                return _this.queryCache.getQueryData(txn, query).next(function (queryData) {
                    assert(queryData != null, 'Tried to release nonexistent query: ' + query);
                    var targetId = queryData.targetId;
                    var cachedQueryData = _this.queryDataByTarget[targetId];

                    var removed = _this.localViewReferences.removeReferencesForId(targetId);

                    delete _this.queryDataByTarget[targetId];

                    if (!keepPersistedQueryData) {
                        return PersistencePromise.forEach(removed, function (key) {
                            return _this.persistence.referenceDelegate.removeReference(txn, key);
                        }).next(function () {
                            return _this.persistence.referenceDelegate.removeTarget(txn, cachedQueryData);
                        });
                    } else {
                        return PersistencePromise.resolve();
                    }
                });
            });
        };

        LocalStore.prototype.executeQuery = function (query) {
            var _this = this;

            return this.persistence.runTransaction('Execute query', 'readonly', function (txn) {
                return _this.localDocuments.getDocumentsMatchingQuery(txn, query);
            });
        };

        LocalStore.prototype.remoteDocumentKeys = function (targetId) {
            var _this = this;

            return this.persistence.runTransaction('Remote document keys', 'readonly', function (txn) {
                return _this.queryCache.getMatchingKeysForTargetId(txn, targetId);
            });
        };

        LocalStore.prototype.getActiveClients = function () {
            return this.persistence.getActiveClients();
        };

        LocalStore.prototype.removeCachedMutationBatchMetadata = function (batchId) {
            this.mutationQueue.removeCachedMutationKeys(batchId);
        };

        LocalStore.prototype.setNetworkEnabled = function (networkEnabled) {
            this.persistence.setNetworkEnabled(networkEnabled);
        };

        LocalStore.prototype.applyWriteToRemoteDocuments = function (txn, batchResult, documentBuffer) {
            var _this = this;

            var batch = batchResult.batch;
            var docKeys = batch.keys();
            var promiseChain = PersistencePromise.resolve();
            docKeys.forEach(function (docKey) {
                promiseChain = promiseChain.next(function () {
                    return documentBuffer.getEntry(txn, docKey);
                }).next(function (remoteDoc) {
                    var doc = remoteDoc;
                    var ackVersion = batchResult.docVersions.get(docKey);
                    assert(ackVersion !== null, 'ackVersions should contain every doc in the write.');

                    if (!doc || doc.version.compareTo(ackVersion) < 0) {
                        doc = batch.applyToRemoteDocument(docKey, doc, batchResult);

                        if (!doc) {
                            assert(!remoteDoc, 'Mutation batch ' + batch + ' applied to document ' + remoteDoc + ' resulted in null');
                        } else {
                            documentBuffer.addEntry(doc);
                        }
                    }
                });
            });
            return promiseChain.next(function () {
                return _this.mutationQueue.removeMutationBatch(txn, batch);
            });
        };

        LocalStore.prototype.getQueryForTarget = function (targetId) {
            var _this = this;

            if (this.queryDataByTarget[targetId]) {
                return Promise.resolve(this.queryDataByTarget[targetId].query);
            } else {
                return this.persistence.runTransaction('Get query data', 'readonly', function (txn) {
                    return _this.queryCache.getQueryDataForTarget(txn, targetId).next(function (queryData) {
                        return queryData ? queryData.query : null;
                    });
                });
            }
        };

        LocalStore.prototype.getNewDocumentChanges = function () {
            var _this = this;

            return this.persistence.runTransaction('Get new document changes', 'readonly', function (txn) {
                return _this.remoteDocuments.getNewDocumentChanges(txn);
            });
        };

        LocalStore.RESUME_TOKEN_MAX_AGE_MICROS = 5 * 60 * 1e6;
        return LocalStore;
    }();

    var ObjectMap = function () {
        function ObjectMap(mapKeyFn) {
            this.mapKeyFn = mapKeyFn;
            this.inner = {};
        }

        ObjectMap.prototype.get = function (key) {
            var id = this.mapKeyFn(key);
            var matches = this.inner[id];

            if (matches === undefined) {
                return undefined;
            }

            for (var _i = 0, matches_1 = matches; _i < matches_1.length; _i++) {
                var _a = matches_1[_i],
                    otherKey = _a[0],
                    value = _a[1];

                if (otherKey.isEqual(key)) {
                    return value;
                }
            }

            return undefined;
        };

        ObjectMap.prototype.has = function (key) {
            return this.get(key) !== undefined;
        };

        ObjectMap.prototype.set = function (key, value) {
            var id = this.mapKeyFn(key);
            var matches = this.inner[id];

            if (matches === undefined) {
                this.inner[id] = [[key, value]];
                return;
            }

            for (var i = 0; i < matches.length; i++) {
                if (matches[i][0].isEqual(key)) {
                    matches[i] = [key, value];
                    return;
                }
            }

            matches.push([key, value]);
        };

        ObjectMap.prototype.delete = function (key) {
            var id = this.mapKeyFn(key);
            var matches = this.inner[id];

            if (matches === undefined) {
                return false;
            }

            for (var i = 0; i < matches.length; i++) {
                if (matches[i][0].isEqual(key)) {
                    if (matches.length === 1) {
                        delete this.inner[id];
                    } else {
                        matches.splice(i, 1);
                    }

                    return true;
                }
            }

            return false;
        };

        ObjectMap.prototype.forEach = function (fn) {
            forEach(this.inner, function (_, entries) {
                for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                    var _a = entries_1[_i],
                        k = _a[0],
                        v = _a[1];
                    fn(k, v);
                }
            });
        };

        ObjectMap.prototype.isEmpty = function () {
            return isEmpty(this.inner);
        };

        ObjectMap.prototype[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"] = function () {
            var entries = [];
            this.forEach(function (key, value) {
                return entries.push({
                    key: key,
                    value: value
                });
            });
            return entries[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"]();
        };

        return ObjectMap;
    }();

    var MemoryMutationQueue = function () {
        function MemoryMutationQueue(referenceDelegate) {
            this.referenceDelegate = referenceDelegate;
            this.mutationQueue = [];
            this.nextBatchId = 1;
            this.highestAcknowledgedBatchId = BATCHID_UNKNOWN;
            this.lastStreamToken = emptyByteString();
            this.batchesByDocumentKey = new SortedSet(DocReference.compareByKey);
        }

        MemoryMutationQueue.prototype.checkEmpty = function (transaction) {
            return PersistencePromise.resolve(this.mutationQueue.length === 0);
        };

        MemoryMutationQueue.prototype.acknowledgeBatch = function (transaction, batch, streamToken) {
            var batchId = batch.batchId;
            assert(batchId > this.highestAcknowledgedBatchId, 'Mutation batchIDs must be acknowledged in order');
            var batchIndex = this.indexOfExistingBatchId(batchId, 'acknowledged');
            var check = this.mutationQueue[batchIndex];
            assert(batchId === check.batchId, 'Queue ordering failure: expected batch ' + batchId + ', got batch ' + check.batchId);
            assert(!check.isTombstone(), "Can't acknowledge a previously removed batch");
            this.highestAcknowledgedBatchId = batchId;
            this.lastStreamToken = streamToken;
            return PersistencePromise.resolve();
        };

        MemoryMutationQueue.prototype.getLastStreamToken = function (transaction) {
            return PersistencePromise.resolve(this.lastStreamToken);
        };

        MemoryMutationQueue.prototype.setLastStreamToken = function (transaction, streamToken) {
            this.lastStreamToken = streamToken;
            return PersistencePromise.resolve();
        };

        MemoryMutationQueue.prototype.addMutationBatch = function (transaction, localWriteTime, mutations) {
            assert(mutations.length !== 0, 'Mutation batches should not be empty');
            var batchId = this.nextBatchId;
            this.nextBatchId++;

            if (this.mutationQueue.length > 0) {
                var prior = this.mutationQueue[this.mutationQueue.length - 1];
                assert(prior.batchId < batchId, 'Mutation batchIDs must be monotonically increasing order');
            }

            var batch = new MutationBatch(batchId, localWriteTime, mutations);
            this.mutationQueue.push(batch);

            for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {
                var mutation = mutations_1[_i];
                this.batchesByDocumentKey = this.batchesByDocumentKey.add(new DocReference(mutation.key, batchId));
            }

            return PersistencePromise.resolve(batch);
        };

        MemoryMutationQueue.prototype.lookupMutationBatch = function (transaction, batchId) {
            return PersistencePromise.resolve(this.findMutationBatch(batchId));
        };

        MemoryMutationQueue.prototype.lookupMutationKeys = function (transaction, batchId) {
            var mutationBatch = this.findMutationBatch(batchId);
            assert(mutationBatch != null, 'Failed to find local mutation batch.');
            return PersistencePromise.resolve(!mutationBatch.isTombstone() ? mutationBatch.keys() : null);
        };

        MemoryMutationQueue.prototype.getNextMutationBatchAfterBatchId = function (transaction, batchId) {
            var size = this.mutationQueue.length;
            var nextBatchId = Math.max(batchId, this.highestAcknowledgedBatchId) + 1;
            var rawIndex = this.indexOfBatchId(nextBatchId);
            var index = rawIndex < 0 ? 0 : rawIndex;

            for (; index < size; index++) {
                var batch = this.mutationQueue[index];

                if (!batch.isTombstone()) {
                    return PersistencePromise.resolve(batch);
                }
            }

            return PersistencePromise.resolve(null);
        };

        MemoryMutationQueue.prototype.getAllMutationBatches = function (transaction) {
            return PersistencePromise.resolve(this.getAllLiveMutationBatchesBeforeIndex(this.mutationQueue.length));
        };

        MemoryMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKey = function (transaction, documentKey) {
            var _this = this;

            var start = new DocReference(documentKey, 0);
            var end = new DocReference(documentKey, Number.POSITIVE_INFINITY);
            var result = [];
            this.batchesByDocumentKey.forEachInRange([start, end], function (ref) {
                assert(documentKey.isEqual(ref.key), "Should only iterate over a single key's batches");

                var batch = _this.findMutationBatch(ref.targetOrBatchId);

                assert(batch !== null, 'Batches in the index must exist in the main table');
                result.push(batch);
            });
            return PersistencePromise.resolve(result);
        };

        MemoryMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKeys = function (transaction, documentKeys) {
            var _this = this;

            var uniqueBatchIDs = new SortedSet(primitiveComparator);
            documentKeys.forEach(function (documentKey) {
                var start = new DocReference(documentKey, 0);
                var end = new DocReference(documentKey, Number.POSITIVE_INFINITY);

                _this.batchesByDocumentKey.forEachInRange([start, end], function (ref) {
                    assert(documentKey.isEqual(ref.key), "For each key, should only iterate over a single key's batches");
                    uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);
                });
            });
            return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));
        };

        MemoryMutationQueue.prototype.getAllMutationBatchesAffectingQuery = function (transaction, query) {
            var prefix = query.path;
            var immediateChildrenPathLength = prefix.length + 1;
            var startPath = prefix;

            if (!DocumentKey.isDocumentKey(startPath)) {
                startPath = startPath.child('');
            }

            var start = new DocReference(new DocumentKey(startPath), 0);
            var uniqueBatchIDs = new SortedSet(primitiveComparator);
            this.batchesByDocumentKey.forEachWhile(function (ref) {
                var rowKeyPath = ref.key.path;

                if (!prefix.isPrefixOf(rowKeyPath)) {
                    return false;
                } else {
                    if (rowKeyPath.length === immediateChildrenPathLength) {
                        uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);
                    }

                    return true;
                }
            }, start);
            return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));
        };

        MemoryMutationQueue.prototype.findMutationBatches = function (batchIDs) {
            var _this = this;

            var result = [];
            batchIDs.forEach(function (batchId) {
                var batch = _this.findMutationBatch(batchId);

                if (batch !== null) {
                    result.push(batch);
                }
            });
            return result;
        };

        MemoryMutationQueue.prototype.removeMutationBatch = function (transaction, batch) {
            var _this = this;

            var batchIndex = this.indexOfExistingBatchId(batch.batchId, 'removed');
            assert(this.mutationQueue[batchIndex].batchId === batch.batchId, 'Removed batches must exist in the queue');

            if (batchIndex === 0) {
                var endIndex = 1;

                for (; endIndex < this.mutationQueue.length; endIndex++) {
                    var batch_1 = this.mutationQueue[endIndex];

                    if (!batch_1.isTombstone()) {
                        break;
                    }
                }

                this.mutationQueue.splice(0, endIndex);
            } else {
                this.mutationQueue[batchIndex] = this.mutationQueue[batchIndex].toTombstone();
            }

            var references = this.batchesByDocumentKey;
            return PersistencePromise.forEach(batch.mutations, function (mutation) {
                var ref = new DocReference(mutation.key, batch.batchId);
                references = references.delete(ref);
                return _this.referenceDelegate.removeMutationReference(transaction, mutation.key);
            }).next(function () {
                _this.batchesByDocumentKey = references;
            });
        };

        MemoryMutationQueue.prototype.removeCachedMutationKeys = function (batchId) {};

        MemoryMutationQueue.prototype.containsKey = function (txn, key) {
            var ref = new DocReference(key, 0);
            var firstRef = this.batchesByDocumentKey.firstAfterOrEqual(ref);
            return PersistencePromise.resolve(key.isEqual(firstRef && firstRef.key));
        };

        MemoryMutationQueue.prototype.performConsistencyCheck = function (txn) {
            if (this.mutationQueue.length === 0) {
                assert(this.batchesByDocumentKey.isEmpty(), 'Document leak -- detected dangling mutation references when queue is empty.');
            }

            return PersistencePromise.resolve();
        };

        MemoryMutationQueue.prototype.getAllLiveMutationBatchesBeforeIndex = function (endIndex) {
            var result = [];

            for (var i = 0; i < endIndex; i++) {
                var batch = this.mutationQueue[i];

                if (!batch.isTombstone()) {
                    result.push(batch);
                }
            }

            return result;
        };

        MemoryMutationQueue.prototype.indexOfExistingBatchId = function (batchId, action) {
            var index = this.indexOfBatchId(batchId);
            assert(index >= 0 && index < this.mutationQueue.length, 'Batches must exist to be ' + action);
            return index;
        };

        MemoryMutationQueue.prototype.indexOfBatchId = function (batchId) {
            if (this.mutationQueue.length === 0) {
                return 0;
            }

            var firstBatchId = this.mutationQueue[0].batchId;
            return batchId - firstBatchId;
        };

        MemoryMutationQueue.prototype.findMutationBatch = function (batchId) {
            var index = this.indexOfBatchId(batchId);

            if (index < 0 || index >= this.mutationQueue.length) {
                return null;
            }

            var batch = this.mutationQueue[index];
            assert(batch.batchId === batchId, 'If found batch must match');
            return batch.isTombstone() ? null : batch;
        };

        return MemoryMutationQueue;
    }();

    var MemoryQueryCache = function () {
        function MemoryQueryCache(persistence) {
            this.persistence = persistence;
            this.queries = new ObjectMap(function (q) {
                return q.canonicalId();
            });
            this.lastRemoteSnapshotVersion = SnapshotVersion.MIN;
            this.highestTargetId = 0;
            this.highestSequenceNumber = 0;
            this.references = new ReferenceSet();
            this.targetCount = 0;
            this.targetIdGenerator = TargetIdGenerator.forQueryCache();
        }

        MemoryQueryCache.prototype.getTargetCount = function (txn) {
            return PersistencePromise.resolve(this.targetCount);
        };

        MemoryQueryCache.prototype.forEachTarget = function (txn, f) {
            this.queries.forEach(function (_, queryData) {
                return f(queryData);
            });
            return PersistencePromise.resolve();
        };

        MemoryQueryCache.prototype.getLastRemoteSnapshotVersion = function (transaction) {
            return PersistencePromise.resolve(this.lastRemoteSnapshotVersion);
        };

        MemoryQueryCache.prototype.getHighestSequenceNumber = function (transaction) {
            return PersistencePromise.resolve(this.highestSequenceNumber);
        };

        MemoryQueryCache.prototype.allocateTargetId = function (transaction) {
            var nextTargetId = this.targetIdGenerator.after(this.highestTargetId);
            this.highestTargetId = nextTargetId;
            return PersistencePromise.resolve(nextTargetId);
        };

        MemoryQueryCache.prototype.setTargetsMetadata = function (transaction, highestListenSequenceNumber, lastRemoteSnapshotVersion) {
            if (lastRemoteSnapshotVersion) {
                this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;
            }

            if (highestListenSequenceNumber > this.highestSequenceNumber) {
                this.highestSequenceNumber = highestListenSequenceNumber;
            }

            return PersistencePromise.resolve();
        };

        MemoryQueryCache.prototype.saveQueryData = function (queryData) {
            this.queries.set(queryData.query, queryData);
            var targetId = queryData.targetId;

            if (targetId > this.highestTargetId) {
                this.highestTargetId = targetId;
            }

            if (queryData.sequenceNumber > this.highestSequenceNumber) {
                this.highestSequenceNumber = queryData.sequenceNumber;
            }
        };

        MemoryQueryCache.prototype.addQueryData = function (transaction, queryData) {
            assert(!this.queries.has(queryData.query), 'Adding a query that already exists');
            this.saveQueryData(queryData);
            this.targetCount += 1;
            return PersistencePromise.resolve();
        };

        MemoryQueryCache.prototype.updateQueryData = function (transaction, queryData) {
            assert(this.queries.has(queryData.query), 'Updating a non-existent query');
            this.saveQueryData(queryData);
            return PersistencePromise.resolve();
        };

        MemoryQueryCache.prototype.removeQueryData = function (transaction, queryData) {
            assert(this.targetCount > 0, 'Removing a target from an empty cache');
            assert(this.queries.has(queryData.query), 'Removing a non-existent target from the cache');
            this.queries.delete(queryData.query);
            this.references.removeReferencesForId(queryData.targetId);
            this.targetCount -= 1;
            return PersistencePromise.resolve();
        };

        MemoryQueryCache.prototype.removeTargets = function (transaction, upperBound, activeTargetIds) {
            var _this = this;

            var count = 0;
            var removals = [];
            this.queries.forEach(function (key, queryData) {
                if (queryData.sequenceNumber <= upperBound && !activeTargetIds[queryData.targetId]) {
                    _this.queries.delete(key);

                    removals.push(_this.removeMatchingKeysForTargetId(transaction, queryData.targetId));
                    count++;
                }
            });
            return PersistencePromise.waitFor(removals).next(function () {
                return count;
            });
        };

        MemoryQueryCache.prototype.getQueryCount = function (transaction) {
            return PersistencePromise.resolve(this.targetCount);
        };

        MemoryQueryCache.prototype.getQueryData = function (transaction, query) {
            var queryData = this.queries.get(query) || null;
            return PersistencePromise.resolve(queryData);
        };

        MemoryQueryCache.prototype.getQueryDataForTarget = function (transaction, targetId) {
            return fail('Not yet implemented.');
        };

        MemoryQueryCache.prototype.addMatchingKeys = function (txn, keys, targetId) {
            this.references.addReferences(keys, targetId);
            var referenceDelegate = this.persistence.referenceDelegate;
            var promises = [];

            if (referenceDelegate) {
                keys.forEach(function (key) {
                    promises.push(referenceDelegate.addReference(txn, key));
                });
            }

            return PersistencePromise.waitFor(promises);
        };

        MemoryQueryCache.prototype.removeMatchingKeys = function (txn, keys, targetId) {
            this.references.removeReferences(keys, targetId);
            var referenceDelegate = this.persistence.referenceDelegate;
            var promises = [];

            if (referenceDelegate) {
                keys.forEach(function (key) {
                    promises.push(referenceDelegate.removeReference(txn, key));
                });
            }

            return PersistencePromise.waitFor(promises);
        };

        MemoryQueryCache.prototype.removeMatchingKeysForTargetId = function (txn, targetId) {
            this.references.removeReferencesForId(targetId);
            return PersistencePromise.resolve();
        };

        MemoryQueryCache.prototype.getMatchingKeysForTargetId = function (txn, targetId) {
            var matchingKeys = this.references.referencesForId(targetId);
            return PersistencePromise.resolve(matchingKeys);
        };

        MemoryQueryCache.prototype.containsKey = function (txn, key) {
            return PersistencePromise.resolve(this.references.containsKey(key));
        };

        return MemoryQueryCache;
    }();

    var MemoryRemoteDocumentCache = function () {
        function MemoryRemoteDocumentCache() {
            this.docs = maybeDocumentMap();
            this.newDocumentChanges = documentKeySet();
        }

        MemoryRemoteDocumentCache.prototype.addEntries = function (transaction, maybeDocuments) {
            for (var _i = 0, maybeDocuments_1 = maybeDocuments; _i < maybeDocuments_1.length; _i++) {
                var maybeDocument = maybeDocuments_1[_i];
                this.docs = this.docs.insert(maybeDocument.key, maybeDocument);
                this.newDocumentChanges = this.newDocumentChanges.add(maybeDocument.key);
            }

            return PersistencePromise.resolve();
        };

        MemoryRemoteDocumentCache.prototype.removeEntry = function (transaction, documentKey) {
            this.docs = this.docs.remove(documentKey);
            return PersistencePromise.resolve();
        };

        MemoryRemoteDocumentCache.prototype.getEntry = function (transaction, documentKey) {
            return PersistencePromise.resolve(this.docs.get(documentKey));
        };

        MemoryRemoteDocumentCache.prototype.getDocumentsMatchingQuery = function (transaction, query) {
            var results = documentMap();
            var prefix = new DocumentKey(query.path.child(''));
            var iterator = this.docs.getIteratorFrom(prefix);

            while (iterator.hasNext()) {
                var _a = iterator.getNext(),
                    key = _a.key,
                    maybeDoc = _a.value;

                if (!query.path.isPrefixOf(key.path)) {
                    break;
                }

                if (maybeDoc instanceof Document && query.matches(maybeDoc)) {
                    results = results.insert(maybeDoc.key, maybeDoc);
                }
            }

            return PersistencePromise.resolve(results);
        };

        MemoryRemoteDocumentCache.prototype.forEachDocumentKey = function (transaction, f) {
            return PersistencePromise.forEach(this.docs, function (entry) {
                return f(entry.key);
            });
        };

        MemoryRemoteDocumentCache.prototype.getNewDocumentChanges = function (transaction) {
            var _this = this;

            var changedDocs = maybeDocumentMap();
            this.newDocumentChanges.forEach(function (key) {
                changedDocs = changedDocs.insert(key, _this.docs.get(key) || new NoDocument(key, SnapshotVersion.forDeletedDoc()));
            });
            this.newDocumentChanges = documentKeySet();
            return PersistencePromise.resolve(changedDocs);
        };

        return MemoryRemoteDocumentCache;
    }();

    var LOG_TAG$4 = 'MemoryPersistence';

    var MemoryPersistence = function () {
        function MemoryPersistence(clientId, isEager) {
            this.clientId = clientId;
            this.mutationQueues = {};
            this.remoteDocumentCache = new MemoryRemoteDocumentCache();
            this.listenSequence = new ListenSequence(0);
            this._started = false;
            this._started = true;

            if (isEager) {
                this.referenceDelegate = new MemoryEagerDelegate(this);
            } else {
                this.referenceDelegate = new MemoryLruDelegate(this);
            }

            this.queryCache = new MemoryQueryCache(this);
        }

        MemoryPersistence.createLruPersistence = function (clientId) {
            return new MemoryPersistence(clientId, false);
        };

        MemoryPersistence.createEagerPersistence = function (clientId) {
            return new MemoryPersistence(clientId, true);
        };

        MemoryPersistence.prototype.shutdown = function (deleteData) {
            this._started = false;
            return Promise.resolve();
        };

        Object.defineProperty(MemoryPersistence.prototype, "started", {
            get: function get() {
                return this._started;
            },
            enumerable: true,
            configurable: true
        });

        MemoryPersistence.prototype.getActiveClients = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                return tslib_1.__generator(this, function (_a) {
                    return [2, [this.clientId]];
                });
            });
        };

        MemoryPersistence.prototype.setPrimaryStateListener = function (primaryStateListener) {
            return primaryStateListener(true);
        };

        MemoryPersistence.prototype.setNetworkEnabled = function (networkEnabled) {};

        MemoryPersistence.prototype.getMutationQueue = function (user) {
            var queue = this.mutationQueues[user.toKey()];

            if (!queue) {
                queue = new MemoryMutationQueue(this.referenceDelegate);
                this.mutationQueues[user.toKey()] = queue;
            }

            return queue;
        };

        MemoryPersistence.prototype.getQueryCache = function () {
            return this.queryCache;
        };

        MemoryPersistence.prototype.getRemoteDocumentCache = function () {
            return this.remoteDocumentCache;
        };

        MemoryPersistence.prototype.runTransaction = function (action, mode, transactionOperation) {
            var _this = this;

            debug(LOG_TAG$4, 'Starting transaction:', action);
            var txn = new MemoryTransaction(this.listenSequence.next());
            this.referenceDelegate.onTransactionStarted();
            return transactionOperation(txn).next(function (result) {
                return _this.referenceDelegate.onTransactionCommitted(txn).next(function () {
                    return result;
                });
            }).toPromise();
        };

        MemoryPersistence.prototype.mutationQueuesContainKey = function (transaction, key) {
            return PersistencePromise.or(values(this.mutationQueues).map(function (queue) {
                return function () {
                    return queue.containsKey(transaction, key);
                };
            }));
        };

        return MemoryPersistence;
    }();

    var MemoryTransaction = function () {
        function MemoryTransaction(currentSequenceNumber) {
            this.currentSequenceNumber = currentSequenceNumber;
        }

        return MemoryTransaction;
    }();

    var MemoryEagerDelegate = function () {
        function MemoryEagerDelegate(persistence) {
            this.persistence = persistence;
        }

        MemoryEagerDelegate.prototype.setInMemoryPins = function (inMemoryPins) {
            this.inMemoryPins = inMemoryPins;
        };

        MemoryEagerDelegate.prototype.addReference = function (txn, key) {
            this.orphanedDocuments.delete(key);
            return PersistencePromise.resolve();
        };

        MemoryEagerDelegate.prototype.removeReference = function (txn, key) {
            this.orphanedDocuments.add(key);
            return PersistencePromise.resolve();
        };

        MemoryEagerDelegate.prototype.removeMutationReference = function (txn, key) {
            this.orphanedDocuments.add(key);
            return PersistencePromise.resolve();
        };

        MemoryEagerDelegate.prototype.removeTarget = function (txn, queryData) {
            var _this = this;

            var cache = this.persistence.getQueryCache();
            return cache.getMatchingKeysForTargetId(txn, queryData.targetId).next(function (keys) {
                keys.forEach(function (key) {
                    return _this.orphanedDocuments.add(key);
                });
            }).next(function () {
                return cache.removeQueryData(txn, queryData);
            });
        };

        MemoryEagerDelegate.prototype.onTransactionStarted = function () {
            this.orphanedDocuments = new Set();
        };

        MemoryEagerDelegate.prototype.onTransactionCommitted = function (txn) {
            var _this = this;

            var cache = this.persistence.getRemoteDocumentCache();
            return PersistencePromise.forEach(this.orphanedDocuments, function (key) {
                return _this.isReferenced(txn, key).next(function (isReferenced) {
                    if (!isReferenced) {
                        return cache.removeEntry(txn, key);
                    }
                });
            });
        };

        MemoryEagerDelegate.prototype.updateLimboDocument = function (txn, key) {
            var _this = this;

            return this.isReferenced(txn, key).next(function (isReferenced) {
                if (isReferenced) {
                    _this.orphanedDocuments.delete(key);
                } else {
                    _this.orphanedDocuments.add(key);
                }
            });
        };

        MemoryEagerDelegate.prototype.isReferenced = function (txn, key) {
            var _this = this;

            return PersistencePromise.or([function () {
                return _this.persistence.getQueryCache().containsKey(txn, key);
            }, function () {
                return _this.persistence.mutationQueuesContainKey(txn, key);
            }, function () {
                return PersistencePromise.resolve(_this.inMemoryPins.containsKey(key));
            }]);
        };

        return MemoryEagerDelegate;
    }();

    var MemoryLruDelegate = function () {
        function MemoryLruDelegate(persistence) {
            this.persistence = persistence;
            this.orphanedSequenceNumbers = new ObjectMap(function (k) {
                return encode(k.path);
            });
            this.garbageCollector = new LruGarbageCollector(this);
        }

        MemoryLruDelegate.prototype.onTransactionStarted = function () {};

        MemoryLruDelegate.prototype.onTransactionCommitted = function (txn) {
            return PersistencePromise.resolve();
        };

        MemoryLruDelegate.prototype.forEachTarget = function (txn, f) {
            return this.persistence.getQueryCache().forEachTarget(txn, f);
        };

        MemoryLruDelegate.prototype.getTargetCount = function (txn) {
            return this.persistence.getQueryCache().getTargetCount(txn);
        };

        MemoryLruDelegate.prototype.forEachOrphanedDocumentSequenceNumber = function (txn, f) {
            var _this = this;

            return PersistencePromise.forEach(this.orphanedSequenceNumbers, function (_a) {
                var key = _a.key,
                    sequenceNumber = _a.value;
                return _this.isPinned(txn, key, sequenceNumber).next(function (isPinned) {
                    if (!isPinned) {
                        return f(sequenceNumber);
                    } else {
                        return PersistencePromise.resolve();
                    }
                });
            });
        };

        MemoryLruDelegate.prototype.setInMemoryPins = function (inMemoryPins) {
            this.inMemoryPins = inMemoryPins;
        };

        MemoryLruDelegate.prototype.removeTargets = function (txn, upperBound, activeTargetIds) {
            return this.persistence.getQueryCache().removeTargets(txn, upperBound, activeTargetIds);
        };

        MemoryLruDelegate.prototype.removeOrphanedDocuments = function (txn, upperBound) {
            var _this = this;

            var count = 0;
            var cache = this.persistence.getRemoteDocumentCache();
            var p = cache.forEachDocumentKey(txn, function (key) {
                return _this.isPinned(txn, key, upperBound).next(function (isPinned) {
                    if (isPinned) {
                        return PersistencePromise.resolve();
                    } else {
                        count++;
                        return cache.removeEntry(txn, key);
                    }
                });
            });
            return p.next(function () {
                return count;
            });
        };

        MemoryLruDelegate.prototype.removeMutationReference = function (txn, key) {
            this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);
            return PersistencePromise.resolve();
        };

        MemoryLruDelegate.prototype.removeTarget = function (txn, queryData) {
            var updated = queryData.copy({
                sequenceNumber: txn.currentSequenceNumber
            });
            return this.persistence.getQueryCache().updateQueryData(txn, updated);
        };

        MemoryLruDelegate.prototype.addReference = function (txn, key) {
            this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);
            return PersistencePromise.resolve();
        };

        MemoryLruDelegate.prototype.removeReference = function (txn, key) {
            this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);
            return PersistencePromise.resolve();
        };

        MemoryLruDelegate.prototype.updateLimboDocument = function (txn, key) {
            this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);
            return PersistencePromise.resolve();
        };

        MemoryLruDelegate.prototype.isPinned = function (txn, key, upperBound) {
            var _this = this;

            return PersistencePromise.or([function () {
                return _this.persistence.mutationQueuesContainKey(txn, key);
            }, function () {
                return PersistencePromise.resolve(_this.inMemoryPins.containsKey(key));
            }, function () {
                return _this.persistence.getQueryCache().containsKey(txn, key);
            }, function () {
                var orphanedAt = _this.orphanedSequenceNumbers.get(key);

                return PersistencePromise.resolve(orphanedAt !== undefined && orphanedAt > upperBound);
            }]);
        };

        return MemoryLruDelegate;
    }();

    var LOG_TAG$5 = 'ExponentialBackoff';

    var ExponentialBackoff = function () {
        function ExponentialBackoff(queue, timerId, initialDelayMs, backoffFactor, maxDelayMs) {
            this.queue = queue;
            this.timerId = timerId;
            this.initialDelayMs = initialDelayMs;
            this.backoffFactor = backoffFactor;
            this.maxDelayMs = maxDelayMs;
            this.timerPromise = null;
            this.lastAttemptTime = Date.now();
            this.reset();
        }

        ExponentialBackoff.prototype.reset = function () {
            this.currentBaseMs = 0;
        };

        ExponentialBackoff.prototype.resetToMax = function () {
            this.currentBaseMs = this.maxDelayMs;
        };

        ExponentialBackoff.prototype.backoffAndRun = function (op) {
            var _this = this;

            this.cancel();
            var desiredDelayWithJitterMs = Math.floor(this.currentBaseMs + this.jitterDelayMs());
            var delaySoFarMs = Math.max(0, Date.now() - this.lastAttemptTime);
            var remainingDelayMs = Math.max(0, desiredDelayWithJitterMs - delaySoFarMs);

            if (this.currentBaseMs > 0) {
                debug(LOG_TAG$5, "Backing off for " + remainingDelayMs + " ms " + ("(base delay: " + this.currentBaseMs + " ms, ") + ("delay with jitter: " + desiredDelayWithJitterMs + " ms, ") + ("last attempt: " + delaySoFarMs + " ms ago)"));
            }

            this.timerPromise = this.queue.enqueueAfterDelay(this.timerId, remainingDelayMs, function () {
                _this.lastAttemptTime = Date.now();
                return op();
            });
            this.currentBaseMs *= this.backoffFactor;

            if (this.currentBaseMs < this.initialDelayMs) {
                this.currentBaseMs = this.initialDelayMs;
            }

            if (this.currentBaseMs > this.maxDelayMs) {
                this.currentBaseMs = this.maxDelayMs;
            }
        };

        ExponentialBackoff.prototype.cancel = function () {
            if (this.timerPromise !== null) {
                this.timerPromise.cancel();
                this.timerPromise = null;
            }
        };

        ExponentialBackoff.prototype.jitterDelayMs = function () {
            return (Math.random() - 0.5) * this.currentBaseMs;
        };

        return ExponentialBackoff;
    }();

    var LOG_TAG$6 = 'PersistentStream';
    var PersistentStreamState;

    (function (PersistentStreamState) {
        PersistentStreamState[PersistentStreamState["Initial"] = 0] = "Initial";
        PersistentStreamState[PersistentStreamState["Starting"] = 1] = "Starting";
        PersistentStreamState[PersistentStreamState["Open"] = 2] = "Open";
        PersistentStreamState[PersistentStreamState["Error"] = 3] = "Error";
        PersistentStreamState[PersistentStreamState["Backoff"] = 4] = "Backoff";
    })(PersistentStreamState || (PersistentStreamState = {}));

    var BACKOFF_INITIAL_DELAY_MS = 1000;
    var BACKOFF_MAX_DELAY_MS = 60 * 1000;
    var BACKOFF_FACTOR = 1.5;
    var IDLE_TIMEOUT_MS = 60 * 1000;

    var PersistentStream = function () {
        function PersistentStream(queue, connectionTimerId, idleTimerId, connection, credentialsProvider, listener) {
            this.queue = queue;
            this.idleTimerId = idleTimerId;
            this.connection = connection;
            this.credentialsProvider = credentialsProvider;
            this.listener = listener;
            this.state = PersistentStreamState.Initial;
            this.closeCount = 0;
            this.idleTimer = null;
            this.stream = null;
            this.backoff = new ExponentialBackoff(queue, connectionTimerId, BACKOFF_INITIAL_DELAY_MS, BACKOFF_FACTOR, BACKOFF_MAX_DELAY_MS);
        }

        PersistentStream.prototype.isStarted = function () {
            return this.state === PersistentStreamState.Starting || this.state === PersistentStreamState.Open || this.state === PersistentStreamState.Backoff;
        };

        PersistentStream.prototype.isOpen = function () {
            return this.state === PersistentStreamState.Open;
        };

        PersistentStream.prototype.start = function () {
            if (this.state === PersistentStreamState.Error) {
                this.performBackoff();
                return;
            }

            assert(this.state === PersistentStreamState.Initial, 'Already started');
            this.auth();
        };

        PersistentStream.prototype.stop = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.isStarted()) return [3, 2];
                            return [4, this.close(PersistentStreamState.Initial)];

                        case 1:
                            _a.sent();

                            _a.label = 2;

                        case 2:
                            return [2];
                    }
                });
            });
        };

        PersistentStream.prototype.inhibitBackoff = function () {
            assert(!this.isStarted(), 'Can only inhibit backoff in a stopped state');
            this.state = PersistentStreamState.Initial;
            this.backoff.reset();
        };

        PersistentStream.prototype.markIdle = function () {
            var _this = this;

            if (this.isOpen() && this.idleTimer === null) {
                this.idleTimer = this.queue.enqueueAfterDelay(this.idleTimerId, IDLE_TIMEOUT_MS, function () {
                    return _this.handleIdleCloseTimer();
                });
            }
        };

        PersistentStream.prototype.sendRequest = function (msg) {
            this.cancelIdleCheck();
            this.stream.send(msg);
        };

        PersistentStream.prototype.handleIdleCloseTimer = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                return tslib_1.__generator(this, function (_a) {
                    if (this.isOpen()) {
                        return [2, this.close(PersistentStreamState.Initial)];
                    }

                    return [2];
                });
            });
        };

        PersistentStream.prototype.cancelIdleCheck = function () {
            if (this.idleTimer) {
                this.idleTimer.cancel();
                this.idleTimer = null;
            }
        };

        PersistentStream.prototype.close = function (finalState, error$$1) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            assert(this.isStarted(), 'Only started streams should be closed.');
                            assert(finalState === PersistentStreamState.Error || isNullOrUndefined(error$$1), "Can't provide an error when not in an error state.");
                            this.cancelIdleCheck();
                            this.backoff.cancel();
                            this.closeCount++;

                            if (finalState !== PersistentStreamState.Error) {
                                this.backoff.reset();
                            } else if (error$$1 && error$$1.code === Code.RESOURCE_EXHAUSTED) {
                                error(error$$1.toString());
                                error('Using maximum backoff delay to prevent overloading the backend.');
                                this.backoff.resetToMax();
                            } else if (error$$1 && error$$1.code === Code.UNAUTHENTICATED) {
                                this.credentialsProvider.invalidateToken();
                            }

                            if (this.stream !== null) {
                                this.tearDown();
                                this.stream.close();
                                this.stream = null;
                            }

                            this.state = finalState;
                            return [4, this.listener.onClose(error$$1)];

                        case 1:
                            _a.sent();

                            return [2];
                    }
                });
            });
        };

        PersistentStream.prototype.tearDown = function () {};

        PersistentStream.prototype.auth = function () {
            var _this = this;

            assert(this.state === PersistentStreamState.Initial, 'Must be in initial state to auth');
            this.state = PersistentStreamState.Starting;
            var dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);
            var closeCount = this.closeCount;
            this.credentialsProvider.getToken().then(function (token) {
                if (_this.closeCount === closeCount) {
                    _this.startStream(token);
                }
            }, function (error$$1) {
                dispatchIfNotClosed(function () {
                    var rpcError = new FirestoreError(Code.UNKNOWN, 'Fetching auth token failed: ' + error$$1.message);
                    return _this.handleStreamClose(rpcError);
                });
            });
        };

        PersistentStream.prototype.startStream = function (token) {
            var _this = this;

            assert(this.state === PersistentStreamState.Starting, 'Trying to start stream in a non-starting state');
            var dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);
            this.stream = this.startRpc(token);
            this.stream.onOpen(function () {
                dispatchIfNotClosed(function () {
                    assert(_this.state === PersistentStreamState.Starting, 'Expected stream to be in state Starting, but was ' + _this.state);
                    _this.state = PersistentStreamState.Open;
                    return _this.listener.onOpen();
                });
            });
            this.stream.onClose(function (error$$1) {
                dispatchIfNotClosed(function () {
                    return _this.handleStreamClose(error$$1);
                });
            });
            this.stream.onMessage(function (msg) {
                dispatchIfNotClosed(function () {
                    return _this.onMessage(msg);
                });
            });
        };

        PersistentStream.prototype.performBackoff = function () {
            var _this = this;

            assert(this.state === PersistentStreamState.Error, 'Should only perform backoff when in Error state');
            this.state = PersistentStreamState.Backoff;
            this.backoff.backoffAndRun(function () {
                return tslib_1.__awaiter(_this, void 0, void 0, function () {
                    return tslib_1.__generator(this, function (_a) {
                        assert(this.state === PersistentStreamState.Backoff, 'Backoff elapsed but state is now: ' + this.state);
                        this.state = PersistentStreamState.Initial;
                        this.start();
                        assert(this.isStarted(), 'PersistentStream should have started');
                        return [2];
                    });
                });
            });
        };

        PersistentStream.prototype.handleStreamClose = function (error$$1) {
            assert(this.isStarted(), "Can't handle server close on non-started stream");
            debug(LOG_TAG$6, "close with error: " + error$$1);
            this.stream = null;
            return this.close(PersistentStreamState.Error, error$$1);
        };

        PersistentStream.prototype.getCloseGuardedDispatcher = function (startCloseCount) {
            var _this = this;

            return function (fn) {
                _this.queue.enqueueAndForget(function () {
                    if (_this.closeCount === startCloseCount) {
                        return fn();
                    } else {
                        debug(LOG_TAG$6, 'stream callback skipped by getCloseGuardedDispatcher.');
                        return Promise.resolve();
                    }
                });
            };
        };

        return PersistentStream;
    }();

    var PersistentListenStream = function (_super) {
        tslib_1.__extends(PersistentListenStream, _super);

        function PersistentListenStream(queue, connection, credentials, serializer, listener) {
            var _this = _super.call(this, queue, TimerId.ListenStreamConnectionBackoff, TimerId.ListenStreamIdle, connection, credentials, listener) || this;

            _this.serializer = serializer;
            return _this;
        }

        PersistentListenStream.prototype.startRpc = function (token) {
            return this.connection.openStream('Listen', token);
        };

        PersistentListenStream.prototype.onMessage = function (watchChangeProto) {
            this.backoff.reset();
            var watchChange = this.serializer.fromWatchChange(watchChangeProto);
            var snapshot = this.serializer.versionFromListenResponse(watchChangeProto);
            return this.listener.onWatchChange(watchChange, snapshot);
        };

        PersistentListenStream.prototype.watch = function (queryData) {
            var request = {};
            request.database = this.serializer.encodedDatabaseId;
            request.addTarget = this.serializer.toTarget(queryData);
            var labels = this.serializer.toListenRequestLabels(queryData);

            if (labels) {
                request.labels = labels;
            }

            this.sendRequest(request);
        };

        PersistentListenStream.prototype.unwatch = function (targetId) {
            var request = {};
            request.database = this.serializer.encodedDatabaseId;
            request.removeTarget = targetId;
            this.sendRequest(request);
        };

        return PersistentListenStream;
    }(PersistentStream);

    var PersistentWriteStream = function (_super) {
        tslib_1.__extends(PersistentWriteStream, _super);

        function PersistentWriteStream(queue, connection, credentials, serializer, listener) {
            var _this = _super.call(this, queue, TimerId.WriteStreamConnectionBackoff, TimerId.WriteStreamIdle, connection, credentials, listener) || this;

            _this.serializer = serializer;
            _this.handshakeComplete_ = false;
            return _this;
        }

        Object.defineProperty(PersistentWriteStream.prototype, "handshakeComplete", {
            get: function get() {
                return this.handshakeComplete_;
            },
            enumerable: true,
            configurable: true
        });

        PersistentWriteStream.prototype.start = function () {
            this.handshakeComplete_ = false;

            _super.prototype.start.call(this);
        };

        PersistentWriteStream.prototype.tearDown = function () {
            if (this.handshakeComplete_) {
                this.writeMutations([]);
            }
        };

        PersistentWriteStream.prototype.startRpc = function (token) {
            return this.connection.openStream('Write', token);
        };

        PersistentWriteStream.prototype.onMessage = function (responseProto) {
            assert(!!responseProto.streamToken, 'Got a write response without a stream token');
            this.lastStreamToken = responseProto.streamToken;

            if (!this.handshakeComplete_) {
                assert(!responseProto.writeResults || responseProto.writeResults.length === 0, 'Got mutation results for handshake');
                this.handshakeComplete_ = true;
                return this.listener.onHandshakeComplete();
            } else {
                this.backoff.reset();
                var results = this.serializer.fromWriteResults(responseProto.writeResults, responseProto.commitTime);
                var commitVersion = this.serializer.fromVersion(responseProto.commitTime);
                return this.listener.onMutationResult(commitVersion, results);
            }
        };

        PersistentWriteStream.prototype.writeHandshake = function () {
            assert(this.isOpen(), 'Writing handshake requires an opened stream');
            assert(!this.handshakeComplete_, 'Handshake already completed');
            var request = {};
            request.database = this.serializer.encodedDatabaseId;
            this.sendRequest(request);
        };

        PersistentWriteStream.prototype.writeMutations = function (mutations) {
            var _this = this;

            assert(this.isOpen(), 'Writing mutations requires an opened stream');
            assert(this.handshakeComplete_, 'Handshake must be complete before writing mutations');
            assert(this.lastStreamToken.length > 0, 'Trying to write mutation without a token');
            var request = {
                streamToken: this.lastStreamToken,
                writes: mutations.map(function (mutation) {
                    return _this.serializer.toMutation(mutation);
                })
            };
            this.sendRequest(request);
        };

        return PersistentWriteStream;
    }(PersistentStream);

    var Datastore = function () {
        function Datastore(queue, connection, credentials, serializer) {
            this.queue = queue;
            this.connection = connection;
            this.credentials = credentials;
            this.serializer = serializer;
        }

        Datastore.prototype.newPersistentWriteStream = function (listener) {
            return new PersistentWriteStream(this.queue, this.connection, this.credentials, this.serializer, listener);
        };

        Datastore.prototype.newPersistentWatchStream = function (listener) {
            return new PersistentListenStream(this.queue, this.connection, this.credentials, this.serializer, listener);
        };

        Datastore.prototype.commit = function (mutations) {
            var _this = this;

            var params = {
                database: this.serializer.encodedDatabaseId,
                writes: mutations.map(function (m) {
                    return _this.serializer.toMutation(m);
                })
            };
            return this.invokeRPC('Commit', params).then(function (response) {
                return _this.serializer.fromWriteResults(response.writeResults, response.commitTime);
            });
        };

        Datastore.prototype.lookup = function (keys) {
            var _this = this;

            var params = {
                database: this.serializer.encodedDatabaseId,
                documents: keys.map(function (k) {
                    return _this.serializer.toName(k);
                })
            };
            return this.invokeStreamingRPC('BatchGetDocuments', params).then(function (response) {
                var docs = maybeDocumentMap();
                response.forEach(function (proto) {
                    var doc = _this.serializer.fromMaybeDocument(proto);

                    docs = docs.insert(doc.key, doc);
                });
                var result = [];
                keys.forEach(function (key) {
                    var doc = docs.get(key);
                    assert(!!doc, 'Missing entity in write response for ' + key);
                    result.push(doc);
                });
                return result;
            });
        };

        Datastore.prototype.invokeRPC = function (rpcName, request) {
            var _this = this;

            return this.credentials.getToken().then(function (token) {
                return _this.connection.invokeRPC(rpcName, request, token);
            }).catch(function (error) {
                if (error.code === Code.UNAUTHENTICATED) {
                    _this.credentials.invalidateToken();
                }

                throw error;
            });
        };

        Datastore.prototype.invokeStreamingRPC = function (rpcName, request) {
            var _this = this;

            return this.credentials.getToken().then(function (token) {
                return _this.connection.invokeStreamingRPC(rpcName, request, token);
            }).catch(function (error) {
                if (error.code === Code.UNAUTHENTICATED) {
                    _this.credentials.invalidateToken();
                }

                throw error;
            });
        };

        return Datastore;
    }();

    var Transaction = function () {
        function Transaction(datastore) {
            this.datastore = datastore;
            this.readVersions = documentVersionMap();
            this.mutations = [];
            this.committed = false;
        }

        Transaction.prototype.recordVersion = function (doc) {
            var docVersion;

            if (doc instanceof Document) {
                docVersion = doc.version;
            } else if (doc instanceof NoDocument) {
                docVersion = SnapshotVersion.forDeletedDoc();
            } else {
                throw fail('Document in a transaction was a ' + doc.constructor.name);
            }

            var existingVersion = this.readVersions.get(doc.key);

            if (existingVersion !== null) {
                if (!docVersion.isEqual(existingVersion)) {
                    throw new FirestoreError(Code.ABORTED, 'Document version changed between two reads.');
                }
            } else {
                this.readVersions = this.readVersions.insert(doc.key, docVersion);
            }
        };

        Transaction.prototype.lookup = function (keys) {
            var _this = this;

            if (this.committed) {
                return Promise.reject('Transaction has already completed.');
            }

            if (this.mutations.length > 0) {
                return Promise.reject('Transactions lookups are invalid after writes.');
            }

            return this.datastore.lookup(keys).then(function (docs) {
                docs.forEach(function (doc) {
                    if (doc instanceof NoDocument || doc instanceof Document) {
                        _this.recordVersion(doc);
                    } else {
                        fail('Document in a transaction was a ' + doc.constructor.name);
                    }
                });
                return docs;
            });
        };

        Transaction.prototype.write = function (mutations) {
            if (this.committed) {
                throw new FirestoreError(Code.FAILED_PRECONDITION, 'Transaction has already completed.');
            }

            this.mutations = this.mutations.concat(mutations);
        };

        Transaction.prototype.precondition = function (key) {
            var version = this.readVersions.get(key);

            if (version) {
                return Precondition.updateTime(version);
            } else {
                return Precondition.NONE;
            }
        };

        Transaction.prototype.preconditionForUpdate = function (key) {
            var version = this.readVersions.get(key);

            if (version && version.isEqual(SnapshotVersion.forDeletedDoc())) {
                throw new FirestoreError(Code.FAILED_PRECONDITION, "Can't update a document that doesn't exist.");
            } else if (version) {
                return Precondition.updateTime(version);
            } else {
                return Precondition.exists(true);
            }
        };

        Transaction.prototype.set = function (key, data) {
            this.write(data.toMutations(key, this.precondition(key)));
        };

        Transaction.prototype.update = function (key, data) {
            this.write(data.toMutations(key, this.preconditionForUpdate(key)));
        };

        Transaction.prototype.delete = function (key) {
            this.write([new DeleteMutation(key, this.precondition(key))]);
            this.readVersions = this.readVersions.insert(key, SnapshotVersion.forDeletedDoc());
        };

        Transaction.prototype.commit = function () {
            var _this = this;

            var unwritten = this.readVersions;
            this.mutations.forEach(function (mutation) {
                unwritten = unwritten.remove(mutation.key);
            });

            if (!unwritten.isEmpty()) {
                return Promise.reject(Error('Every document read in a transaction must also be written.'));
            }

            return this.datastore.commit(this.mutations).then(function () {
                _this.committed = true;
            });
        };

        return Transaction;
    }();

    var OnlineState;

    (function (OnlineState) {
        OnlineState[OnlineState["Unknown"] = 0] = "Unknown";
        OnlineState[OnlineState["Online"] = 1] = "Online";
        OnlineState[OnlineState["Offline"] = 2] = "Offline";
    })(OnlineState || (OnlineState = {}));

    var OnlineStateSource;

    (function (OnlineStateSource) {
        OnlineStateSource[OnlineStateSource["RemoteStore"] = 0] = "RemoteStore";
        OnlineStateSource[OnlineStateSource["SharedClientState"] = 1] = "SharedClientState";
    })(OnlineStateSource || (OnlineStateSource = {}));

    var LOG_TAG$7 = 'OnlineStateTracker';
    var MAX_WATCH_STREAM_FAILURES = 1;
    var ONLINE_STATE_TIMEOUT_MS = 10 * 1000;

    var OnlineStateTracker = function () {
        function OnlineStateTracker(asyncQueue, onlineStateHandler) {
            this.asyncQueue = asyncQueue;
            this.onlineStateHandler = onlineStateHandler;
            this.state = OnlineState.Unknown;
            this.watchStreamFailures = 0;
            this.onlineStateTimer = null;
            this.shouldWarnClientIsOffline = true;
        }

        OnlineStateTracker.prototype.handleWatchStreamStart = function () {
            var _this = this;

            if (this.watchStreamFailures === 0) {
                this.setAndBroadcast(OnlineState.Unknown);
                assert(this.onlineStateTimer === null, "onlineStateTimer shouldn't be started yet");
                this.onlineStateTimer = this.asyncQueue.enqueueAfterDelay(TimerId.OnlineStateTimeout, ONLINE_STATE_TIMEOUT_MS, function () {
                    _this.onlineStateTimer = null;
                    assert(_this.state === OnlineState.Unknown, 'Timer should be canceled if we transitioned to a different state.');

                    _this.logClientOfflineWarningIfNecessary("Backend didn't respond within " + ONLINE_STATE_TIMEOUT_MS / 1000 + " " + "seconds.");

                    _this.setAndBroadcast(OnlineState.Offline);

                    return Promise.resolve();
                });
            }
        };

        OnlineStateTracker.prototype.handleWatchStreamFailure = function (error$$1) {
            if (this.state === OnlineState.Online) {
                this.setAndBroadcast(OnlineState.Unknown);
                assert(this.watchStreamFailures === 0, 'watchStreamFailures must be 0');
                assert(this.onlineStateTimer === null, 'onlineStateTimer must be null');
            } else {
                this.watchStreamFailures++;

                if (this.watchStreamFailures >= MAX_WATCH_STREAM_FAILURES) {
                    this.clearOnlineStateTimer();
                    this.logClientOfflineWarningIfNecessary("Connection failed " + MAX_WATCH_STREAM_FAILURES + " " + ("times. Most recent error: " + error$$1.toString()));
                    this.setAndBroadcast(OnlineState.Offline);
                }
            }
        };

        OnlineStateTracker.prototype.set = function (newState) {
            this.clearOnlineStateTimer();
            this.watchStreamFailures = 0;

            if (newState === OnlineState.Online) {
                this.shouldWarnClientIsOffline = false;
            }

            this.setAndBroadcast(newState);
        };

        OnlineStateTracker.prototype.setAndBroadcast = function (newState) {
            if (newState !== this.state) {
                this.state = newState;
                this.onlineStateHandler(newState);
            }
        };

        OnlineStateTracker.prototype.logClientOfflineWarningIfNecessary = function (details) {
            var message = "Could not reach Cloud Firestore backend. " + details + "\n" + "This typically indicates that your device does not have a healthy " + "Internet connection at the moment. The client will operate in offline " + "mode until it is able to successfully connect to the backend.";

            if (this.shouldWarnClientIsOffline) {
                error(message);
                this.shouldWarnClientIsOffline = false;
            } else {
                debug(LOG_TAG$7, message);
            }
        };

        OnlineStateTracker.prototype.clearOnlineStateTimer = function () {
            if (this.onlineStateTimer !== null) {
                this.onlineStateTimer.cancel();
                this.onlineStateTimer = null;
            }
        };

        return OnlineStateTracker;
    }();

    var LOG_TAG$8 = 'RemoteStore';
    var MAX_PENDING_WRITES = 10;

    var RemoteStore = function () {
        function RemoteStore(localStore, datastore, asyncQueue, onlineStateHandler) {
            this.localStore = localStore;
            this.datastore = datastore;
            this.writePipeline = [];
            this.listenTargets = {};
            this.watchChangeAggregator = null;
            this.networkEnabled = false;
            this.isPrimary = false;
            this.onlineStateTracker = new OnlineStateTracker(asyncQueue, onlineStateHandler);
            this.watchStream = this.datastore.newPersistentWatchStream({
                onOpen: this.onWatchStreamOpen.bind(this),
                onClose: this.onWatchStreamClose.bind(this),
                onWatchChange: this.onWatchStreamChange.bind(this)
            });
            this.writeStream = this.datastore.newPersistentWriteStream({
                onOpen: this.onWriteStreamOpen.bind(this),
                onClose: this.onWriteStreamClose.bind(this),
                onHandshakeComplete: this.onWriteHandshakeComplete.bind(this),
                onMutationResult: this.onMutationResult.bind(this)
            });
        }

        RemoteStore.prototype.start = function () {
            return this.enableNetwork();
        };

        RemoteStore.prototype.enableNetwork = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var _a;

                return tslib_1.__generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            this.networkEnabled = true;
                            if (!this.canUseNetwork()) return [3, 3];
                            _a = this.writeStream;
                            return [4, this.localStore.getLastStreamToken()];

                        case 1:
                            _a.lastStreamToken = _b.sent();

                            if (this.shouldStartWatchStream()) {
                                this.startWatchStream();
                            } else {
                                this.onlineStateTracker.set(OnlineState.Unknown);
                            }

                            return [4, this.fillWritePipeline()];

                        case 2:
                            _b.sent();

                            _b.label = 3;

                        case 3:
                            return [2];
                    }
                });
            });
        };

        RemoteStore.prototype.disableNetwork = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.networkEnabled = false;
                            return [4, this.disableNetworkInternal()];

                        case 1:
                            _a.sent();

                            this.onlineStateTracker.set(OnlineState.Offline);
                            return [2];
                    }
                });
            });
        };

        RemoteStore.prototype.disableNetworkInternal = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            return [4, this.writeStream.stop()];

                        case 1:
                            _a.sent();

                            return [4, this.watchStream.stop()];

                        case 2:
                            _a.sent();

                            if (this.writePipeline.length > 0) {
                                debug(LOG_TAG$8, "Stopping write stream with " + this.writePipeline.length + " pending writes");
                                this.writePipeline = [];
                            }

                            this.cleanUpWatchStreamState();
                            return [2];
                    }
                });
            });
        };

        RemoteStore.prototype.shutdown = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            debug(LOG_TAG$8, 'RemoteStore shutting down.');
                            this.networkEnabled = false;
                            return [4, this.disableNetworkInternal()];

                        case 1:
                            _a.sent();

                            this.onlineStateTracker.set(OnlineState.Unknown);
                            return [2];
                    }
                });
            });
        };

        RemoteStore.prototype.listen = function (queryData) {
            assert(!contains(this.listenTargets, queryData.targetId), 'listen called with duplicate targetId!');
            this.listenTargets[queryData.targetId] = queryData;

            if (this.shouldStartWatchStream()) {
                this.startWatchStream();
            } else if (this.watchStream.isOpen()) {
                this.sendWatchRequest(queryData);
            }
        };

        RemoteStore.prototype.unlisten = function (targetId) {
            assert(contains(this.listenTargets, targetId), 'unlisten called without assigned target ID!');
            delete this.listenTargets[targetId];

            if (this.watchStream.isOpen()) {
                this.sendUnwatchRequest(targetId);
            }

            if (isEmpty(this.listenTargets)) {
                if (this.watchStream.isOpen()) {
                    this.watchStream.markIdle();
                } else if (this.canUseNetwork()) {
                    this.onlineStateTracker.set(OnlineState.Unknown);
                }
            }
        };

        RemoteStore.prototype.getQueryDataForTarget = function (targetId) {
            return this.listenTargets[targetId] || null;
        };

        RemoteStore.prototype.getRemoteKeysForTarget = function (targetId) {
            return this.syncEngine.getRemoteKeysForTarget(targetId);
        };

        RemoteStore.prototype.sendWatchRequest = function (queryData) {
            this.watchChangeAggregator.recordPendingTargetRequest(queryData.targetId);
            this.watchStream.watch(queryData);
        };

        RemoteStore.prototype.sendUnwatchRequest = function (targetId) {
            this.watchChangeAggregator.recordPendingTargetRequest(targetId);
            this.watchStream.unwatch(targetId);
        };

        RemoteStore.prototype.startWatchStream = function () {
            assert(this.shouldStartWatchStream(), 'startWatchStream() called when shouldStartWatchStream() is false.');
            this.watchChangeAggregator = new WatchChangeAggregator(this);
            this.watchStream.start();
            this.onlineStateTracker.handleWatchStreamStart();
        };

        RemoteStore.prototype.shouldStartWatchStream = function () {
            return this.canUseNetwork() && !this.watchStream.isStarted() && !isEmpty(this.listenTargets);
        };

        RemoteStore.prototype.canUseNetwork = function () {
            return this.isPrimary && this.networkEnabled;
        };

        RemoteStore.prototype.cleanUpWatchStreamState = function () {
            this.watchChangeAggregator = null;
        };

        RemoteStore.prototype.onWatchStreamOpen = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var _this = this;

                return tslib_1.__generator(this, function (_a) {
                    forEachNumber(this.listenTargets, function (targetId, queryData) {
                        _this.sendWatchRequest(queryData);
                    });
                    return [2];
                });
            });
        };

        RemoteStore.prototype.onWatchStreamClose = function (error$$1) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                return tslib_1.__generator(this, function (_a) {
                    if (error$$1 === undefined) {
                        assert(!this.shouldStartWatchStream(), 'Watch stream was stopped gracefully while still needed.');
                    }

                    this.cleanUpWatchStreamState();

                    if (this.shouldStartWatchStream()) {
                        this.onlineStateTracker.handleWatchStreamFailure(error$$1);
                        this.startWatchStream();
                    } else {
                        this.onlineStateTracker.set(OnlineState.Unknown);
                    }

                    return [2];
                });
            });
        };

        RemoteStore.prototype.onWatchStreamChange = function (watchChange, snapshotVersion) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var lastRemoteSnapshotVersion;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.onlineStateTracker.set(OnlineState.Online);

                            if (watchChange instanceof WatchTargetChange && watchChange.state === WatchTargetChangeState.Removed && watchChange.cause) {
                                return [2, this.handleTargetError(watchChange)];
                            }

                            if (watchChange instanceof DocumentWatchChange) {
                                this.watchChangeAggregator.handleDocumentChange(watchChange);
                            } else if (watchChange instanceof ExistenceFilterChange) {
                                this.watchChangeAggregator.handleExistenceFilter(watchChange);
                            } else {
                                assert(watchChange instanceof WatchTargetChange, 'Expected watchChange to be an instance of WatchTargetChange');
                                this.watchChangeAggregator.handleTargetChange(watchChange);
                            }

                            if (!!snapshotVersion.isEqual(SnapshotVersion.MIN)) return [3, 3];
                            return [4, this.localStore.getLastRemoteSnapshotVersion()];

                        case 1:
                            lastRemoteSnapshotVersion = _a.sent();
                            if (!(snapshotVersion.compareTo(lastRemoteSnapshotVersion) >= 0)) return [3, 3];
                            return [4, this.raiseWatchSnapshot(snapshotVersion)];

                        case 2:
                            _a.sent();

                            _a.label = 3;

                        case 3:
                            return [2];
                    }
                });
            });
        };

        RemoteStore.prototype.raiseWatchSnapshot = function (snapshotVersion) {
            var _this = this;

            assert(!snapshotVersion.isEqual(SnapshotVersion.MIN), "Can't raise event for unknown SnapshotVersion");
            var remoteEvent = this.watchChangeAggregator.createRemoteEvent(snapshotVersion);
            forEachNumber(remoteEvent.targetChanges, function (targetId, change) {
                if (change.resumeToken.length > 0) {
                    var queryData = _this.listenTargets[targetId];

                    if (queryData) {
                        _this.listenTargets[targetId] = queryData.copy({
                            resumeToken: change.resumeToken,
                            snapshotVersion: snapshotVersion
                        });
                    }
                }
            });
            remoteEvent.targetMismatches.forEach(function (targetId) {
                var queryData = _this.listenTargets[targetId];

                if (!queryData) {
                    return;
                }

                _this.listenTargets[targetId] = queryData.copy({
                    resumeToken: emptyByteString()
                });

                _this.sendUnwatchRequest(targetId);

                var requestQueryData = new QueryData(queryData.query, targetId, QueryPurpose.ExistenceFilterMismatch, queryData.sequenceNumber);

                _this.sendWatchRequest(requestQueryData);
            });
            return this.syncEngine.applyRemoteEvent(remoteEvent);
        };

        RemoteStore.prototype.handleTargetError = function (watchChange) {
            var _this = this;

            assert(!!watchChange.cause, 'Handling target error without a cause');
            var error$$1 = watchChange.cause;
            var promiseChain = Promise.resolve();
            watchChange.targetIds.forEach(function (targetId) {
                promiseChain = promiseChain.then(function () {
                    return tslib_1.__awaiter(_this, void 0, void 0, function () {
                        return tslib_1.__generator(this, function (_a) {
                            if (contains(this.listenTargets, targetId)) {
                                delete this.listenTargets[targetId];
                                this.watchChangeAggregator.removeTarget(targetId);
                                return [2, this.syncEngine.rejectListen(targetId, error$$1)];
                            }

                            return [2];
                        });
                    });
                });
            });
            return promiseChain;
        };

        RemoteStore.prototype.fillWritePipeline = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var lastBatchIdRetrieved, batch;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.canAddToWritePipeline()) return [3, 4];
                            lastBatchIdRetrieved = this.writePipeline.length > 0 ? this.writePipeline[this.writePipeline.length - 1].batchId : BATCHID_UNKNOWN;
                            return [4, this.localStore.nextMutationBatch(lastBatchIdRetrieved)];

                        case 1:
                            batch = _a.sent();
                            if (!(batch === null)) return [3, 2];

                            if (this.writePipeline.length === 0) {
                                this.writeStream.markIdle();
                            }

                            return [3, 4];

                        case 2:
                            this.addToWritePipeline(batch);
                            return [4, this.fillWritePipeline()];

                        case 3:
                            _a.sent();

                            _a.label = 4;

                        case 4:
                            if (this.shouldStartWriteStream()) {
                                this.startWriteStream();
                            }

                            return [2];
                    }
                });
            });
        };

        RemoteStore.prototype.canAddToWritePipeline = function () {
            return this.canUseNetwork() && this.writePipeline.length < MAX_PENDING_WRITES;
        };

        RemoteStore.prototype.outstandingWrites = function () {
            return this.writePipeline.length;
        };

        RemoteStore.prototype.addToWritePipeline = function (batch) {
            assert(this.canAddToWritePipeline(), 'addToWritePipeline called when pipeline is full');
            this.writePipeline.push(batch);

            if (this.writeStream.isOpen() && this.writeStream.handshakeComplete) {
                this.writeStream.writeMutations(batch.mutations);
            }
        };

        RemoteStore.prototype.shouldStartWriteStream = function () {
            return this.canUseNetwork() && !this.writeStream.isStarted() && this.writePipeline.length > 0;
        };

        RemoteStore.prototype.startWriteStream = function () {
            assert(this.shouldStartWriteStream(), 'startWriteStream() called when shouldStartWriteStream() is false.');
            this.writeStream.start();
        };

        RemoteStore.prototype.onWriteStreamOpen = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                return tslib_1.__generator(this, function (_a) {
                    this.writeStream.writeHandshake();
                    return [2];
                });
            });
        };

        RemoteStore.prototype.onWriteHandshakeComplete = function () {
            var _this = this;

            return this.localStore.setLastStreamToken(this.writeStream.lastStreamToken).then(function () {
                for (var _i = 0, _a = _this.writePipeline; _i < _a.length; _i++) {
                    var batch = _a[_i];

                    _this.writeStream.writeMutations(batch.mutations);
                }
            }).catch(function (err) {
                return _this.ignoreIfPrimaryLeaseLoss(err);
            });
        };

        RemoteStore.prototype.ignoreIfPrimaryLeaseLoss = function (err) {
            if (isPrimaryLeaseLostError(err)) {
                debug(LOG_TAG$8, 'Unexpectedly lost primary lease');
            } else {
                throw err;
            }
        };

        RemoteStore.prototype.onMutationResult = function (commitVersion, results) {
            var _this = this;

            assert(this.writePipeline.length > 0, 'Got result for empty write pipeline');
            var batch = this.writePipeline.shift();
            var success = MutationBatchResult.from(batch, commitVersion, results, this.writeStream.lastStreamToken);
            return this.syncEngine.applySuccessfulWrite(success).then(function () {
                return _this.fillWritePipeline();
            });
        };

        RemoteStore.prototype.onWriteStreamClose = function (error$$1) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var _this = this;

                var errorHandling;
                return tslib_1.__generator(this, function (_a) {
                    if (error$$1 === undefined) {
                        assert(!this.shouldStartWriteStream(), 'Write stream was stopped gracefully while still needed.');
                    }

                    if (error$$1 && this.writePipeline.length > 0) {
                        errorHandling = void 0;

                        if (this.writeStream.handshakeComplete) {
                            errorHandling = this.handleWriteError(error$$1);
                        } else {
                            errorHandling = this.handleHandshakeError(error$$1);
                        }

                        return [2, errorHandling.then(function () {
                            if (_this.shouldStartWriteStream()) {
                                _this.startWriteStream();
                            }
                        })];
                    }

                    return [2];
                });
            });
        };

        RemoteStore.prototype.handleHandshakeError = function (error$$1) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var _this = this;

                return tslib_1.__generator(this, function (_a) {
                    if (isPermanentError(error$$1.code) || error$$1.code === Code.ABORTED) {
                        debug(LOG_TAG$8, 'RemoteStore error before completed handshake; resetting stream token: ', this.writeStream.lastStreamToken);
                        this.writeStream.lastStreamToken = emptyByteString();
                        return [2, this.localStore.setLastStreamToken(emptyByteString()).catch(function (err) {
                            return _this.ignoreIfPrimaryLeaseLoss(err);
                        })];
                    } else {}

                    return [2];
                });
            });
        };

        RemoteStore.prototype.handleWriteError = function (error$$1) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var _this = this;

                var batch;
                return tslib_1.__generator(this, function (_a) {
                    if (isPermanentError(error$$1.code)) {
                        batch = this.writePipeline.shift();
                        this.writeStream.inhibitBackoff();
                        return [2, this.syncEngine.rejectFailedWrite(batch.batchId, error$$1).then(function () {
                            return _this.fillWritePipeline();
                        })];
                    } else {}

                    return [2];
                });
            });
        };

        RemoteStore.prototype.createTransaction = function () {
            return new Transaction(this.datastore);
        };

        RemoteStore.prototype.handleCredentialChange = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.canUseNetwork()) return [3, 3];
                            debug(LOG_TAG$8, 'RemoteStore restarting streams for new credential');
                            this.networkEnabled = false;
                            return [4, this.disableNetworkInternal()];

                        case 1:
                            _a.sent();

                            this.onlineStateTracker.set(OnlineState.Unknown);
                            return [4, this.enableNetwork()];

                        case 2:
                            _a.sent();

                            _a.label = 3;

                        case 3:
                            return [2];
                    }
                });
            });
        };

        RemoteStore.prototype.applyPrimaryState = function (isPrimary) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.isPrimary = isPrimary;
                            if (!(isPrimary && this.networkEnabled)) return [3, 2];
                            return [4, this.enableNetwork()];

                        case 1:
                            _a.sent();

                            return [3, 4];

                        case 2:
                            if (!!isPrimary) return [3, 4];
                            return [4, this.disableNetworkInternal()];

                        case 3:
                            _a.sent();

                            this.onlineStateTracker.set(OnlineState.Unknown);
                            _a.label = 4;

                        case 4:
                            return [2];
                    }
                });
            });
        };

        return RemoteStore;
    }();

    var QueryListenersInfo = function () {
        function QueryListenersInfo() {
            this.listeners = [];
        }

        return QueryListenersInfo;
    }();

    var EventManager = function () {
        function EventManager(syncEngine) {
            this.syncEngine = syncEngine;
            this.queries = new ObjectMap(function (q) {
                return q.canonicalId();
            });
            this.onlineState = OnlineState.Unknown;
            this.syncEngine.subscribe(this);
        }

        EventManager.prototype.listen = function (listener) {
            var query = listener.query;
            var firstListen = false;
            var queryInfo = this.queries.get(query);

            if (!queryInfo) {
                firstListen = true;
                queryInfo = new QueryListenersInfo();
                this.queries.set(query, queryInfo);
            }

            queryInfo.listeners.push(listener);
            listener.applyOnlineStateChange(this.onlineState);
            if (queryInfo.viewSnap) listener.onViewSnapshot(queryInfo.viewSnap);

            if (firstListen) {
                return this.syncEngine.listen(query).then(function (targetId) {
                    queryInfo.targetId = targetId;
                    return targetId;
                });
            } else {
                return Promise.resolve(queryInfo.targetId);
            }
        };

        EventManager.prototype.unlisten = function (listener) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var query, lastListen, queryInfo, i;
                return tslib_1.__generator(this, function (_a) {
                    query = listener.query;
                    lastListen = false;
                    queryInfo = this.queries.get(query);

                    if (queryInfo) {
                        i = queryInfo.listeners.indexOf(listener);

                        if (i >= 0) {
                            queryInfo.listeners.splice(i, 1);
                            lastListen = queryInfo.listeners.length === 0;
                        }
                    }

                    if (lastListen) {
                        this.queries.delete(query);
                        return [2, this.syncEngine.unlisten(query)];
                    }

                    return [2];
                });
            });
        };

        EventManager.prototype.onWatchChange = function (viewSnaps) {
            for (var _i = 0, viewSnaps_1 = viewSnaps; _i < viewSnaps_1.length; _i++) {
                var viewSnap = viewSnaps_1[_i];
                var query = viewSnap.query;
                var queryInfo = this.queries.get(query);

                if (queryInfo) {
                    for (var _a = 0, _b = queryInfo.listeners; _a < _b.length; _a++) {
                        var listener = _b[_a];
                        listener.onViewSnapshot(viewSnap);
                    }

                    queryInfo.viewSnap = viewSnap;
                }
            }
        };

        EventManager.prototype.onWatchError = function (query, error) {
            var queryInfo = this.queries.get(query);

            if (queryInfo) {
                for (var _i = 0, _a = queryInfo.listeners; _i < _a.length; _i++) {
                    var listener = _a[_i];
                    listener.onError(error);
                }
            }

            this.queries.delete(query);
        };

        EventManager.prototype.onOnlineStateChange = function (onlineState) {
            this.onlineState = onlineState;
            this.queries.forEach(function (_, queryInfo) {
                for (var _i = 0, _a = queryInfo.listeners; _i < _a.length; _i++) {
                    var listener = _a[_i];
                    listener.applyOnlineStateChange(onlineState);
                }
            });
        };

        return EventManager;
    }();

    var QueryListener = function () {
        function QueryListener(query, queryObserver, options) {
            this.query = query;
            this.queryObserver = queryObserver;
            this.raisedInitialEvent = false;
            this.onlineState = OnlineState.Unknown;
            this.options = options || {};
        }

        QueryListener.prototype.onViewSnapshot = function (snap) {
            assert(snap.docChanges.length > 0 || snap.syncStateChanged, 'We got a new snapshot with no changes?');

            if (!this.options.includeMetadataChanges) {
                var docChanges = [];

                for (var _i = 0, _a = snap.docChanges; _i < _a.length; _i++) {
                    var docChange = _a[_i];

                    if (docChange.type !== ChangeType.Metadata) {
                        docChanges.push(docChange);
                    }
                }

                snap = new ViewSnapshot(snap.query, snap.docs, snap.oldDocs, docChanges, snap.mutatedKeys, snap.fromCache, snap.syncStateChanged, true);
            }

            if (!this.raisedInitialEvent) {
                if (this.shouldRaiseInitialEvent(snap, this.onlineState)) {
                    this.raiseInitialEvent(snap);
                }
            } else if (this.shouldRaiseEvent(snap)) {
                this.queryObserver.next(snap);
            }

            this.snap = snap;
        };

        QueryListener.prototype.onError = function (error) {
            this.queryObserver.error(error);
        };

        QueryListener.prototype.applyOnlineStateChange = function (onlineState) {
            this.onlineState = onlineState;

            if (this.snap && !this.raisedInitialEvent && this.shouldRaiseInitialEvent(this.snap, onlineState)) {
                this.raiseInitialEvent(this.snap);
            }
        };

        QueryListener.prototype.shouldRaiseInitialEvent = function (snap, onlineState) {
            assert(!this.raisedInitialEvent, 'Determining whether to raise first event but already had first event');

            if (!snap.fromCache) {
                return true;
            }

            var maybeOnline = onlineState !== OnlineState.Offline;

            if (this.options.waitForSyncWhenOnline && maybeOnline) {
                assert(snap.fromCache, 'Waiting for sync, but snapshot is not from cache');
                return false;
            }

            return !snap.docs.isEmpty() || onlineState === OnlineState.Offline;
        };

        QueryListener.prototype.shouldRaiseEvent = function (snap) {
            if (snap.docChanges.length > 0) {
                return true;
            }

            var hasPendingWritesChanged = this.snap && this.snap.hasPendingWrites !== snap.hasPendingWrites;

            if (snap.syncStateChanged || hasPendingWritesChanged) {
                return this.options.includeMetadataChanges === true;
            }

            return false;
        };

        QueryListener.prototype.raiseInitialEvent = function (snap) {
            assert(!this.raisedInitialEvent, 'Trying to raise initial events for second time');
            snap = ViewSnapshot.fromInitialDocuments(snap.query, snap.docs, snap.mutatedKeys, snap.fromCache);
            this.raisedInitialEvent = true;
            this.queryObserver.next(snap);
        };

        return QueryListener;
    }();

    var LocalViewChanges = function () {
        function LocalViewChanges(targetId, addedKeys, removedKeys) {
            this.targetId = targetId;
            this.addedKeys = addedKeys;
            this.removedKeys = removedKeys;
        }

        LocalViewChanges.fromSnapshot = function (targetId, viewSnapshot) {
            var addedKeys = documentKeySet();
            var removedKeys = documentKeySet();

            for (var _i = 0, _a = viewSnapshot.docChanges; _i < _a.length; _i++) {
                var docChange = _a[_i];

                switch (docChange.type) {
                    case ChangeType.Added:
                        addedKeys = addedKeys.add(docChange.doc.key);
                        break;

                    case ChangeType.Removed:
                        removedKeys = removedKeys.add(docChange.doc.key);
                        break;

                    default:}
            }

            return new LocalViewChanges(targetId, addedKeys, removedKeys);
        };

        return LocalViewChanges;
    }();

    var AddedLimboDocument = function () {
        function AddedLimboDocument(key) {
            this.key = key;
        }

        return AddedLimboDocument;
    }();

    var RemovedLimboDocument = function () {
        function RemovedLimboDocument(key) {
            this.key = key;
        }

        return RemovedLimboDocument;
    }();

    var View = function () {
        function View(query, _syncedDocuments) {
            this.query = query;
            this._syncedDocuments = _syncedDocuments;
            this.syncState = null;
            this.current = false;
            this.limboDocuments = documentKeySet();
            this.mutatedKeys = documentKeySet();
            this.documentSet = new DocumentSet(query.docComparator.bind(query));
        }

        Object.defineProperty(View.prototype, "syncedDocuments", {
            get: function get() {
                return this._syncedDocuments;
            },
            enumerable: true,
            configurable: true
        });

        View.prototype.computeDocChanges = function (docChanges, previousChanges) {
            var _this = this;

            var changeSet = previousChanges ? previousChanges.changeSet : new DocumentChangeSet();
            var oldDocumentSet = previousChanges ? previousChanges.documentSet : this.documentSet;
            var newMutatedKeys = previousChanges ? previousChanges.mutatedKeys : this.mutatedKeys;
            var newDocumentSet = oldDocumentSet;
            var needsRefill = false;
            var lastDocInLimit = this.query.hasLimit() && oldDocumentSet.size === this.query.limit ? oldDocumentSet.last() : null;
            docChanges.inorderTraversal(function (key, newMaybeDoc) {
                var oldDoc = oldDocumentSet.get(key);
                var newDoc = newMaybeDoc instanceof Document ? newMaybeDoc : null;

                if (newDoc) {
                    assert(key.isEqual(newDoc.key), 'Mismatching keys found in document changes: ' + key + ' != ' + newDoc.key);
                    newDoc = _this.query.matches(newDoc) ? newDoc : null;
                }

                var oldDocHadPendingMutations = oldDoc ? _this.mutatedKeys.has(oldDoc.key) : false;
                var newDocHasPendingMutations = newDoc ? newDoc.hasLocalMutations || _this.mutatedKeys.has(newDoc.key) && newDoc.hasCommittedMutations : false;
                var changeApplied = false;

                if (oldDoc && newDoc) {
                    var docsEqual = oldDoc.data.isEqual(newDoc.data);

                    if (!docsEqual) {
                        if (!_this.shouldWaitForSyncedDocument(oldDoc, newDoc)) {
                            changeSet.track({
                                type: ChangeType.Modified,
                                doc: newDoc
                            });
                            changeApplied = true;

                            if (lastDocInLimit && _this.query.docComparator(newDoc, lastDocInLimit) > 0) {
                                needsRefill = true;
                            }
                        }
                    } else if (oldDocHadPendingMutations !== newDocHasPendingMutations) {
                        changeSet.track({
                            type: ChangeType.Metadata,
                            doc: newDoc
                        });
                        changeApplied = true;
                    }
                } else if (!oldDoc && newDoc) {
                    changeSet.track({
                        type: ChangeType.Added,
                        doc: newDoc
                    });
                    changeApplied = true;
                } else if (oldDoc && !newDoc) {
                    changeSet.track({
                        type: ChangeType.Removed,
                        doc: oldDoc
                    });
                    changeApplied = true;

                    if (lastDocInLimit) {
                        needsRefill = true;
                    }
                }

                if (changeApplied) {
                    if (newDoc) {
                        newDocumentSet = newDocumentSet.add(newDoc);

                        if (newDocHasPendingMutations) {
                            newMutatedKeys = newMutatedKeys.add(key);
                        } else {
                            newMutatedKeys = newMutatedKeys.delete(key);
                        }
                    } else {
                        newDocumentSet = newDocumentSet.delete(key);
                        newMutatedKeys = newMutatedKeys.delete(key);
                    }
                }
            });

            if (this.query.hasLimit()) {
                while (newDocumentSet.size > this.query.limit) {
                    var oldDoc = newDocumentSet.last();
                    newDocumentSet = newDocumentSet.delete(oldDoc.key);
                    newMutatedKeys = newMutatedKeys.delete(oldDoc.key);
                    changeSet.track({
                        type: ChangeType.Removed,
                        doc: oldDoc
                    });
                }
            }

            assert(!needsRefill || !previousChanges, 'View was refilled using docs that themselves needed refilling.');
            return {
                documentSet: newDocumentSet,
                changeSet: changeSet,
                needsRefill: needsRefill,
                mutatedKeys: newMutatedKeys
            };
        };

        View.prototype.shouldWaitForSyncedDocument = function (oldDoc, newDoc) {
            return oldDoc.hasLocalMutations && newDoc.hasCommittedMutations && !newDoc.hasLocalMutations;
        };

        View.prototype.applyChanges = function (docChanges, updateLimboDocuments, targetChange) {
            var _this = this;

            assert(!docChanges.needsRefill, 'Cannot apply changes that need a refill');
            var oldDocs = this.documentSet;
            this.documentSet = docChanges.documentSet;
            this.mutatedKeys = docChanges.mutatedKeys;
            var changes = docChanges.changeSet.getChanges();
            changes.sort(function (c1, c2) {
                return compareChangeType(c1.type, c2.type) || _this.query.docComparator(c1.doc, c2.doc);
            });
            this.applyTargetChange(targetChange);
            var limboChanges = updateLimboDocuments ? this.updateLimboDocuments() : [];
            var synced = this.limboDocuments.size === 0 && this.current;
            var newSyncState = synced ? SyncState.Synced : SyncState.Local;
            var syncStateChanged = newSyncState !== this.syncState;
            this.syncState = newSyncState;

            if (changes.length === 0 && !syncStateChanged) {
                return {
                    limboChanges: limboChanges
                };
            } else {
                var snap = new ViewSnapshot(this.query, docChanges.documentSet, oldDocs, changes, docChanges.mutatedKeys, newSyncState === SyncState.Local, syncStateChanged, false);
                return {
                    snapshot: snap,
                    limboChanges: limboChanges
                };
            }
        };

        View.prototype.applyOnlineStateChange = function (onlineState) {
            if (this.current && onlineState === OnlineState.Offline) {
                this.current = false;
                return this.applyChanges({
                    documentSet: this.documentSet,
                    changeSet: new DocumentChangeSet(),
                    mutatedKeys: this.mutatedKeys,
                    needsRefill: false
                }, false);
            } else {
                return {
                    limboChanges: []
                };
            }
        };

        View.prototype.shouldBeInLimbo = function (key) {
            if (this._syncedDocuments.has(key)) {
                return false;
            }

            if (!this.documentSet.has(key)) {
                return false;
            }

            if (this.documentSet.get(key).hasLocalMutations) {
                return false;
            }

            return true;
        };

        View.prototype.applyTargetChange = function (targetChange) {
            var _this = this;

            if (targetChange) {
                targetChange.addedDocuments.forEach(function (key) {
                    return _this._syncedDocuments = _this._syncedDocuments.add(key);
                });
                targetChange.modifiedDocuments.forEach(function (key) {
                    return assert(_this._syncedDocuments.has(key), "Modified document " + key + " not found in view.");
                });
                targetChange.removedDocuments.forEach(function (key) {
                    return _this._syncedDocuments = _this._syncedDocuments.delete(key);
                });
                this.current = targetChange.current;
            }
        };

        View.prototype.updateLimboDocuments = function () {
            var _this = this;

            if (!this.current) {
                return [];
            }

            var oldLimboDocuments = this.limboDocuments;
            this.limboDocuments = documentKeySet();
            this.documentSet.forEach(function (doc) {
                if (_this.shouldBeInLimbo(doc.key)) {
                    _this.limboDocuments = _this.limboDocuments.add(doc.key);
                }
            });
            var changes = [];
            oldLimboDocuments.forEach(function (key) {
                if (!_this.limboDocuments.has(key)) {
                    changes.push(new RemovedLimboDocument(key));
                }
            });
            this.limboDocuments.forEach(function (key) {
                if (!oldLimboDocuments.has(key)) {
                    changes.push(new AddedLimboDocument(key));
                }
            });
            return changes;
        };

        View.prototype.synchronizeWithPersistedState = function (localDocs, remoteKeys) {
            this._syncedDocuments = remoteKeys;
            this.limboDocuments = documentKeySet();
            var docChanges = this.computeDocChanges(localDocs);
            return this.applyChanges(docChanges, true);
        };

        View.prototype.computeInitialSnapshot = function () {
            return ViewSnapshot.fromInitialDocuments(this.query, this.documentSet, this.mutatedKeys, this.syncState === SyncState.Local);
        };

        return View;
    }();

    function compareChangeType(c1, c2) {
        var order = function order(change) {
            switch (change) {
                case ChangeType.Added:
                    return 1;

                case ChangeType.Modified:
                    return 2;

                case ChangeType.Metadata:
                    return 2;

                case ChangeType.Removed:
                    return 0;

                default:
                    return fail('Unknown ChangeType: ' + change);
            }
        };

        return order(c1) - order(c2);
    }

    var LOG_TAG$9 = 'SyncEngine';

    var QueryView = function () {
        function QueryView(query, targetId, view) {
            this.query = query;
            this.targetId = targetId;
            this.view = view;
        }

        return QueryView;
    }();

    var LimboResolution = function () {
        function LimboResolution(key) {
            this.key = key;
        }

        return LimboResolution;
    }();

    var SyncEngine = function () {
        function SyncEngine(localStore, remoteStore, sharedClientState, currentUser) {
            this.localStore = localStore;
            this.remoteStore = remoteStore;
            this.sharedClientState = sharedClientState;
            this.currentUser = currentUser;
            this.syncEngineListener = null;
            this.queryViewsByQuery = new ObjectMap(function (q) {
                return q.canonicalId();
            });
            this.queryViewsByTarget = {};
            this.limboTargetsByKey = new SortedMap(DocumentKey.comparator);
            this.limboResolutionsByTarget = {};
            this.limboDocumentRefs = new ReferenceSet();
            this.mutationUserCallbacks = {};
            this.limboTargetIdGenerator = TargetIdGenerator.forSyncEngine();
            this.isPrimary = undefined;
            this.onlineState = OnlineState.Unknown;
        }

        Object.defineProperty(SyncEngine.prototype, "isPrimaryClient", {
            get: function get() {
                return this.isPrimary === true;
            },
            enumerable: true,
            configurable: true
        });

        SyncEngine.prototype.subscribe = function (syncEngineListener) {
            assert(syncEngineListener !== null, 'SyncEngine listener cannot be null');
            assert(this.syncEngineListener === null, 'SyncEngine already has a subscriber.');
            this.syncEngineListener = syncEngineListener;
        };

        SyncEngine.prototype.listen = function (query) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var targetId, viewSnapshot, queryView, queryData, status_1;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.assertSubscribed('listen()');
                            queryView = this.queryViewsByQuery.get(query);
                            if (!queryView) return [3, 1];
                            targetId = queryView.targetId;
                            this.sharedClientState.addLocalQueryTarget(targetId);
                            viewSnapshot = queryView.view.computeInitialSnapshot();
                            return [3, 4];

                        case 1:
                            return [4, this.localStore.allocateQuery(query)];

                        case 2:
                            queryData = _a.sent();
                            status_1 = this.sharedClientState.addLocalQueryTarget(queryData.targetId);
                            targetId = queryData.targetId;
                            return [4, this.initializeViewAndComputeSnapshot(queryData, status_1 === 'current')];

                        case 3:
                            viewSnapshot = _a.sent();

                            if (this.isPrimary) {
                                this.remoteStore.listen(queryData);
                            }

                            _a.label = 4;

                        case 4:
                            this.syncEngineListener.onWatchChange([viewSnapshot]);
                            return [2, targetId];
                    }
                });
            });
        };

        SyncEngine.prototype.initializeViewAndComputeSnapshot = function (queryData, current) {
            var _this = this;

            var query = queryData.query;
            return this.localStore.executeQuery(query).then(function (docs) {
                return _this.localStore.remoteDocumentKeys(queryData.targetId).then(function (remoteKeys) {
                    var view = new View(query, remoteKeys);
                    var viewDocChanges = view.computeDocChanges(docs);
                    var synthesizedTargetChange = TargetChange.createSynthesizedTargetChangeForCurrentChange(queryData.targetId, current && _this.onlineState !== OnlineState.Offline);
                    var viewChange = view.applyChanges(viewDocChanges, _this.isPrimary === true, synthesizedTargetChange);
                    assert(viewChange.limboChanges.length === 0, 'View returned limbo docs before target ack from the server.');
                    assert(!!viewChange.snapshot, 'applyChanges for new view should always return a snapshot');
                    var data = new QueryView(query, queryData.targetId, view);

                    _this.queryViewsByQuery.set(query, data);

                    _this.queryViewsByTarget[queryData.targetId] = data;
                    return viewChange.snapshot;
                });
            });
        };

        SyncEngine.prototype.synchronizeViewAndComputeSnapshot = function (queryView) {
            var _this = this;

            return this.localStore.executeQuery(queryView.query).then(function (docs) {
                return _this.localStore.remoteDocumentKeys(queryView.targetId).then(function (remoteKeys) {
                    return tslib_1.__awaiter(_this, void 0, void 0, function () {
                        var viewSnapshot;
                        return tslib_1.__generator(this, function (_a) {
                            viewSnapshot = queryView.view.synchronizeWithPersistedState(docs, remoteKeys);

                            if (this.isPrimary) {
                                this.updateTrackedLimbos(queryView.targetId, viewSnapshot.limboChanges);
                            }

                            return [2, viewSnapshot];
                        });
                    });
                });
            });
        };

        SyncEngine.prototype.unlisten = function (query) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var _this = this;

                var queryView, targetRemainsActive;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.assertSubscribed('unlisten()');
                            queryView = this.queryViewsByQuery.get(query);
                            assert(!!queryView, 'Trying to unlisten on query not found:' + query);
                            if (!this.isPrimary) return [3, 3];
                            this.sharedClientState.removeLocalQueryTarget(queryView.targetId);
                            targetRemainsActive = this.sharedClientState.isActiveQueryTarget(queryView.targetId);
                            if (!!targetRemainsActive) return [3, 2];
                            return [4, this.localStore.releaseQuery(query, false).then(function () {
                                _this.sharedClientState.clearQueryState(queryView.targetId);

                                _this.remoteStore.unlisten(queryView.targetId);

                                _this.removeAndCleanupQuery(queryView);
                            }).catch(function (err) {
                                return _this.ignoreIfPrimaryLeaseLoss(err);
                            })];

                        case 1:
                            _a.sent();

                            _a.label = 2;

                        case 2:
                            return [3, 5];

                        case 3:
                            this.removeAndCleanupQuery(queryView);
                            return [4, this.localStore.releaseQuery(query, true)];

                        case 4:
                            _a.sent();

                            _a.label = 5;

                        case 5:
                            return [2];
                    }
                });
            });
        };

        SyncEngine.prototype.write = function (batch, userCallback) {
            var _this = this;

            this.assertSubscribed('write()');
            return this.localStore.localWrite(batch).then(function (result) {
                _this.sharedClientState.addPendingMutation(result.batchId);

                _this.addMutationCallback(result.batchId, userCallback);

                return _this.emitNewSnapsAndNotifyLocalStore(result.changes);
            }).then(function () {
                return _this.remoteStore.fillWritePipeline();
            });
        };

        SyncEngine.prototype.wrapUpdateFunctionError = function (error$$1) {
            return error$$1;
        };

        SyncEngine.prototype.runTransaction = function (updateFunction, retries) {
            var _this = this;

            if (retries === void 0) {
                retries = 5;
            }

            assert(retries >= 0, 'Got negative number of retries for transaction.');
            var transaction = this.remoteStore.createTransaction();

            var wrappedUpdateFunction = function wrappedUpdateFunction() {
                try {
                    var userPromise = updateFunction(transaction);

                    if (isNullOrUndefined(userPromise) || !userPromise.catch || !userPromise.then) {
                        return Promise.reject(Error('Transaction callback must return a Promise'));
                    }

                    return userPromise.catch(function (e) {
                        return Promise.reject(_this.wrapUpdateFunctionError(e));
                    });
                } catch (e) {
                    return Promise.reject(_this.wrapUpdateFunctionError(e));
                }
            };

            return wrappedUpdateFunction().then(function (result) {
                return transaction.commit().then(function () {
                    return result;
                }).catch(function (error$$1) {
                    if (retries === 0) {
                        return Promise.reject(error$$1);
                    }

                    return _this.runTransaction(updateFunction, retries - 1);
                });
            });
        };

        SyncEngine.prototype.applyRemoteEvent = function (remoteEvent) {
            var _this = this;

            this.assertSubscribed('applyRemoteEvent()');
            return this.localStore.applyRemoteEvent(remoteEvent).then(function (changes) {
                forEach(remoteEvent.targetChanges, function (targetId, targetChange) {
                    var limboResolution = _this.limboResolutionsByTarget[targetId];

                    if (limboResolution) {
                        assert(targetChange.addedDocuments.size + targetChange.modifiedDocuments.size + targetChange.removedDocuments.size <= 1, 'Limbo resolution for single document contains multiple changes.');

                        if (targetChange.addedDocuments.size > 0) {
                            limboResolution.receivedDocument = true;
                        } else if (targetChange.modifiedDocuments.size > 0) {
                            assert(limboResolution.receivedDocument, 'Received change for limbo target document without add.');
                        } else if (targetChange.removedDocuments.size > 0) {
                            assert(limboResolution.receivedDocument, 'Received remove for limbo target document without add.');
                            limboResolution.receivedDocument = false;
                        } else {}
                    }
                });
                return _this.emitNewSnapsAndNotifyLocalStore(changes, remoteEvent);
            }).catch(function (err) {
                return _this.ignoreIfPrimaryLeaseLoss(err);
            });
        };

        SyncEngine.prototype.applyOnlineStateChange = function (onlineState, source) {
            if (this.isPrimary && source === OnlineStateSource.RemoteStore || !this.isPrimary && source === OnlineStateSource.SharedClientState) {
                var newViewSnapshots_1 = [];
                this.queryViewsByQuery.forEach(function (query, queryView) {
                    var viewChange = queryView.view.applyOnlineStateChange(onlineState);
                    assert(viewChange.limboChanges.length === 0, 'OnlineState should not affect limbo documents.');

                    if (viewChange.snapshot) {
                        newViewSnapshots_1.push(viewChange.snapshot);
                    }
                });
                this.syncEngineListener.onOnlineStateChange(onlineState);
                this.syncEngineListener.onWatchChange(newViewSnapshots_1);
                this.onlineState = onlineState;

                if (this.isPrimary) {
                    this.sharedClientState.setOnlineState(onlineState);
                }
            }
        };

        SyncEngine.prototype.rejectListen = function (targetId, err) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var _this = this;

                var limboResolution, limboKey, documentUpdates, resolvedLimboDocuments, event_1, queryView_1;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.assertSubscribed('rejectListens()');
                            this.sharedClientState.updateQueryState(targetId, 'rejected', err);
                            limboResolution = this.limboResolutionsByTarget[targetId];
                            limboKey = limboResolution && limboResolution.key;
                            if (!limboKey) return [3, 1];
                            this.limboTargetsByKey = this.limboTargetsByKey.remove(limboKey);
                            delete this.limboResolutionsByTarget[targetId];
                            documentUpdates = new SortedMap(DocumentKey.comparator);
                            documentUpdates = documentUpdates.insert(limboKey, new NoDocument(limboKey, SnapshotVersion.forDeletedDoc()));
                            resolvedLimboDocuments = documentKeySet().add(limboKey);
                            event_1 = new RemoteEvent(SnapshotVersion.MIN, {}, new SortedSet(primitiveComparator), documentUpdates, resolvedLimboDocuments);
                            return [2, this.applyRemoteEvent(event_1)];

                        case 1:
                            queryView_1 = this.queryViewsByTarget[targetId];
                            assert(!!queryView_1, 'Unknown targetId: ' + targetId);
                            return [4, this.localStore.releaseQuery(queryView_1.query, false).then(function () {
                                return _this.removeAndCleanupQuery(queryView_1);
                            }).catch(function (err) {
                                return _this.ignoreIfPrimaryLeaseLoss(err);
                            })];

                        case 2:
                            _a.sent();

                            this.syncEngineListener.onWatchError(queryView_1.query, err);
                            _a.label = 3;

                        case 3:
                            return [2];
                    }
                });
            });
        };

        SyncEngine.prototype.applyBatchState = function (batchId, batchState, error$$1) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var documents;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.assertSubscribed('applyBatchState()');
                            return [4, this.localStore.lookupMutationDocuments(batchId)];

                        case 1:
                            documents = _a.sent();

                            if (documents === null) {
                                debug(LOG_TAG$9, 'Cannot apply mutation batch with id: ' + batchId);
                                return [2];
                            }

                            if (!(batchState === 'pending')) return [3, 3];
                            return [4, this.remoteStore.fillWritePipeline()];

                        case 2:
                            _a.sent();

                            return [3, 4];

                        case 3:
                            if (batchState === 'acknowledged' || batchState === 'rejected') {
                                this.processUserCallback(batchId, error$$1 ? error$$1 : null);
                                this.localStore.removeCachedMutationBatchMetadata(batchId);
                            } else {
                                fail("Unknown batchState: " + batchState);
                            }

                            _a.label = 4;

                        case 4:
                            return [4, this.emitNewSnapsAndNotifyLocalStore(documents)];

                        case 5:
                            _a.sent();

                            return [2];
                    }
                });
            });
        };

        SyncEngine.prototype.applySuccessfulWrite = function (mutationBatchResult) {
            var _this = this;

            this.assertSubscribed('applySuccessfulWrite()');
            var batchId = mutationBatchResult.batch.batchId;
            this.processUserCallback(batchId, null);
            return this.localStore.acknowledgeBatch(mutationBatchResult).then(function (changes) {
                _this.sharedClientState.updateMutationState(batchId, 'acknowledged');

                return _this.emitNewSnapsAndNotifyLocalStore(changes);
            }).catch(function (err) {
                return _this.ignoreIfPrimaryLeaseLoss(err);
            });
        };

        SyncEngine.prototype.rejectFailedWrite = function (batchId, error$$1) {
            var _this = this;

            this.assertSubscribed('rejectFailedWrite()');
            this.processUserCallback(batchId, error$$1);
            return this.localStore.rejectBatch(batchId).then(function (changes) {
                _this.sharedClientState.updateMutationState(batchId, 'rejected', error$$1);

                return _this.emitNewSnapsAndNotifyLocalStore(changes);
            }).catch(function (err) {
                return _this.ignoreIfPrimaryLeaseLoss(err);
            });
        };

        SyncEngine.prototype.addMutationCallback = function (batchId, callback) {
            var newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];

            if (!newCallbacks) {
                newCallbacks = new SortedMap(primitiveComparator);
            }

            newCallbacks = newCallbacks.insert(batchId, callback);
            this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;
        };

        SyncEngine.prototype.processUserCallback = function (batchId, error$$1) {
            var newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];

            if (newCallbacks) {
                var callback = newCallbacks.get(batchId);

                if (callback) {
                    assert(batchId === newCallbacks.minKey(), 'Mutation callbacks processed out-of-order?');

                    if (error$$1) {
                        callback.reject(error$$1);
                    } else {
                        callback.resolve();
                    }

                    newCallbacks = newCallbacks.remove(batchId);
                }

                this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;
            }
        };

        SyncEngine.prototype.removeAndCleanupQuery = function (queryView) {
            var _this = this;

            this.sharedClientState.removeLocalQueryTarget(queryView.targetId);
            this.queryViewsByQuery.delete(queryView.query);
            delete this.queryViewsByTarget[queryView.targetId];

            if (this.isPrimary) {
                var limboKeys = this.limboDocumentRefs.referencesForId(queryView.targetId);
                this.limboDocumentRefs.removeReferencesForId(queryView.targetId);
                limboKeys.forEach(function (limboKey) {
                    var isReferenced = _this.limboDocumentRefs.containsKey(limboKey);

                    if (!isReferenced) {
                        _this.removeLimboTarget(limboKey);
                    }
                });
            }
        };

        SyncEngine.prototype.removeLimboTarget = function (key) {
            var limboTargetId = this.limboTargetsByKey.get(key);

            if (limboTargetId === null) {
                return;
            }

            this.remoteStore.unlisten(limboTargetId);
            this.limboTargetsByKey = this.limboTargetsByKey.remove(key);
            delete this.limboResolutionsByTarget[limboTargetId];
        };

        SyncEngine.prototype.updateTrackedLimbos = function (targetId, limboChanges) {
            for (var _i = 0, limboChanges_1 = limboChanges; _i < limboChanges_1.length; _i++) {
                var limboChange = limboChanges_1[_i];

                if (limboChange instanceof AddedLimboDocument) {
                    this.limboDocumentRefs.addReference(limboChange.key, targetId);
                    this.trackLimboChange(limboChange);
                } else if (limboChange instanceof RemovedLimboDocument) {
                    debug(LOG_TAG$9, 'Document no longer in limbo: ' + limboChange.key);
                    this.limboDocumentRefs.removeReference(limboChange.key, targetId);
                    var isReferenced = this.limboDocumentRefs.containsKey(limboChange.key);

                    if (!isReferenced) {
                        this.removeLimboTarget(limboChange.key);
                    }
                } else {
                    fail('Unknown limbo change: ' + JSON.stringify(limboChange));
                }
            }
        };

        SyncEngine.prototype.trackLimboChange = function (limboChange) {
            var key = limboChange.key;

            if (!this.limboTargetsByKey.get(key)) {
                debug(LOG_TAG$9, 'New document in limbo: ' + key);
                var limboTargetId = this.limboTargetIdGenerator.next();
                var query = Query.atPath(key.path);
                this.limboResolutionsByTarget[limboTargetId] = new LimboResolution(key);
                this.remoteStore.listen(new QueryData(query, limboTargetId, QueryPurpose.LimboResolution, ListenSequence.INVALID));
                this.limboTargetsByKey = this.limboTargetsByKey.insert(key, limboTargetId);
            }
        };

        SyncEngine.prototype.currentLimboDocs = function () {
            return this.limboTargetsByKey;
        };

        SyncEngine.prototype.emitNewSnapsAndNotifyLocalStore = function (changes, remoteEvent) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var _this = this;

                var newSnaps, docChangesInAllViews, queriesProcessed;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            newSnaps = [];
                            docChangesInAllViews = [];
                            queriesProcessed = [];
                            this.queryViewsByQuery.forEach(function (_, queryView) {
                                queriesProcessed.push(Promise.resolve().then(function () {
                                    var viewDocChanges = queryView.view.computeDocChanges(changes);

                                    if (!viewDocChanges.needsRefill) {
                                        return viewDocChanges;
                                    }

                                    return _this.localStore.executeQuery(queryView.query).then(function (docs) {
                                        return queryView.view.computeDocChanges(docs, viewDocChanges);
                                    });
                                }).then(function (viewDocChanges) {
                                    var targetChange = remoteEvent && remoteEvent.targetChanges[queryView.targetId];
                                    var viewChange = queryView.view.applyChanges(viewDocChanges, _this.isPrimary === true, targetChange);

                                    _this.updateTrackedLimbos(queryView.targetId, viewChange.limboChanges);

                                    if (viewChange.snapshot) {
                                        if (_this.isPrimary) {
                                            _this.sharedClientState.updateQueryState(queryView.targetId, viewChange.snapshot.fromCache ? 'not-current' : 'current');
                                        }

                                        newSnaps.push(viewChange.snapshot);
                                        var docChanges = LocalViewChanges.fromSnapshot(queryView.targetId, viewChange.snapshot);
                                        docChangesInAllViews.push(docChanges);
                                    }
                                }));
                            });
                            return [4, Promise.all(queriesProcessed)];

                        case 1:
                            _a.sent();

                            this.syncEngineListener.onWatchChange(newSnaps);
                            return [4, this.localStore.notifyLocalViewChanges(docChangesInAllViews)];

                        case 2:
                            _a.sent();

                            return [2];
                    }
                });
            });
        };

        SyncEngine.prototype.ignoreIfPrimaryLeaseLoss = function (err) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                return tslib_1.__generator(this, function (_a) {
                    if (isPrimaryLeaseLostError(err)) {
                        debug(LOG_TAG$9, 'Unexpectedly lost primary lease');
                    } else {
                        throw err;
                    }

                    return [2];
                });
            });
        };

        SyncEngine.prototype.assertSubscribed = function (fnName) {
            assert(this.syncEngineListener !== null, 'Trying to call ' + fnName + ' before calling subscribe().');
        };

        SyncEngine.prototype.handleCredentialChange = function (user) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var userChanged, result;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            userChanged = !this.currentUser.isEqual(user);
                            this.currentUser = user;
                            if (!userChanged) return [3, 3];
                            return [4, this.localStore.handleUserChange(user)];

                        case 1:
                            result = _a.sent();
                            this.sharedClientState.handleUserChange(user, result.removedBatchIds, result.addedBatchIds);
                            return [4, this.emitNewSnapsAndNotifyLocalStore(result.affectedDocuments)];

                        case 2:
                            _a.sent();

                            _a.label = 3;

                        case 3:
                            return [4, this.remoteStore.handleCredentialChange()];

                        case 4:
                            _a.sent();

                            return [2];
                    }
                });
            });
        };

        SyncEngine.prototype.applyPrimaryState = function (isPrimary) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var _this = this;

                var activeTargets, activeQueries, _i, activeQueries_1, queryData, activeTargets_1, p_1;

                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!(isPrimary === true && this.isPrimary !== true)) return [3, 3];
                            this.isPrimary = true;
                            return [4, this.remoteStore.applyPrimaryState(true)];

                        case 1:
                            _a.sent();

                            activeTargets = this.sharedClientState.getAllActiveQueryTargets();
                            return [4, this.synchronizeQueryViewsAndRaiseSnapshots(activeTargets.toArray())];

                        case 2:
                            activeQueries = _a.sent();

                            for (_i = 0, activeQueries_1 = activeQueries; _i < activeQueries_1.length; _i++) {
                                queryData = activeQueries_1[_i];
                                this.remoteStore.listen(queryData);
                            }

                            return [3, 7];

                        case 3:
                            if (!(isPrimary === false && this.isPrimary !== false)) return [3, 7];
                            this.isPrimary = false;
                            activeTargets_1 = [];
                            p_1 = Promise.resolve();
                            forEachNumber(this.queryViewsByTarget, function (targetId, queryView) {
                                if (_this.sharedClientState.isLocalQueryTarget(targetId)) {
                                    activeTargets_1.push(targetId);
                                } else {
                                    p_1 = p_1.then(function () {
                                        return _this.unlisten(queryView.query);
                                    });
                                }

                                _this.remoteStore.unlisten(queryView.targetId);
                            });
                            return [4, p_1];

                        case 4:
                            _a.sent();

                            return [4, this.synchronizeQueryViewsAndRaiseSnapshots(activeTargets_1)];

                        case 5:
                            _a.sent();

                            this.resetLimboDocuments();
                            return [4, this.remoteStore.applyPrimaryState(false)];

                        case 6:
                            _a.sent();

                            _a.label = 7;

                        case 7:
                            return [2];
                    }
                });
            });
        };

        SyncEngine.prototype.resetLimboDocuments = function () {
            var _this = this;

            forEachNumber(this.limboResolutionsByTarget, function (targetId) {
                _this.remoteStore.unlisten(targetId);
            });
            this.limboDocumentRefs.removeAllReferences();
            this.limboResolutionsByTarget = [];
            this.limboTargetsByKey = new SortedMap(DocumentKey.comparator);
        };

        SyncEngine.prototype.synchronizeQueryViewsAndRaiseSnapshots = function (targets) {
            var _this = this;

            var p = Promise.resolve();
            var activeQueries = [];
            var newViewSnapshots = [];

            var _loop_1 = function _loop_1(targetId) {
                p = p.then(function () {
                    return tslib_1.__awaiter(_this, void 0, void 0, function () {
                        var queryData, queryView, viewChange, query;
                        return tslib_1.__generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    queryView = this.queryViewsByTarget[targetId];
                                    if (!queryView) return [3, 4];
                                    return [4, this.localStore.releaseQuery(queryView.query, true)];

                                case 1:
                                    _a.sent();

                                    return [4, this.localStore.allocateQuery(queryView.query)];

                                case 2:
                                    queryData = _a.sent();
                                    return [4, this.synchronizeViewAndComputeSnapshot(queryView)];

                                case 3:
                                    viewChange = _a.sent();

                                    if (viewChange.snapshot) {
                                        newViewSnapshots.push(viewChange.snapshot);
                                    }

                                    return [3, 8];

                                case 4:
                                    assert(this.isPrimary === true, 'A secondary tab should never have an active query without an active view.');
                                    return [4, this.localStore.getQueryForTarget(targetId)];

                                case 5:
                                    query = _a.sent();
                                    assert(!!query, "Query data for target " + targetId + " not found");
                                    return [4, this.localStore.allocateQuery(query)];

                                case 6:
                                    queryData = _a.sent();
                                    return [4, this.initializeViewAndComputeSnapshot(queryData, false)];

                                case 7:
                                    _a.sent();

                                    _a.label = 8;

                                case 8:
                                    activeQueries.push(queryData);
                                    return [2];
                            }
                        });
                    });
                });
            };

            for (var _i = 0, targets_1 = targets; _i < targets_1.length; _i++) {
                var targetId = targets_1[_i];

                _loop_1(targetId);
            }

            return p.then(function () {
                _this.syncEngineListener.onWatchChange(newViewSnapshots);

                return activeQueries;
            });
        };

        SyncEngine.prototype.getActiveClients = function () {
            return this.localStore.getActiveClients();
        };

        SyncEngine.prototype.applyTargetState = function (targetId, state, error$$1) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var _this = this;

                var _a, queryView;

                return tslib_1.__generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (this.isPrimary) {
                                debug(LOG_TAG$9, 'Ignoring unexpected query state notification.');
                                return [2];
                            }

                            if (!this.queryViewsByTarget[targetId]) return [3, 5];
                            _a = state;

                            switch (_a) {
                                case 'current':
                                    return [3, 1];

                                case 'not-current':
                                    return [3, 1];

                                case 'rejected':
                                    return [3, 2];
                            }

                            return [3, 4];

                        case 1:
                            {
                                return [2, this.localStore.getNewDocumentChanges().then(function (changes) {
                                    return tslib_1.__awaiter(_this, void 0, void 0, function () {
                                        var synthesizedRemoteEvent;
                                        return tslib_1.__generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    synthesizedRemoteEvent = RemoteEvent.createSynthesizedRemoteEventForCurrentChange(targetId, state === 'current');
                                                    return [4, this.emitNewSnapsAndNotifyLocalStore(changes, synthesizedRemoteEvent)];

                                                case 1:
                                                    _a.sent();

                                                    return [2];
                                            }
                                        });
                                    });
                                }, function (err) {
                                    return tslib_1.__awaiter(_this, void 0, void 0, function () {
                                        var activeTargets_2;
                                        return tslib_1.__generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    if (!isDocumentChangeMissingError(err)) return [3, 2];
                                                    activeTargets_2 = [];
                                                    forEachNumber(this.queryViewsByTarget, function (target) {
                                                        return activeTargets_2.push(target);
                                                    });
                                                    return [4, this.synchronizeQueryViewsAndRaiseSnapshots(activeTargets_2)];

                                                case 1:
                                                    _a.sent();

                                                    return [3, 3];

                                                case 2:
                                                    throw err;

                                                case 3:
                                                    return [2];
                                            }
                                        });
                                    });
                                })];
                            }
                            _b.label = 2;

                        case 2:
                            queryView = this.queryViewsByTarget[targetId];
                            this.removeAndCleanupQuery(queryView);
                            return [4, this.localStore.releaseQuery(queryView.query, true)];

                        case 3:
                            _b.sent();

                            this.syncEngineListener.onWatchError(queryView.query, error$$1);
                            return [3, 5];

                        case 4:
                            fail('Unexpected target state: ' + state);
                            _b.label = 5;

                        case 5:
                            return [2];
                    }
                });
            });
        };

        SyncEngine.prototype.applyActiveTargetsChange = function (added, removed) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var _this = this;

                var _i, added_1, targetId, query, queryData, _loop_2, this_1, _a, removed_1, targetId;

                return tslib_1.__generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (!this.isPrimary) {
                                return [2];
                            }

                            _i = 0, added_1 = added;
                            _b.label = 1;

                        case 1:
                            if (!(_i < added_1.length)) return [3, 6];
                            targetId = added_1[_i];
                            assert(!this.queryViewsByTarget[targetId], 'Trying to add an already active target');
                            return [4, this.localStore.getQueryForTarget(targetId)];

                        case 2:
                            query = _b.sent();
                            assert(!!query, "Query data for active target " + targetId + " not found");
                            return [4, this.localStore.allocateQuery(query)];

                        case 3:
                            queryData = _b.sent();
                            return [4, this.initializeViewAndComputeSnapshot(queryData, false)];

                        case 4:
                            _b.sent();

                            this.remoteStore.listen(queryData);
                            _b.label = 5;

                        case 5:
                            _i++;
                            return [3, 1];

                        case 6:
                            _loop_2 = function _loop_2(targetId) {
                                var queryView;
                                return tslib_1.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            queryView = this_1.queryViewsByTarget[targetId];
                                            if (!queryView) return [3, 2];
                                            return [4, this_1.localStore.releaseQuery(queryView.query, false).then(function () {
                                                _this.remoteStore.unlisten(targetId);

                                                _this.removeAndCleanupQuery(queryView);
                                            }).catch(function (err) {
                                                return _this.ignoreIfPrimaryLeaseLoss(err);
                                            })];

                                        case 1:
                                            _a.sent();

                                            _a.label = 2;

                                        case 2:
                                            return [2];
                                    }
                                });
                            };

                            this_1 = this;
                            _a = 0, removed_1 = removed;
                            _b.label = 7;

                        case 7:
                            if (!(_a < removed_1.length)) return [3, 10];
                            targetId = removed_1[_a];
                            return [5, _loop_2(targetId)];

                        case 8:
                            _b.sent();

                            _b.label = 9;

                        case 9:
                            _a++;
                            return [3, 7];

                        case 10:
                            return [2];
                    }
                });
            });
        };

        SyncEngine.prototype.enableNetwork = function () {
            this.localStore.setNetworkEnabled(true);
            return this.remoteStore.enableNetwork();
        };

        SyncEngine.prototype.disableNetwork = function () {
            this.localStore.setNetworkEnabled(false);
            return this.remoteStore.disableNetwork();
        };

        SyncEngine.prototype.getRemoteKeysForTarget = function (targetId) {
            var limboResolution = this.limboResolutionsByTarget[targetId];

            if (limboResolution && limboResolution.receivedDocument) {
                return documentKeySet().add(limboResolution.key);
            } else {
                return this.queryViewsByTarget[targetId] ? this.queryViewsByTarget[targetId].view.syncedDocuments : documentKeySet();
            }
        };

        return SyncEngine;
    }();

    var User = function () {
        function User(uid) {
            this.uid = uid;
        }

        User.prototype.isAuthenticated = function () {
            return this.uid != null;
        };

        User.prototype.toKey = function () {
            if (this.isAuthenticated()) {
                return 'uid:' + this.uid;
            } else {
                return 'anonymous-user';
            }
        };

        User.prototype.isEqual = function (otherUser) {
            return otherUser.uid === this.uid;
        };

        User.UNAUTHENTICATED = new User(null);
        User.GOOGLE_CREDENTIALS = new User('google-credentials-uid');
        User.FIRST_PARTY = new User('first-party-uid');
        return User;
    }();

    var LOG_TAG$10 = 'SharedClientState';
    var CLIENT_STATE_KEY_PREFIX = 'firestore_clients';
    var MUTATION_BATCH_KEY_PREFIX = 'firestore_mutations';
    var QUERY_TARGET_KEY_PREFIX = 'firestore_targets';
    var ONLINE_STATE_KEY_PREFIX = 'firestore_online_state';
    var SEQUENCE_NUMBER_KEY_PREFIX = 'firestore_sequence_number';

    var MutationMetadata = function () {
        function MutationMetadata(user, batchId, state, error$$1) {
            this.user = user;
            this.batchId = batchId;
            this.state = state;
            this.error = error$$1;
            assert(error$$1 !== undefined === (state === 'rejected'), "MutationMetadata must contain an error iff state is 'rejected'");
        }

        MutationMetadata.fromWebStorageEntry = function (user, batchId, value) {
            var mutationBatch = JSON.parse(value);
            var validData = typeof mutationBatch === 'object' && ['pending', 'acknowledged', 'rejected'].indexOf(mutationBatch.state) !== -1 && (mutationBatch.error === undefined || typeof mutationBatch.error === 'object');
            var firestoreError = undefined;

            if (validData && mutationBatch.error) {
                validData = typeof mutationBatch.error.message === 'string' && typeof mutationBatch.error.code === 'string';

                if (validData) {
                    firestoreError = new FirestoreError(mutationBatch.error.code, mutationBatch.error.message);
                }
            }

            if (validData) {
                return new MutationMetadata(user, batchId, mutationBatch.state, firestoreError);
            } else {
                error(LOG_TAG$10, "Failed to parse mutation state for ID '" + batchId + "': " + value);
                return null;
            }
        };

        MutationMetadata.prototype.toWebStorageJSON = function () {
            var batchMetadata = {
                state: this.state,
                updateTimeMs: Date.now()
            };

            if (this.error) {
                batchMetadata.error = {
                    code: this.error.code,
                    message: this.error.message
                };
            }

            return JSON.stringify(batchMetadata);
        };

        return MutationMetadata;
    }();

    var QueryTargetMetadata = function () {
        function QueryTargetMetadata(targetId, state, error$$1) {
            this.targetId = targetId;
            this.state = state;
            this.error = error$$1;
            assert(error$$1 !== undefined === (state === 'rejected'), "QueryTargetMetadata must contain an error iff state is 'rejected'");
        }

        QueryTargetMetadata.fromWebStorageEntry = function (targetId, value) {
            var targetState = JSON.parse(value);
            var validData = typeof targetState === 'object' && ['not-current', 'current', 'rejected'].indexOf(targetState.state) !== -1 && (targetState.error === undefined || typeof targetState.error === 'object');
            var firestoreError = undefined;

            if (validData && targetState.error) {
                validData = typeof targetState.error.message === 'string' && typeof targetState.error.code === 'string';

                if (validData) {
                    firestoreError = new FirestoreError(targetState.error.code, targetState.error.message);
                }
            }

            if (validData) {
                return new QueryTargetMetadata(targetId, targetState.state, firestoreError);
            } else {
                error(LOG_TAG$10, "Failed to parse target state for ID '" + targetId + "': " + value);
                return null;
            }
        };

        QueryTargetMetadata.prototype.toWebStorageJSON = function () {
            var targetState = {
                state: this.state,
                updateTimeMs: Date.now()
            };

            if (this.error) {
                targetState.error = {
                    code: this.error.code,
                    message: this.error.message
                };
            }

            return JSON.stringify(targetState);
        };

        return QueryTargetMetadata;
    }();

    var RemoteClientState = function () {
        function RemoteClientState(clientId, activeTargetIds) {
            this.clientId = clientId;
            this.activeTargetIds = activeTargetIds;
        }

        RemoteClientState.fromWebStorageEntry = function (clientId, value) {
            var clientState = JSON.parse(value);
            var validData = typeof clientState === 'object' && clientState.activeTargetIds instanceof Array;
            var activeTargetIdsSet = targetIdSet();

            for (var i = 0; validData && i < clientState.activeTargetIds.length; ++i) {
                validData = isSafeInteger(clientState.activeTargetIds[i]);
                activeTargetIdsSet = activeTargetIdsSet.add(clientState.activeTargetIds[i]);
            }

            if (validData) {
                return new RemoteClientState(clientId, activeTargetIdsSet);
            } else {
                error(LOG_TAG$10, "Failed to parse client data for instance '" + clientId + "': " + value);
                return null;
            }
        };

        return RemoteClientState;
    }();

    var SharedOnlineState = function () {
        function SharedOnlineState(clientId, onlineState) {
            this.clientId = clientId;
            this.onlineState = onlineState;
        }

        SharedOnlineState.fromWebStorageEntry = function (value) {
            var onlineState = JSON.parse(value);
            var validData = typeof onlineState === 'object' && OnlineState[onlineState.onlineState] !== undefined && typeof onlineState.clientId === 'string';

            if (validData) {
                return new SharedOnlineState(onlineState.clientId, OnlineState[onlineState.onlineState]);
            } else {
                error(LOG_TAG$10, "Failed to parse online state: " + value);
                return null;
            }
        };

        return SharedOnlineState;
    }();

    var LocalClientState = function () {
        function LocalClientState() {
            this.activeTargetIds = targetIdSet();
        }

        LocalClientState.prototype.addQueryTarget = function (targetId) {
            assert(!this.activeTargetIds.has(targetId), "Target with ID '" + targetId + "' already active.");
            this.activeTargetIds = this.activeTargetIds.add(targetId);
        };

        LocalClientState.prototype.removeQueryTarget = function (targetId) {
            this.activeTargetIds = this.activeTargetIds.delete(targetId);
        };

        LocalClientState.prototype.toWebStorageJSON = function () {
            var data = {
                activeTargetIds: this.activeTargetIds.toArray(),
                updateTimeMs: Date.now()
            };
            return JSON.stringify(data);
        };

        return LocalClientState;
    }();

    var WebStorageSharedClientState = function () {
        function WebStorageSharedClientState(queue, platform, persistenceKey, localClientId, initialUser) {
            this.queue = queue;
            this.platform = platform;
            this.persistenceKey = persistenceKey;
            this.localClientId = localClientId;
            this.syncEngine = null;
            this.onlineStateHandler = null;
            this.sequenceNumberHandler = null;
            this.activeClients = {};
            this.storageListener = this.handleWebStorageEvent.bind(this);
            this.started = false;
            this.earlyEvents = [];

            if (!WebStorageSharedClientState.isAvailable(this.platform)) {
                throw new FirestoreError(Code.UNIMPLEMENTED, 'LocalStorage is not available on this platform.');
            }

            var escapedPersistenceKey = persistenceKey.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            this.storage = this.platform.window.localStorage;
            this.currentUser = initialUser;
            this.localClientStorageKey = this.toWebStorageClientStateKey(this.localClientId);
            this.sequenceNumberKey = SEQUENCE_NUMBER_KEY_PREFIX + "_" + persistenceKey;
            this.activeClients[this.localClientId] = new LocalClientState();
            this.clientStateKeyRe = new RegExp("^" + CLIENT_STATE_KEY_PREFIX + "_" + escapedPersistenceKey + "_([^_]*)$");
            this.mutationBatchKeyRe = new RegExp("^" + MUTATION_BATCH_KEY_PREFIX + "_" + escapedPersistenceKey + "_(\\d+)(?:_(.*))?$");
            this.queryTargetKeyRe = new RegExp("^" + QUERY_TARGET_KEY_PREFIX + "_" + escapedPersistenceKey + "_(\\d+)$");
            this.onlineStateKey = ONLINE_STATE_KEY_PREFIX + "_" + persistenceKey;
            this.platform.window.addEventListener('storage', this.storageListener);
        }

        WebStorageSharedClientState.isAvailable = function (platform) {
            return !!(platform.window && platform.window.localStorage != null);
        };

        WebStorageSharedClientState.prototype.start = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var _this = this;

                var existingClients, _i, existingClients_1, clientId, storageItem, clientState, onlineStateJSON, onlineState, _a, _b, event_1;

                return tslib_1.__generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            assert(!this.started, 'WebStorageSharedClientState already started');
                            assert(this.syncEngine !== null, 'syncEngine property must be set before calling start()');
                            assert(this.onlineStateHandler !== null, 'onlineStateHandler property must be set before calling start()');
                            return [4, this.syncEngine.getActiveClients()];

                        case 1:
                            existingClients = _c.sent();

                            for (_i = 0, existingClients_1 = existingClients; _i < existingClients_1.length; _i++) {
                                clientId = existingClients_1[_i];

                                if (clientId === this.localClientId) {
                                    continue;
                                }

                                storageItem = this.getItem(this.toWebStorageClientStateKey(clientId));

                                if (storageItem) {
                                    clientState = RemoteClientState.fromWebStorageEntry(clientId, storageItem);

                                    if (clientState) {
                                        this.activeClients[clientState.clientId] = clientState;
                                    }
                                }
                            }

                            this.persistClientState();
                            onlineStateJSON = this.storage.getItem(this.onlineStateKey);

                            if (onlineStateJSON) {
                                onlineState = this.fromWebStorageOnlineState(onlineStateJSON);

                                if (onlineState) {
                                    this.handleOnlineStateEvent(onlineState);
                                }
                            }

                            for (_a = 0, _b = this.earlyEvents; _a < _b.length; _a++) {
                                event_1 = _b[_a];
                                this.handleWebStorageEvent(event_1);
                            }

                            this.earlyEvents = [];
                            this.platform.window.addEventListener('unload', function () {
                                return _this.shutdown();
                            });
                            this.started = true;
                            return [2];
                    }
                });
            });
        };

        WebStorageSharedClientState.prototype.writeSequenceNumber = function (sequenceNumber) {
            this.setItem(this.sequenceNumberKey, JSON.stringify(sequenceNumber));
        };

        WebStorageSharedClientState.prototype.getAllActiveQueryTargets = function () {
            var activeTargets = targetIdSet();
            forEach(this.activeClients, function (key, value) {
                activeTargets = activeTargets.unionWith(value.activeTargetIds);
            });
            return activeTargets;
        };

        WebStorageSharedClientState.prototype.isActiveQueryTarget = function (targetId) {
            for (var clientId in this.activeClients) {
                if (this.activeClients.hasOwnProperty(clientId)) {
                    if (this.activeClients[clientId].activeTargetIds.has(targetId)) {
                        return true;
                    }
                }
            }

            return false;
        };

        WebStorageSharedClientState.prototype.addPendingMutation = function (batchId) {
            this.persistMutationState(batchId, 'pending');
        };

        WebStorageSharedClientState.prototype.updateMutationState = function (batchId, state, error$$1) {
            this.persistMutationState(batchId, state, error$$1);
            this.removeMutationState(batchId);
        };

        WebStorageSharedClientState.prototype.addLocalQueryTarget = function (targetId) {
            var queryState = 'not-current';

            if (this.isActiveQueryTarget(targetId)) {
                var storageItem = this.storage.getItem(this.toWebStorageQueryTargetMetadataKey(targetId));

                if (storageItem) {
                    var metadata = QueryTargetMetadata.fromWebStorageEntry(targetId, storageItem);

                    if (metadata) {
                        queryState = metadata.state;
                    }
                }
            }

            this.localClientState.addQueryTarget(targetId);
            this.persistClientState();
            return queryState;
        };

        WebStorageSharedClientState.prototype.removeLocalQueryTarget = function (targetId) {
            this.localClientState.removeQueryTarget(targetId);
            this.persistClientState();
        };

        WebStorageSharedClientState.prototype.isLocalQueryTarget = function (targetId) {
            return this.localClientState.activeTargetIds.has(targetId);
        };

        WebStorageSharedClientState.prototype.clearQueryState = function (targetId) {
            this.removeItem(this.toWebStorageQueryTargetMetadataKey(targetId));
        };

        WebStorageSharedClientState.prototype.updateQueryState = function (targetId, state, error$$1) {
            this.persistQueryTargetState(targetId, state, error$$1);
        };

        WebStorageSharedClientState.prototype.handleUserChange = function (user, removedBatchIds, addedBatchIds) {
            var _this = this;

            removedBatchIds.forEach(function (batchId) {
                _this.removeMutationState(batchId);
            });
            this.currentUser = user;
            addedBatchIds.forEach(function (batchId) {
                _this.addPendingMutation(batchId);
            });
        };

        WebStorageSharedClientState.prototype.setOnlineState = function (onlineState) {
            this.persistOnlineState(onlineState);
        };

        WebStorageSharedClientState.prototype.shutdown = function () {
            if (this.started) {
                this.platform.window.removeEventListener('storage', this.storageListener);
                this.removeItem(this.localClientStorageKey);
                this.started = false;
            }
        };

        WebStorageSharedClientState.prototype.getItem = function (key) {
            var value = this.storage.getItem(key);
            debug(LOG_TAG$10, 'READ', key, value);
            return value;
        };

        WebStorageSharedClientState.prototype.setItem = function (key, value) {
            debug(LOG_TAG$10, 'SET', key, value);
            this.storage.setItem(key, value);
        };

        WebStorageSharedClientState.prototype.removeItem = function (key) {
            debug(LOG_TAG$10, 'REMOVE', key);
            this.storage.removeItem(key);
        };

        WebStorageSharedClientState.prototype.handleWebStorageEvent = function (event) {
            var _this = this;

            if (event.storageArea === this.storage) {
                debug(LOG_TAG$10, 'EVENT', event.key, event.newValue);

                if (event.key === this.localClientStorageKey) {
                    error('Received WebStorage notification for local change. Another client might have ' + 'garbage-collected our state');
                    return;
                }

                this.queue.enqueueAndForget(function () {
                    return tslib_1.__awaiter(_this, void 0, void 0, function () {
                        var clientState, clientId, mutationMetadata, queryTargetMetadata, onlineState, sequenceNumber;
                        return tslib_1.__generator(this, function (_a) {
                            if (!this.started) {
                                this.earlyEvents.push(event);
                                return [2];
                            }

                            if (event.key === null) {
                                return [2];
                            }

                            if (this.clientStateKeyRe.test(event.key)) {
                                if (event.newValue != null) {
                                    clientState = this.fromWebStorageClientState(event.key, event.newValue);

                                    if (clientState) {
                                        return [2, this.handleClientStateEvent(clientState.clientId, clientState)];
                                    }
                                } else {
                                    clientId = this.fromWebStorageClientStateKey(event.key);
                                    return [2, this.handleClientStateEvent(clientId, null)];
                                }
                            } else if (this.mutationBatchKeyRe.test(event.key)) {
                                if (event.newValue !== null) {
                                    mutationMetadata = this.fromWebStorageMutationMetadata(event.key, event.newValue);

                                    if (mutationMetadata) {
                                        return [2, this.handleMutationBatchEvent(mutationMetadata)];
                                    }
                                }
                            } else if (this.queryTargetKeyRe.test(event.key)) {
                                if (event.newValue !== null) {
                                    queryTargetMetadata = this.fromWebStorageQueryTargetMetadata(event.key, event.newValue);

                                    if (queryTargetMetadata) {
                                        return [2, this.handleQueryTargetEvent(queryTargetMetadata)];
                                    }
                                }
                            } else if (event.key === this.onlineStateKey) {
                                if (event.newValue !== null) {
                                    onlineState = this.fromWebStorageOnlineState(event.newValue);

                                    if (onlineState) {
                                        return [2, this.handleOnlineStateEvent(onlineState)];
                                    }
                                }
                            } else if (event.key === this.sequenceNumberKey) {
                                assert(!!this.sequenceNumberHandler, 'Missing sequenceNumberHandler');
                                sequenceNumber = fromWebStorageSequenceNumber(event.newValue);

                                if (sequenceNumber !== ListenSequence.INVALID) {
                                    this.sequenceNumberHandler(sequenceNumber);
                                }
                            }

                            return [2];
                        });
                    });
                });
            }
        };

        Object.defineProperty(WebStorageSharedClientState.prototype, "localClientState", {
            get: function get() {
                return this.activeClients[this.localClientId];
            },
            enumerable: true,
            configurable: true
        });

        WebStorageSharedClientState.prototype.persistClientState = function () {
            this.setItem(this.localClientStorageKey, this.localClientState.toWebStorageJSON());
        };

        WebStorageSharedClientState.prototype.persistMutationState = function (batchId, state, error$$1) {
            var mutationState = new MutationMetadata(this.currentUser, batchId, state, error$$1);
            var mutationKey = this.toWebStorageMutationBatchKey(batchId);
            this.setItem(mutationKey, mutationState.toWebStorageJSON());
        };

        WebStorageSharedClientState.prototype.removeMutationState = function (batchId) {
            var mutationKey = this.toWebStorageMutationBatchKey(batchId);
            this.removeItem(mutationKey);
        };

        WebStorageSharedClientState.prototype.persistOnlineState = function (onlineState) {
            var entry = {
                clientId: this.localClientId,
                onlineState: OnlineState[onlineState]
            };
            this.storage.setItem(this.onlineStateKey, JSON.stringify(entry));
        };

        WebStorageSharedClientState.prototype.persistQueryTargetState = function (targetId, state, error$$1) {
            var targetKey = this.toWebStorageQueryTargetMetadataKey(targetId);
            var targetMetadata = new QueryTargetMetadata(targetId, state, error$$1);
            this.setItem(targetKey, targetMetadata.toWebStorageJSON());
        };

        WebStorageSharedClientState.prototype.toWebStorageClientStateKey = function (clientId) {
            assert(clientId.indexOf('_') === -1, "Client key cannot contain '_', but was '" + clientId + "'");
            return CLIENT_STATE_KEY_PREFIX + "_" + this.persistenceKey + "_" + clientId;
        };

        WebStorageSharedClientState.prototype.toWebStorageQueryTargetMetadataKey = function (targetId) {
            return QUERY_TARGET_KEY_PREFIX + "_" + this.persistenceKey + "_" + targetId;
        };

        WebStorageSharedClientState.prototype.toWebStorageMutationBatchKey = function (batchId) {
            var mutationKey = MUTATION_BATCH_KEY_PREFIX + "_" + this.persistenceKey + "_" + batchId;

            if (this.currentUser.isAuthenticated()) {
                mutationKey += "_" + this.currentUser.uid;
            }

            return mutationKey;
        };

        WebStorageSharedClientState.prototype.fromWebStorageClientStateKey = function (key) {
            var match = this.clientStateKeyRe.exec(key);
            return match ? match[1] : null;
        };

        WebStorageSharedClientState.prototype.fromWebStorageClientState = function (key, value) {
            var clientId = this.fromWebStorageClientStateKey(key);
            assert(clientId !== null, "Cannot parse client state key '" + key + "'");
            return RemoteClientState.fromWebStorageEntry(clientId, value);
        };

        WebStorageSharedClientState.prototype.fromWebStorageMutationMetadata = function (key, value) {
            var match = this.mutationBatchKeyRe.exec(key);
            assert(match !== null, "Cannot parse mutation batch key '" + key + "'");
            var batchId = Number(match[1]);
            var userId = match[2] !== undefined ? match[2] : null;
            return MutationMetadata.fromWebStorageEntry(new User(userId), batchId, value);
        };

        WebStorageSharedClientState.prototype.fromWebStorageQueryTargetMetadata = function (key, value) {
            var match = this.queryTargetKeyRe.exec(key);
            assert(match !== null, "Cannot parse query target key '" + key + "'");
            var targetId = Number(match[1]);
            return QueryTargetMetadata.fromWebStorageEntry(targetId, value);
        };

        WebStorageSharedClientState.prototype.fromWebStorageOnlineState = function (value) {
            return SharedOnlineState.fromWebStorageEntry(value);
        };

        WebStorageSharedClientState.prototype.handleMutationBatchEvent = function (mutationBatch) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                return tslib_1.__generator(this, function (_a) {
                    if (mutationBatch.user.uid !== this.currentUser.uid) {
                        debug(LOG_TAG$10, "Ignoring mutation for non-active user " + mutationBatch.user.uid);
                        return [2];
                    }

                    return [2, this.syncEngine.applyBatchState(mutationBatch.batchId, mutationBatch.state, mutationBatch.error)];
                });
            });
        };

        WebStorageSharedClientState.prototype.handleQueryTargetEvent = function (targetMetadata) {
            return this.syncEngine.applyTargetState(targetMetadata.targetId, targetMetadata.state, targetMetadata.error);
        };

        WebStorageSharedClientState.prototype.handleClientStateEvent = function (clientId, clientState) {
            var _this = this;

            var existingTargets = this.getAllActiveQueryTargets();

            if (clientState) {
                this.activeClients[clientId] = clientState;
            } else {
                delete this.activeClients[clientId];
            }

            var newTargets = this.getAllActiveQueryTargets();
            var addedTargets = [];
            var removedTargets = [];
            newTargets.forEach(function (targetId) {
                return tslib_1.__awaiter(_this, void 0, void 0, function () {
                    return tslib_1.__generator(this, function (_a) {
                        if (!existingTargets.has(targetId)) {
                            addedTargets.push(targetId);
                        }

                        return [2];
                    });
                });
            });
            existingTargets.forEach(function (targetId) {
                return tslib_1.__awaiter(_this, void 0, void 0, function () {
                    return tslib_1.__generator(this, function (_a) {
                        if (!newTargets.has(targetId)) {
                            removedTargets.push(targetId);
                        }

                        return [2];
                    });
                });
            });
            return this.syncEngine.applyActiveTargetsChange(addedTargets, removedTargets);
        };

        WebStorageSharedClientState.prototype.handleOnlineStateEvent = function (onlineState) {
            if (this.activeClients[onlineState.clientId]) {
                this.onlineStateHandler(onlineState.onlineState);
            }
        };

        return WebStorageSharedClientState;
    }();

    function fromWebStorageSequenceNumber(seqString) {
        var sequenceNumber = ListenSequence.INVALID;

        if (seqString != null) {
            try {
                var parsed = JSON.parse(seqString);
                assert(typeof parsed === 'number', 'Found non-numeric sequence number');
                sequenceNumber = parsed;
            } catch (e) {
                error(LOG_TAG$10, 'Failed to read sequence number from WebStorage', e);
            }
        }

        return sequenceNumber;
    }

    var MemorySharedClientState = function () {
        function MemorySharedClientState() {
            this.localState = new LocalClientState();
            this.queryState = {};
            this.syncEngine = null;
            this.onlineStateHandler = null;
            this.sequenceNumberHandler = null;
        }

        MemorySharedClientState.prototype.addPendingMutation = function (batchId) {};

        MemorySharedClientState.prototype.updateMutationState = function (batchId, state, error$$1) {};

        MemorySharedClientState.prototype.addLocalQueryTarget = function (targetId) {
            this.localState.addQueryTarget(targetId);
            return this.queryState[targetId] || 'not-current';
        };

        MemorySharedClientState.prototype.updateQueryState = function (targetId, state, error$$1) {
            this.queryState[targetId] = state;
        };

        MemorySharedClientState.prototype.removeLocalQueryTarget = function (targetId) {
            this.localState.removeQueryTarget(targetId);
        };

        MemorySharedClientState.prototype.isLocalQueryTarget = function (targetId) {
            return this.localState.activeTargetIds.has(targetId);
        };

        MemorySharedClientState.prototype.clearQueryState = function (targetId) {
            delete this.queryState[targetId];
        };

        MemorySharedClientState.prototype.getAllActiveQueryTargets = function () {
            return this.localState.activeTargetIds;
        };

        MemorySharedClientState.prototype.isActiveQueryTarget = function (targetId) {
            return this.localState.activeTargetIds.has(targetId);
        };

        MemorySharedClientState.prototype.start = function () {
            this.localState = new LocalClientState();
            return Promise.resolve();
        };

        MemorySharedClientState.prototype.handleUserChange = function (user, removedBatchIds, addedBatchIds) {};

        MemorySharedClientState.prototype.setOnlineState = function (onlineState) {};

        MemorySharedClientState.prototype.shutdown = function () {};

        MemorySharedClientState.prototype.writeSequenceNumber = function (sequenceNumber) {};

        return MemorySharedClientState;
    }();

    var LOG_TAG$11 = 'FirestoreClient';
    var DOM_EXCEPTION_ABORTED = 20;
    var DOM_EXCEPTION_QUOTA_EXCEEDED = 22;

    var FirestoreClient = function () {
        function FirestoreClient(platform, databaseInfo, credentials, asyncQueue) {
            this.platform = platform;
            this.databaseInfo = databaseInfo;
            this.credentials = credentials;
            this.asyncQueue = asyncQueue;
            this.clientId = AutoId.newId();
        }

        FirestoreClient.prototype.start = function (persistenceSettings) {
            var _this = this;

            var initializationDone = new Deferred$1();
            var persistenceResult = new Deferred$1();
            var initialized = false;
            this.credentials.setChangeListener(function (user) {
                if (!initialized) {
                    initialized = true;

                    _this.initializePersistence(persistenceSettings, persistenceResult, user).then(function () {
                        return _this.initializeRest(user);
                    }).then(initializationDone.resolve, initializationDone.reject);
                } else {
                    _this.asyncQueue.enqueueAndForget(function () {
                        return _this.handleCredentialChange(user);
                    });
                }
            });
            this.asyncQueue.enqueueAndForget(function () {
                return initializationDone.promise;
            });
            return persistenceResult.promise;
        };

        FirestoreClient.prototype.enableNetwork = function () {
            var _this = this;

            return this.asyncQueue.enqueue(function () {
                return _this.syncEngine.enableNetwork();
            });
        };

        FirestoreClient.prototype.initializePersistence = function (persistenceSettings, persistenceResult, user) {
            var _this = this;

            if (persistenceSettings.enabled) {
                return this.startIndexedDbPersistence(user, persistenceSettings).then(persistenceResult.resolve).catch(function (error$$1) {
                    persistenceResult.reject(error$$1);

                    if (!_this.canFallback(error$$1)) {
                        return Promise.reject(error$$1);
                    }

                    console.warn('Error enabling offline storage. Falling back to' + ' storage disabled: ' + error$$1);
                    return _this.startMemoryPersistence();
                });
            } else {
                persistenceResult.resolve();
                return this.startMemoryPersistence();
            }
        };

        FirestoreClient.prototype.canFallback = function (error$$1) {
            if (error$$1 instanceof FirestoreError) {
                return error$$1.code === Code.FAILED_PRECONDITION || error$$1.code === Code.UNIMPLEMENTED;
            } else if (typeof DOMException !== 'undefined' && error$$1 instanceof DOMException) {
                return error$$1.code === DOM_EXCEPTION_QUOTA_EXCEEDED || error$$1.code === DOM_EXCEPTION_ABORTED;
            }

            return true;
        };

        FirestoreClient.prototype.startIndexedDbPersistence = function (user, settings) {
            var _this = this;

            assert(settings.enabled, 'Should only start IndexedDb persitence with offline persistence enabled.');
            var storagePrefix = IndexedDbPersistence.buildStoragePrefix(this.databaseInfo);
            var serializer = new JsonProtoSerializer(this.databaseInfo.databaseId, {
                useProto3Json: true
            });
            return Promise.resolve().then(function () {
                return tslib_1.__awaiter(_this, void 0, void 0, function () {
                    var _a, _b;

                    return tslib_1.__generator(this, function (_c) {
                        switch (_c.label) {
                            case 0:
                                if (settings.experimentalTabSynchronization && !WebStorageSharedClientState.isAvailable(this.platform)) {
                                    throw new FirestoreError(Code.UNIMPLEMENTED, 'IndexedDB persistence is only available on platforms that support LocalStorage.');
                                }

                                if (!settings.experimentalTabSynchronization) return [3, 2];
                                this.sharedClientState = new WebStorageSharedClientState(this.asyncQueue, this.platform, storagePrefix, this.clientId, user);
                                _a = this;
                                return [4, IndexedDbPersistence.createMultiClientIndexedDbPersistence(storagePrefix, this.clientId, this.platform, this.asyncQueue, serializer, {
                                    sequenceNumberSyncer: this.sharedClientState
                                })];

                            case 1:
                                _a.persistence = _c.sent();
                                return [3, 4];

                            case 2:
                                this.sharedClientState = new MemorySharedClientState();
                                _b = this;
                                return [4, IndexedDbPersistence.createIndexedDbPersistence(storagePrefix, this.clientId, this.platform, this.asyncQueue, serializer)];

                            case 3:
                                _b.persistence = _c.sent();
                                _c.label = 4;

                            case 4:
                                return [2];
                        }
                    });
                });
            });
        };

        FirestoreClient.prototype.startMemoryPersistence = function () {
            this.persistence = MemoryPersistence.createEagerPersistence(this.clientId);
            this.sharedClientState = new MemorySharedClientState();
            return Promise.resolve();
        };

        FirestoreClient.prototype.initializeRest = function (user) {
            var _this = this;

            debug(LOG_TAG$11, 'Initializing. user=', user.uid);
            return this.platform.loadConnection(this.databaseInfo).then(function (connection) {
                return tslib_1.__awaiter(_this, void 0, void 0, function () {
                    var _this = this;

                    var serializer, datastore, remoteStoreOnlineStateChangedHandler, sharedClientStateOnlineStateChangedHandler;
                    return tslib_1.__generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                this.localStore = new LocalStore(this.persistence, user);
                                serializer = this.platform.newSerializer(this.databaseInfo.databaseId);
                                datastore = new Datastore(this.asyncQueue, connection, this.credentials, serializer);

                                remoteStoreOnlineStateChangedHandler = function remoteStoreOnlineStateChangedHandler(onlineState) {
                                    return _this.syncEngine.applyOnlineStateChange(onlineState, OnlineStateSource.RemoteStore);
                                };

                                sharedClientStateOnlineStateChangedHandler = function sharedClientStateOnlineStateChangedHandler(onlineState) {
                                    return _this.syncEngine.applyOnlineStateChange(onlineState, OnlineStateSource.SharedClientState);
                                };

                                this.remoteStore = new RemoteStore(this.localStore, datastore, this.asyncQueue, remoteStoreOnlineStateChangedHandler);
                                this.syncEngine = new SyncEngine(this.localStore, this.remoteStore, this.sharedClientState, user);
                                this.sharedClientState.onlineStateHandler = sharedClientStateOnlineStateChangedHandler;
                                this.remoteStore.syncEngine = this.syncEngine;
                                this.sharedClientState.syncEngine = this.syncEngine;
                                this.eventMgr = new EventManager(this.syncEngine);
                                return [4, this.sharedClientState.start()];

                            case 1:
                                _a.sent();

                                return [4, this.remoteStore.start()];

                            case 2:
                                _a.sent();

                                return [4, this.persistence.setPrimaryStateListener(function (isPrimary) {
                                    return _this.syncEngine.applyPrimaryState(isPrimary);
                                })];

                            case 3:
                                _a.sent();

                                return [2];
                        }
                    });
                });
            });
        };

        FirestoreClient.prototype.handleCredentialChange = function (user) {
            this.asyncQueue.verifyOperationInProgress();
            debug(LOG_TAG$11, 'Credential Changed. Current user: ' + user.uid);
            return this.syncEngine.handleCredentialChange(user);
        };

        FirestoreClient.prototype.disableNetwork = function () {
            var _this = this;

            return this.asyncQueue.enqueue(function () {
                return _this.syncEngine.disableNetwork();
            });
        };

        FirestoreClient.prototype.shutdown = function (options) {
            var _this = this;

            return this.asyncQueue.enqueue(function () {
                return tslib_1.__awaiter(_this, void 0, void 0, function () {
                    return tslib_1.__generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                return [4, this.remoteStore.shutdown()];

                            case 1:
                                _a.sent();

                                return [4, this.sharedClientState.shutdown()];

                            case 2:
                                _a.sent();

                                return [4, this.persistence.shutdown(options && options.purgePersistenceWithDataLoss)];

                            case 3:
                                _a.sent();

                                this.credentials.removeChangeListener();
                                return [2];
                        }
                    });
                });
            });
        };

        FirestoreClient.prototype.listen = function (query, observer, options) {
            var _this = this;

            var listener = new QueryListener(query, observer, options);
            this.asyncQueue.enqueueAndForget(function () {
                return _this.eventMgr.listen(listener);
            });
            return listener;
        };

        FirestoreClient.prototype.unlisten = function (listener) {
            var _this = this;

            this.asyncQueue.enqueueAndForget(function () {
                return _this.eventMgr.unlisten(listener);
            });
        };

        FirestoreClient.prototype.getDocumentFromLocalCache = function (docKey) {
            var _this = this;

            return this.asyncQueue.enqueue(function () {
                return _this.localStore.readDocument(docKey);
            }).then(function (maybeDoc) {
                if (maybeDoc instanceof Document) {
                    return maybeDoc;
                } else if (maybeDoc instanceof NoDocument) {
                    return null;
                } else {
                    throw new FirestoreError(Code.UNAVAILABLE, 'Failed to get document from cache. (However, this document may ' + "exist on the server. Run again without setting 'source' in " + 'the GetOptions to attempt to retrieve the document from the ' + 'server.)');
                }
            });
        };

        FirestoreClient.prototype.getDocumentsFromLocalCache = function (query) {
            var _this = this;

            return this.asyncQueue.enqueue(function () {
                return _this.localStore.executeQuery(query);
            }).then(function (docs) {
                var remoteKeys = documentKeySet();
                var view = new View(query, remoteKeys);
                var viewDocChanges = view.computeDocChanges(docs);
                return view.applyChanges(viewDocChanges, false).snapshot;
            });
        };

        FirestoreClient.prototype.write = function (mutations) {
            var _this = this;

            var deferred = new Deferred$1();
            this.asyncQueue.enqueueAndForget(function () {
                return _this.syncEngine.write(mutations, deferred);
            });
            return deferred.promise;
        };

        FirestoreClient.prototype.databaseId = function () {
            return this.databaseInfo.databaseId;
        };

        FirestoreClient.prototype.transaction = function (updateFunction) {
            var _this = this;

            return this.asyncQueue.enqueue(function () {
                return tslib_1.__awaiter(_this, void 0, void 0, function () {
                    return tslib_1.__generator(this, function (_a) {
                        return [2];
                    });
                });
            }).then(function () {
                return _this.syncEngine.runTransaction(updateFunction);
            });
        };

        return FirestoreClient;
    }();

    var AsyncObserver = function () {
        function AsyncObserver(observer) {
            this.observer = observer;
            this.muted = false;
        }

        AsyncObserver.prototype.next = function (value) {
            this.scheduleEvent(this.observer.next, value);
        };

        AsyncObserver.prototype.error = function (error) {
            this.scheduleEvent(this.observer.error, error);
        };

        AsyncObserver.prototype.mute = function () {
            this.muted = true;
        };

        AsyncObserver.prototype.scheduleEvent = function (eventHandler, event) {
            var _this = this;

            if (!this.muted) {
                setTimeout(function () {
                    if (!_this.muted) {
                        eventHandler(event);
                    }
                }, 0);
            }
        };

        return AsyncObserver;
    }();

    var FieldPath$1 = function () {
        function FieldPath$$1() {
            var fieldNames = [];

            for (var _i = 0; _i < arguments.length; _i++) {
                fieldNames[_i] = arguments[_i];
            }

            validateNamedArrayAtLeastNumberOfElements('FieldPath', fieldNames, 'fieldNames', 1);

            for (var i = 0; i < fieldNames.length; ++i) {
                validateArgType('FieldPath', 'string', i, fieldNames[i]);

                if (fieldNames[i].length === 0) {
                    throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). " + 'Field names must not be empty.');
                }
            }

            this._internalPath = new FieldPath(fieldNames);
        }

        FieldPath$$1.documentId = function () {
            return FieldPath$$1._DOCUMENT_ID;
        };

        FieldPath$$1.prototype.isEqual = function (other) {
            if (!(other instanceof FieldPath$$1)) {
                throw invalidClassError('isEqual', 'FieldPath', 1, other);
            }

            return this._internalPath.isEqual(other._internalPath);
        };

        FieldPath$$1._DOCUMENT_ID = new FieldPath$$1(FieldPath.keyField().canonicalString());
        return FieldPath$$1;
    }();

    var RESERVED = new RegExp('[~\\*/\\[\\]]');

    function fromDotSeparatedString(path) {
        var found = path.search(RESERVED);

        if (found >= 0) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid field path (" + path + "). Paths must not contain " + "'~', '*', '/', '[', or ']'");
        }

        try {
            return new (FieldPath$1.bind.apply(FieldPath$1, [void 0].concat(path.split('.'))))();
        } catch (e) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid field path (" + path + "). Paths must not be empty, " + "begin with '.', end with '.', or contain '..'");
        }
    }

    var OAuthToken = function () {
        function OAuthToken(value, user) {
            this.user = user;
            this.type = 'OAuth';
            this.authHeaders = {
                Authorization: "Bearer " + value
            };
        }

        return OAuthToken;
    }();

    var EmptyCredentialsProvider = function () {
        function EmptyCredentialsProvider() {
            this.changeListener = null;
        }

        EmptyCredentialsProvider.prototype.getToken = function () {
            return Promise.resolve(null);
        };

        EmptyCredentialsProvider.prototype.invalidateToken = function () {};

        EmptyCredentialsProvider.prototype.setChangeListener = function (changeListener) {
            assert(!this.changeListener, 'Can only call setChangeListener() once.');
            this.changeListener = changeListener;
            changeListener(User.UNAUTHENTICATED);
        };

        EmptyCredentialsProvider.prototype.removeChangeListener = function () {
            assert(this.changeListener !== null, 'removeChangeListener() when no listener registered');
            this.changeListener = null;
        };

        return EmptyCredentialsProvider;
    }();

    var FirebaseCredentialsProvider = function () {
        function FirebaseCredentialsProvider(app) {
            var _this = this;

            this.app = app;
            this.tokenListener = null;
            this.tokenCounter = 0;
            this.changeListener = null;
            this.forceRefresh = false;

            this.tokenListener = function () {
                _this.tokenCounter++;
                _this.currentUser = _this.getUser();

                if (_this.changeListener) {
                    _this.changeListener(_this.currentUser);
                }
            };

            this.tokenCounter = 0;
            this.app.INTERNAL.addAuthTokenListener(this.tokenListener);
        }

        FirebaseCredentialsProvider.prototype.getToken = function () {
            var _this = this;

            assert(this.tokenListener != null, 'getToken cannot be called after listener removed.');
            var initialTokenCounter = this.tokenCounter;
            var forceRefresh = this.forceRefresh;
            this.forceRefresh = false;
            return this.app.INTERNAL.getToken(forceRefresh).then(function (tokenData) {
                if (_this.tokenCounter !== initialTokenCounter) {
                    throw new FirestoreError(Code.ABORTED, 'getToken aborted due to token change.');
                } else {
                    if (tokenData) {
                        assert(typeof tokenData.accessToken === 'string', 'Invalid tokenData returned from getToken():' + tokenData);
                        return new OAuthToken(tokenData.accessToken, _this.currentUser);
                    } else {
                        return null;
                    }
                }
            });
        };

        FirebaseCredentialsProvider.prototype.invalidateToken = function () {
            this.forceRefresh = true;
        };

        FirebaseCredentialsProvider.prototype.setChangeListener = function (changeListener) {
            assert(!this.changeListener, 'Can only call setChangeListener() once.');
            this.changeListener = changeListener;

            if (this.currentUser) {
                changeListener(this.currentUser);
            }
        };

        FirebaseCredentialsProvider.prototype.removeChangeListener = function () {
            assert(this.tokenListener != null, 'removeChangeListener() called twice');
            assert(this.changeListener !== null, 'removeChangeListener() called when no listener registered');
            this.app.INTERNAL.removeAuthTokenListener(this.tokenListener);
            this.tokenListener = null;
            this.changeListener = null;
        };

        FirebaseCredentialsProvider.prototype.getUser = function () {
            var currentUid = this.app.INTERNAL.getUid();
            assert(currentUid === null || typeof currentUid === 'string', 'Received invalid UID: ' + currentUid);
            return new User(currentUid);
        };

        return FirebaseCredentialsProvider;
    }();

    var FirstPartyToken = function () {
        function FirstPartyToken(gapi, sessionIndex) {
            this.gapi = gapi;
            this.sessionIndex = sessionIndex;
            this.type = 'FirstParty';
            this.user = User.FIRST_PARTY;
            assert(this.gapi && this.gapi['auth'] && this.gapi['auth']['getAuthHeaderValueForFirstParty'], 'unexpected gapi interface');
        }

        Object.defineProperty(FirstPartyToken.prototype, "authHeaders", {
            get: function get() {
                return {
                    Authorization: this.gapi['auth']['getAuthHeaderValueForFirstParty']([]),
                    'X-Goog-AuthUser': this.sessionIndex
                };
            },
            enumerable: true,
            configurable: true
        });
        return FirstPartyToken;
    }();

    var FirstPartyCredentialsProvider = function () {
        function FirstPartyCredentialsProvider(gapi, sessionIndex) {
            this.gapi = gapi;
            this.sessionIndex = sessionIndex;
            assert(this.gapi && this.gapi['auth'] && this.gapi['auth']['getAuthHeaderValueForFirstParty'], 'unexpected gapi interface');
        }

        FirstPartyCredentialsProvider.prototype.getToken = function () {
            return Promise.resolve(new FirstPartyToken(this.gapi, this.sessionIndex));
        };

        FirstPartyCredentialsProvider.prototype.setChangeListener = function (changeListener) {
            changeListener(User.FIRST_PARTY);
        };

        FirstPartyCredentialsProvider.prototype.removeChangeListener = function () {};

        FirstPartyCredentialsProvider.prototype.invalidateToken = function () {};

        return FirstPartyCredentialsProvider;
    }();

    function makeCredentialsProvider(credentials) {
        if (!credentials) {
            return new EmptyCredentialsProvider();
        }

        switch (credentials.type) {
            case 'gapi':
                return new FirstPartyCredentialsProvider(credentials.client, credentials.sessionIndex || '0');

            case 'provider':
                return credentials.client;

            default:
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'makeCredentialsProvider failed due to invalid credential type');
        }
    }

    function isPartialObserver(obj) {
        return implementsAnyMethods$1(obj, ['next', 'error', 'complete']);
    }

    function implementsAnyMethods$1(obj, methods) {
        if (typeof obj !== 'object' || obj === null) {
            return false;
        }

        var object = obj;

        for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {
            var method = methods_1[_i];

            if (method in object && typeof object[method] === 'function') {
                return true;
            }
        }

        return false;
    }

    var FieldValueImpl = function () {
        function FieldValueImpl(_methodName) {
            this._methodName = _methodName;
        }

        FieldValueImpl.delete = function () {
            return DeleteFieldValueImpl.instance;
        };

        FieldValueImpl.serverTimestamp = function () {
            return ServerTimestampFieldValueImpl.instance;
        };

        FieldValueImpl.arrayUnion = function () {
            var elements = [];

            for (var _i = 0; _i < arguments.length; _i++) {
                elements[_i] = arguments[_i];
            }

            validateAtLeastNumberOfArgs('FieldValue.arrayUnion', arguments, 1);
            return new ArrayUnionFieldValueImpl(elements);
        };

        FieldValueImpl.arrayRemove = function () {
            var elements = [];

            for (var _i = 0; _i < arguments.length; _i++) {
                elements[_i] = arguments[_i];
            }

            validateAtLeastNumberOfArgs('FieldValue.arrayRemove', arguments, 1);
            return new ArrayRemoveFieldValueImpl(elements);
        };

        FieldValueImpl.prototype.isEqual = function (other) {
            return this === other;
        };

        return FieldValueImpl;
    }();

    var DeleteFieldValueImpl = function (_super) {
        tslib_1.__extends(DeleteFieldValueImpl, _super);

        function DeleteFieldValueImpl() {
            return _super.call(this, 'FieldValue.delete') || this;
        }

        DeleteFieldValueImpl.instance = new DeleteFieldValueImpl();
        return DeleteFieldValueImpl;
    }(FieldValueImpl);

    var ServerTimestampFieldValueImpl = function (_super) {
        tslib_1.__extends(ServerTimestampFieldValueImpl, _super);

        function ServerTimestampFieldValueImpl() {
            return _super.call(this, 'FieldValue.serverTimestamp') || this;
        }

        ServerTimestampFieldValueImpl.instance = new ServerTimestampFieldValueImpl();
        return ServerTimestampFieldValueImpl;
    }(FieldValueImpl);

    var ArrayUnionFieldValueImpl = function (_super) {
        tslib_1.__extends(ArrayUnionFieldValueImpl, _super);

        function ArrayUnionFieldValueImpl(_elements) {
            var _this = _super.call(this, 'FieldValue.arrayUnion') || this;

            _this._elements = _elements;
            return _this;
        }

        return ArrayUnionFieldValueImpl;
    }(FieldValueImpl);

    var ArrayRemoveFieldValueImpl = function (_super) {
        tslib_1.__extends(ArrayRemoveFieldValueImpl, _super);

        function ArrayRemoveFieldValueImpl(_elements) {
            var _this = _super.call(this, 'FieldValue.arrayRemove') || this;

            _this._elements = _elements;
            return _this;
        }

        return ArrayRemoveFieldValueImpl;
    }(FieldValueImpl);

    var PublicFieldValue = makeConstructorPrivate(FieldValueImpl, 'Use FieldValue.<field>() instead.');
    var RESERVED_FIELD_REGEX = /^__.*__$/;

    var ParsedSetData = function () {
        function ParsedSetData(data, fieldMask, fieldTransforms) {
            this.data = data;
            this.fieldMask = fieldMask;
            this.fieldTransforms = fieldTransforms;
        }

        ParsedSetData.prototype.toMutations = function (key, precondition) {
            var mutations = [];

            if (this.fieldMask !== null) {
                mutations.push(new PatchMutation(key, this.data, this.fieldMask, precondition));
            } else {
                mutations.push(new SetMutation(key, this.data, precondition));
            }

            if (this.fieldTransforms.length > 0) {
                mutations.push(new TransformMutation(key, this.fieldTransforms));
            }

            return mutations;
        };

        return ParsedSetData;
    }();

    var ParsedUpdateData = function () {
        function ParsedUpdateData(data, fieldMask, fieldTransforms) {
            this.data = data;
            this.fieldMask = fieldMask;
            this.fieldTransforms = fieldTransforms;
        }

        ParsedUpdateData.prototype.toMutations = function (key, precondition) {
            var mutations = [new PatchMutation(key, this.data, this.fieldMask, precondition)];

            if (this.fieldTransforms.length > 0) {
                mutations.push(new TransformMutation(key, this.fieldTransforms));
            }

            return mutations;
        };

        return ParsedUpdateData;
    }();

    var UserDataSource;

    (function (UserDataSource) {
        UserDataSource[UserDataSource["Set"] = 0] = "Set";
        UserDataSource[UserDataSource["Update"] = 1] = "Update";
        UserDataSource[UserDataSource["MergeSet"] = 2] = "MergeSet";
        UserDataSource[UserDataSource["Argument"] = 3] = "Argument";
    })(UserDataSource || (UserDataSource = {}));

    function isWrite(dataSource) {
        switch (dataSource) {
            case UserDataSource.Set:
            case UserDataSource.MergeSet:
            case UserDataSource.Update:
                return true;

            case UserDataSource.Argument:
                return false;

            default:
                throw fail("Unexpected case for UserDataSource: " + dataSource);
        }
    }

    var ParseContext = function () {
        function ParseContext(dataSource, methodName, path, arrayElement, fieldTransforms, fieldMask) {
            this.dataSource = dataSource;
            this.methodName = methodName;
            this.path = path;
            this.arrayElement = arrayElement;

            if (fieldTransforms === undefined) {
                this.validatePath();
            }

            this.arrayElement = arrayElement !== undefined ? arrayElement : false;
            this.fieldTransforms = fieldTransforms || [];
            this.fieldMask = fieldMask || [];
        }

        ParseContext.prototype.childContextForField = function (field) {
            var childPath = this.path == null ? null : this.path.child(field);
            var context = new ParseContext(this.dataSource, this.methodName, childPath, false, this.fieldTransforms, this.fieldMask);
            context.validatePathSegment(field);
            return context;
        };

        ParseContext.prototype.childContextForFieldPath = function (field) {
            var childPath = this.path == null ? null : this.path.child(field);
            var context = new ParseContext(this.dataSource, this.methodName, childPath, false, this.fieldTransforms, this.fieldMask);
            context.validatePath();
            return context;
        };

        ParseContext.prototype.childContextForArray = function (index) {
            return new ParseContext(this.dataSource, this.methodName, null, true, this.fieldTransforms, this.fieldMask);
        };

        ParseContext.prototype.createError = function (reason) {
            var fieldDescription = this.path === null || this.path.isEmpty() ? '' : " (found in field " + this.path.toString() + ")";
            return new FirestoreError(Code.INVALID_ARGUMENT, "Function " + this.methodName + "() called with invalid data. " + reason + fieldDescription);
        };

        ParseContext.prototype.contains = function (fieldPath) {
            return this.fieldMask.find(function (field) {
                return fieldPath.isPrefixOf(field);
            }) !== undefined || this.fieldTransforms.find(function (transform) {
                return fieldPath.isPrefixOf(transform.field);
            }) !== undefined;
        };

        ParseContext.prototype.validatePath = function () {
            if (this.path === null) {
                return;
            }

            for (var i = 0; i < this.path.length; i++) {
                this.validatePathSegment(this.path.get(i));
            }
        };

        ParseContext.prototype.validatePathSegment = function (segment) {
            if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) {
                throw this.createError('Document fields cannot begin and end with __');
            }
        };

        return ParseContext;
    }();

    var DocumentKeyReference = function () {
        function DocumentKeyReference(databaseId, key) {
            this.databaseId = databaseId;
            this.key = key;
        }

        return DocumentKeyReference;
    }();

    var UserDataConverter = function () {
        function UserDataConverter(preConverter) {
            this.preConverter = preConverter;
        }

        UserDataConverter.prototype.parseSetData = function (methodName, input) {
            var context = new ParseContext(UserDataSource.Set, methodName, FieldPath.EMPTY_PATH);
            validatePlainObject('Data must be an object, but it was:', context, input);
            var updateData = this.parseData(input, context);
            return new ParsedSetData(updateData, null, context.fieldTransforms);
        };

        UserDataConverter.prototype.parseMergeData = function (methodName, input, fieldPaths) {
            var context = new ParseContext(UserDataSource.MergeSet, methodName, FieldPath.EMPTY_PATH);
            validatePlainObject('Data must be an object, but it was:', context, input);
            var updateData = this.parseData(input, context);
            var fieldMask;
            var fieldTransforms;

            if (!fieldPaths) {
                fieldMask = new FieldMask(context.fieldMask);
                fieldTransforms = context.fieldTransforms;
            } else {
                var validatedFieldPaths = [];

                for (var _i = 0, fieldPaths_1 = fieldPaths; _i < fieldPaths_1.length; _i++) {
                    var stringOrFieldPath = fieldPaths_1[_i];
                    var fieldPath = void 0;

                    if (stringOrFieldPath instanceof FieldPath$1) {
                        fieldPath = stringOrFieldPath._internalPath;
                    } else if (typeof stringOrFieldPath === 'string') {
                        fieldPath = fieldPathFromDotSeparatedString(methodName, stringOrFieldPath);
                    } else {
                        throw fail('Expected stringOrFieldPath to be a string or a FieldPath');
                    }

                    if (!context.contains(fieldPath)) {
                        throw new FirestoreError(Code.INVALID_ARGUMENT, "Field '" + fieldPath + "' is specified in your field mask but missing from your input data.");
                    }

                    validatedFieldPaths.push(fieldPath);
                }

                fieldMask = new FieldMask(validatedFieldPaths);
                fieldTransforms = context.fieldTransforms.filter(function (transform) {
                    return fieldMask.covers(transform.field);
                });
            }

            return new ParsedSetData(updateData, fieldMask, fieldTransforms);
        };

        UserDataConverter.prototype.parseUpdateData = function (methodName, input) {
            var _this = this;

            var context = new ParseContext(UserDataSource.Update, methodName, FieldPath.EMPTY_PATH);
            validatePlainObject('Data must be an object, but it was:', context, input);
            var fieldMaskPaths = [];
            var updateData = ObjectValue.EMPTY;
            forEach(input, function (key, value) {
                var path = fieldPathFromDotSeparatedString(methodName, key);
                var childContext = context.childContextForFieldPath(path);
                value = _this.runPreConverter(value, childContext);

                if (value instanceof DeleteFieldValueImpl) {
                    fieldMaskPaths.push(path);
                } else {
                    var parsedValue = _this.parseData(value, childContext);

                    if (parsedValue != null) {
                        fieldMaskPaths.push(path);
                        updateData = updateData.set(path, parsedValue);
                    }
                }
            });
            var mask = new FieldMask(fieldMaskPaths);
            return new ParsedUpdateData(updateData, mask, context.fieldTransforms);
        };

        UserDataConverter.prototype.parseUpdateVarargs = function (methodName, field, value, moreFieldsAndValues) {
            var context = new ParseContext(UserDataSource.Update, methodName, FieldPath.EMPTY_PATH);
            var keys = [fieldPathFromArgument(methodName, field)];
            var values$$1 = [value];

            if (moreFieldsAndValues.length % 2 !== 0) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + methodName + "() needs to be called with an even number " + 'of arguments that alternate between field names and values.');
            }

            for (var i = 0; i < moreFieldsAndValues.length; i += 2) {
                keys.push(fieldPathFromArgument(methodName, moreFieldsAndValues[i]));
                values$$1.push(moreFieldsAndValues[i + 1]);
            }

            var fieldMaskPaths = [];
            var updateData = ObjectValue.EMPTY;

            for (var i = 0; i < keys.length; ++i) {
                var path = keys[i];
                var childContext = context.childContextForFieldPath(path);
                var value_1 = this.runPreConverter(values$$1[i], childContext);

                if (value_1 instanceof DeleteFieldValueImpl) {
                    fieldMaskPaths.push(path);
                } else {
                    var parsedValue = this.parseData(value_1, childContext);

                    if (parsedValue != null) {
                        fieldMaskPaths.push(path);
                        updateData = updateData.set(path, parsedValue);
                    }
                }
            }

            var mask = new FieldMask(fieldMaskPaths);
            return new ParsedUpdateData(updateData, mask, context.fieldTransforms);
        };

        UserDataConverter.prototype.parseQueryValue = function (methodName, input) {
            var context = new ParseContext(UserDataSource.Argument, methodName, FieldPath.EMPTY_PATH);
            var parsed = this.parseData(input, context);
            assert(parsed != null, 'Parsed data should not be null.');
            assert(context.fieldTransforms.length === 0, 'Field transforms should have been disallowed.');
            return parsed;
        };

        UserDataConverter.prototype.runPreConverter = function (input, context) {
            try {
                return this.preConverter(input);
            } catch (e) {
                var message = errorMessage(e);
                throw context.createError(message);
            }
        };

        UserDataConverter.prototype.parseData = function (input, context) {
            input = this.runPreConverter(input, context);

            if (looksLikeJsonObject(input)) {
                validatePlainObject('Unsupported field value:', context, input);
                return this.parseObject(input, context);
            } else if (input instanceof FieldValueImpl) {
                this.parseSentinelFieldValue(input, context);
                return null;
            } else {
                if (context.path) {
                    context.fieldMask.push(context.path);
                }

                if (input instanceof Array) {
                    if (context.arrayElement) {
                        throw context.createError('Nested arrays are not supported');
                    }

                    return this.parseArray(input, context);
                } else {
                    return this.parseScalarValue(input, context);
                }
            }
        };

        UserDataConverter.prototype.parseObject = function (obj, context) {
            var _this = this;

            var result = new SortedMap(primitiveComparator);

            if (isEmpty(obj)) {
                if (context.path && context.path.length > 0) {
                    context.fieldMask.push(context.path);
                }
            } else {
                forEach(obj, function (key, val) {
                    var parsedValue = _this.parseData(val, context.childContextForField(key));

                    if (parsedValue != null) {
                        result = result.insert(key, parsedValue);
                    }
                });
            }

            return new ObjectValue(result);
        };

        UserDataConverter.prototype.parseArray = function (array, context) {
            var result = [];
            var entryIndex = 0;

            for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
                var entry = array_1[_i];
                var parsedEntry = this.parseData(entry, context.childContextForArray(entryIndex));

                if (parsedEntry == null) {
                    parsedEntry = NullValue.INSTANCE;
                }

                result.push(parsedEntry);
                entryIndex++;
            }

            return new ArrayValue(result);
        };

        UserDataConverter.prototype.parseSentinelFieldValue = function (value, context) {
            if (!isWrite(context.dataSource)) {
                throw context.createError(value._methodName + "() can only be used with update() and set()");
            }

            if (context.path === null) {
                throw context.createError(value._methodName + "() is not currently supported inside arrays");
            }

            if (value instanceof DeleteFieldValueImpl) {
                if (context.dataSource === UserDataSource.MergeSet) {
                    context.fieldMask.push(context.path);
                } else if (context.dataSource === UserDataSource.Update) {
                    assert(context.path.length > 0, 'FieldValue.delete() at the top level should have already' + ' been handled.');
                    throw context.createError('FieldValue.delete() can only appear at the top level ' + 'of your update data');
                } else {
                    throw context.createError('FieldValue.delete() cannot be used with set() unless you pass ' + '{merge:true}');
                }
            } else if (value instanceof ServerTimestampFieldValueImpl) {
                context.fieldTransforms.push(new FieldTransform(context.path, ServerTimestampTransform.instance));
            } else if (value instanceof ArrayUnionFieldValueImpl) {
                var parsedElements = this.parseArrayTransformElements(value._methodName, value._elements);
                var arrayUnion = new ArrayUnionTransformOperation(parsedElements);
                context.fieldTransforms.push(new FieldTransform(context.path, arrayUnion));
            } else if (value instanceof ArrayRemoveFieldValueImpl) {
                var parsedElements = this.parseArrayTransformElements(value._methodName, value._elements);
                var arrayRemove = new ArrayRemoveTransformOperation(parsedElements);
                context.fieldTransforms.push(new FieldTransform(context.path, arrayRemove));
            } else {
                fail('Unknown FieldValue type: ' + value);
            }
        };

        UserDataConverter.prototype.parseScalarValue = function (value, context) {
            if (value === null) {
                return NullValue.INSTANCE;
            } else if (typeof value === 'number') {
                if (isSafeInteger(value)) {
                    return new IntegerValue(value);
                } else {
                    return new DoubleValue(value);
                }
            } else if (typeof value === 'boolean') {
                return BooleanValue.of(value);
            } else if (typeof value === 'string') {
                return new StringValue(value);
            } else if (value instanceof Date) {
                return new TimestampValue(Timestamp.fromDate(value));
            } else if (value instanceof Timestamp) {
                return new TimestampValue(new Timestamp(value.seconds, Math.floor(value.nanoseconds / 1000) * 1000));
            } else if (value instanceof GeoPoint) {
                return new GeoPointValue(value);
            } else if (value instanceof Blob) {
                return new BlobValue(value);
            } else if (value instanceof DocumentKeyReference) {
                return new RefValue(value.databaseId, value.key);
            } else {
                throw context.createError("Unsupported field value: " + valueDescription(value));
            }
        };

        UserDataConverter.prototype.parseArrayTransformElements = function (methodName, elements) {
            var _this = this;

            return elements.map(function (element, i) {
                var context = new ParseContext(UserDataSource.Argument, methodName, FieldPath.EMPTY_PATH);
                return _this.parseData(element, context.childContextForArray(i));
            });
        };

        return UserDataConverter;
    }();

    function looksLikeJsonObject(input) {
        return typeof input === 'object' && input !== null && !(input instanceof Array) && !(input instanceof Date) && !(input instanceof Timestamp) && !(input instanceof GeoPoint) && !(input instanceof Blob) && !(input instanceof DocumentKeyReference) && !(input instanceof FieldValueImpl);
    }

    function validatePlainObject(message, context, input) {
        if (!looksLikeJsonObject(input) || !isPlainObject(input)) {
            var description = valueDescription(input);

            if (description === 'an object') {
                throw context.createError(message + ' a custom object');
            } else {
                throw context.createError(message + ' ' + description);
            }
        }
    }

    function fieldPathFromArgument(methodName, path) {
        if (path instanceof FieldPath$1) {
            return path._internalPath;
        } else if (typeof path === 'string') {
            return fieldPathFromDotSeparatedString(methodName, path);
        } else {
            var message = 'Field path arguments must be of type string or FieldPath.';
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + methodName + "() called with invalid data. " + message);
        }
    }

    function fieldPathFromDotSeparatedString(methodName, path) {
        try {
            return fromDotSeparatedString(path)._internalPath;
        } catch (e) {
            var message = errorMessage(e);
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + methodName + "() called with invalid data. " + message);
        }
    }

    function errorMessage(error) {
        return error instanceof Error ? error.message : error.toString();
    }

    var DEFAULT_HOST = 'firestore.googleapis.com';
    var DEFAULT_SSL = true;
    var DEFAULT_TIMESTAMPS_IN_SNAPSHOTS = false;
    var DEFAULT_SYNCHRONIZE_TABS = false;

    var FirestoreSettings = function () {
        function FirestoreSettings(settings) {
            if (settings.host === undefined) {
                if (settings.ssl !== undefined) {
                    throw new FirestoreError(Code.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
                }

                this.host = DEFAULT_HOST;
                this.ssl = DEFAULT_SSL;
            } else {
                validateNamedType('settings', 'non-empty string', 'host', settings.host);
                this.host = settings.host;
                validateNamedOptionalType('settings', 'boolean', 'ssl', settings.ssl);
                this.ssl = defaulted(settings.ssl, DEFAULT_SSL);
            }

            validateOptionNames('settings', settings, ['host', 'ssl', 'credentials', 'timestampsInSnapshots']);
            validateNamedOptionalType('settings', 'object', 'credentials', settings.credentials);
            this.credentials = settings.credentials;
            validateNamedOptionalType('settings', 'boolean', 'timestampsInSnapshots', settings.timestampsInSnapshots);
            this.timestampsInSnapshots = defaulted(settings.timestampsInSnapshots, DEFAULT_TIMESTAMPS_IN_SNAPSHOTS);
        }

        FirestoreSettings.prototype.isEqual = function (other) {
            return this.host === other.host && this.ssl === other.ssl && this.timestampsInSnapshots === other.timestampsInSnapshots && this.credentials === other.credentials;
        };

        return FirestoreSettings;
    }();

    var FirestoreConfig = function () {
        function FirestoreConfig() {}

        return FirestoreConfig;
    }();

    var PersistenceSettings = function () {
        function PersistenceSettings(enabled, settings) {
            this.enabled = enabled;
            assert(enabled || !settings, 'Can only provide PersistenceSettings with persistence enabled');
            settings = settings || {};
            this.experimentalTabSynchronization = defaulted(settings.experimentalTabSynchronization, DEFAULT_SYNCHRONIZE_TABS);
        }

        PersistenceSettings.prototype.isEqual = function (other) {
            return this.enabled === other.enabled && this.experimentalTabSynchronization === other.experimentalTabSynchronization;
        };

        return PersistenceSettings;
    }();

    var Firestore = function () {
        function Firestore(databaseIdOrApp) {
            var _this = this;

            this._queue = new AsyncQueue();
            this.INTERNAL = {
                delete: function _delete(options) {
                    return tslib_1.__awaiter(_this, void 0, void 0, function () {
                        return tslib_1.__generator(this, function (_a) {
                            if (this._firestoreClient) {
                                return [2, this._firestoreClient.shutdown(options)];
                            }

                            return [2];
                        });
                    });
                }
            };
            var config = new FirestoreConfig();

            if (typeof databaseIdOrApp.options === 'object') {
                var app = databaseIdOrApp;
                config.firebaseApp = app;
                config.databaseId = Firestore.databaseIdFromApp(app);
                config.persistenceKey = config.firebaseApp.name;
                config.credentials = new FirebaseCredentialsProvider(app);
            } else {
                var external_1 = databaseIdOrApp;

                if (!external_1.projectId) {
                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide projectId');
                }

                config.databaseId = new DatabaseId(external_1.projectId, external_1.database);
                config.persistenceKey = '[DEFAULT]';
                config.credentials = new EmptyCredentialsProvider();
            }

            config.settings = new FirestoreSettings({});
            this._config = config;
            this._databaseId = config.databaseId;
        }

        Firestore.prototype.settings = function (settingsLiteral) {
            validateExactNumberOfArgs('Firestore.settings', arguments, 1);
            validateArgType('Firestore.settings', 'object', 1, settingsLiteral);

            if (contains(settingsLiteral, 'persistence')) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, '"persistence" is now specified with a separate call to ' + 'firestore.enablePersistence().');
            }

            var newSettings = new FirestoreSettings(settingsLiteral);

            if (this._firestoreClient && !this._config.settings.isEqual(newSettings)) {
                throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and its settings can no longer ' + 'be changed. You can only call settings() before calling any other ' + 'methods on a Firestore object.');
            }

            this._config.settings = newSettings;

            if (newSettings.credentials !== undefined) {
                this._config.credentials = makeCredentialsProvider(newSettings.credentials);
            }
        };

        Firestore.prototype.enableNetwork = function () {
            this.ensureClientConfigured();
            return this._firestoreClient.enableNetwork();
        };

        Firestore.prototype.disableNetwork = function () {
            this.ensureClientConfigured();
            return this._firestoreClient.disableNetwork();
        };

        Firestore.prototype.enablePersistence = function (settings) {
            if (this._firestoreClient) {
                throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and persistence can no longer ' + 'be enabled. You can only call enablePersistence() before calling ' + 'any other methods on a Firestore object.');
            }

            return this.configureClient(new PersistenceSettings(true, settings));
        };

        Firestore.prototype.ensureClientConfigured = function () {
            if (!this._firestoreClient) {
                this.configureClient(new PersistenceSettings(false));
            }

            return this._firestoreClient;
        };

        Firestore.prototype.configureClient = function (persistenceSettings) {
            var _this = this;

            assert(!!this._config.settings.host, 'FirestoreSettings.host cannot be falsey');

            if (!this._config.settings.timestampsInSnapshots) {
                error("\nThe behavior for Date objects stored in Firestore is going to change\nAND YOUR APP MAY BREAK.\nTo hide this warning and ensure your app does not break, you need to add the\nfollowing code to your app before calling any other Cloud Firestore methods:\n\n  const firestore = firebase.firestore();\n  const settings = {/* your settings... */ timestampsInSnapshots: true};\n  firestore.settings(settings);\n\nWith this change, timestamps stored in Cloud Firestore will be read back as\nFirebase Timestamp objects instead of as system Date objects. So you will also\nneed to update code expecting a Date to instead expect a Timestamp. For example:\n\n  // Old:\n  const date = snapshot.get('created_at');\n  // New:\n  const timestamp = snapshot.get('created_at');\n  const date = timestamp.toDate();\n\nPlease audit all existing usages of Date when you enable the new behavior. In a\nfuture release, the behavior will change to the new behavior, so if you do not\nfollow these steps, YOUR APP MAY BREAK.");
            }

            assert(!this._firestoreClient, 'configureClient() called multiple times');
            var databaseInfo = new DatabaseInfo(this._config.databaseId, this._config.persistenceKey, this._config.settings.host, this._config.settings.ssl);

            var preConverter = function preConverter(value) {
                if (value instanceof DocumentReference) {
                    var thisDb = _this._config.databaseId;
                    var otherDb = value.firestore._config.databaseId;

                    if (!otherDb.isEqual(thisDb)) {
                        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Document reference is for database ' + (otherDb.projectId + "/" + otherDb.database + " but should be ") + ("for database " + thisDb.projectId + "/" + thisDb.database));
                    }

                    return new DocumentKeyReference(_this._config.databaseId, value._key);
                } else {
                    return value;
                }
            };

            this._dataConverter = new UserDataConverter(preConverter);
            this._firestoreClient = new FirestoreClient(PlatformSupport.getPlatform(), databaseInfo, this._config.credentials, this._queue);
            return this._firestoreClient.start(persistenceSettings);
        };

        Firestore.databaseIdFromApp = function (app) {
            var options = app.options;

            if (!contains(options, 'projectId')) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
            }

            var projectId = options['projectId'];

            if (!projectId || typeof projectId !== 'string') {
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'projectId must be a string in FirebaseApp.options');
            }

            return new DatabaseId(projectId);
        };

        Object.defineProperty(Firestore.prototype, "app", {
            get: function get() {
                if (!this._config.firebaseApp) {
                    throw new FirestoreError(Code.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is " + 'not available');
                }

                return this._config.firebaseApp;
            },
            enumerable: true,
            configurable: true
        });

        Firestore.prototype.collection = function (pathString) {
            validateExactNumberOfArgs('Firestore.collection', arguments, 1);
            validateArgType('Firestore.collection', 'non-empty string', 1, pathString);

            if (!pathString) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty collection path to collection()');
            }

            this.ensureClientConfigured();
            return new CollectionReference(ResourcePath.fromString(pathString), this);
        };

        Firestore.prototype.doc = function (pathString) {
            validateExactNumberOfArgs('Firestore.doc', arguments, 1);
            validateArgType('Firestore.doc', 'non-empty string', 1, pathString);

            if (!pathString) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty document path to doc()');
            }

            this.ensureClientConfigured();
            return DocumentReference.forPath(ResourcePath.fromString(pathString), this);
        };

        Firestore.prototype.runTransaction = function (updateFunction) {
            var _this = this;

            validateExactNumberOfArgs('Firestore.runTransaction', arguments, 1);
            validateArgType('Firestore.runTransaction', 'function', 1, updateFunction);
            return this.ensureClientConfigured().transaction(function (transaction) {
                return updateFunction(new Transaction$1(_this, transaction));
            });
        };

        Firestore.prototype.batch = function () {
            this.ensureClientConfigured();
            return new WriteBatch(this);
        };

        Object.defineProperty(Firestore, "logLevel", {
            get: function get() {
                switch (getLogLevel()) {
                    case LogLevel.DEBUG:
                        return 'debug';

                    case LogLevel.ERROR:
                        return 'error';

                    case LogLevel.SILENT:
                        return 'silent';

                    default:
                        return fail('Unknown log level: ' + getLogLevel());
                }
            },
            enumerable: true,
            configurable: true
        });

        Firestore.setLogLevel = function (level) {
            validateExactNumberOfArgs('Firestore.setLogLevel', arguments, 1);
            validateArgType('Firestore.setLogLevel', 'non-empty string', 1, level);

            switch (level) {
                case 'debug':
                    setLogLevel(LogLevel.DEBUG);
                    break;

                case 'error':
                    setLogLevel(LogLevel.ERROR);
                    break;

                case 'silent':
                    setLogLevel(LogLevel.SILENT);
                    break;

                default:
                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid log level: ' + level);
            }
        };

        Firestore.prototype._areTimestampsInSnapshotsEnabled = function () {
            return this._config.settings.timestampsInSnapshots;
        };

        return Firestore;
    }();

    var Transaction$1 = function () {
        function Transaction(_firestore, _transaction) {
            this._firestore = _firestore;
            this._transaction = _transaction;
        }

        Transaction.prototype.get = function (documentRef) {
            var _this = this;

            validateExactNumberOfArgs('Transaction.get', arguments, 1);
            var ref = validateReference('Transaction.get', documentRef, this._firestore);
            return this._transaction.lookup([ref._key]).then(function (docs) {
                if (!docs || docs.length !== 1) {
                    return fail('Mismatch in docs returned from document lookup.');
                }

                var doc = docs[0];

                if (doc instanceof NoDocument) {
                    return new DocumentSnapshot(_this._firestore, ref._key, null, false, false);
                } else if (doc instanceof Document) {
                    return new DocumentSnapshot(_this._firestore, ref._key, doc, false, false);
                } else {
                    throw fail("BatchGetDocumentsRequest returned unexpected document type: " + doc.constructor.name);
                }
            });
        };

        Transaction.prototype.set = function (documentRef, value, options) {
            validateBetweenNumberOfArgs('Transaction.set', arguments, 2, 3);
            var ref = validateReference('Transaction.set', documentRef, this._firestore);
            options = validateSetOptions('Transaction.set', options);
            var parsed = options.merge || options.mergeFields ? this._firestore._dataConverter.parseMergeData('Transaction.set', value, options.mergeFields) : this._firestore._dataConverter.parseSetData('Transaction.set', value);

            this._transaction.set(ref._key, parsed);

            return this;
        };

        Transaction.prototype.update = function (documentRef, fieldOrUpdateData, value) {
            var moreFieldsAndValues = [];

            for (var _i = 3; _i < arguments.length; _i++) {
                moreFieldsAndValues[_i - 3] = arguments[_i];
            }

            var ref;
            var parsed;

            if (typeof fieldOrUpdateData === 'string' || fieldOrUpdateData instanceof FieldPath$1) {
                validateAtLeastNumberOfArgs('Transaction.update', arguments, 3);
                ref = validateReference('Transaction.update', documentRef, this._firestore);
                parsed = this._firestore._dataConverter.parseUpdateVarargs('Transaction.update', fieldOrUpdateData, value, moreFieldsAndValues);
            } else {
                validateExactNumberOfArgs('Transaction.update', arguments, 2);
                ref = validateReference('Transaction.update', documentRef, this._firestore);
                parsed = this._firestore._dataConverter.parseUpdateData('Transaction.update', fieldOrUpdateData);
            }

            this._transaction.update(ref._key, parsed);

            return this;
        };

        Transaction.prototype.delete = function (documentRef) {
            validateExactNumberOfArgs('Transaction.delete', arguments, 1);
            var ref = validateReference('Transaction.delete', documentRef, this._firestore);

            this._transaction.delete(ref._key);

            return this;
        };

        return Transaction;
    }();

    var WriteBatch = function () {
        function WriteBatch(_firestore) {
            this._firestore = _firestore;
            this._mutations = [];
            this._committed = false;
        }

        WriteBatch.prototype.set = function (documentRef, value, options) {
            validateBetweenNumberOfArgs('WriteBatch.set', arguments, 2, 3);
            this.verifyNotCommitted();
            var ref = validateReference('WriteBatch.set', documentRef, this._firestore);
            options = validateSetOptions('WriteBatch.set', options);
            var parsed = options.merge || options.mergeFields ? this._firestore._dataConverter.parseMergeData('WriteBatch.set', value, options.mergeFields) : this._firestore._dataConverter.parseSetData('WriteBatch.set', value);
            this._mutations = this._mutations.concat(parsed.toMutations(ref._key, Precondition.NONE));
            return this;
        };

        WriteBatch.prototype.update = function (documentRef, fieldOrUpdateData, value) {
            var moreFieldsAndValues = [];

            for (var _i = 3; _i < arguments.length; _i++) {
                moreFieldsAndValues[_i - 3] = arguments[_i];
            }

            this.verifyNotCommitted();
            var ref;
            var parsed;

            if (typeof fieldOrUpdateData === 'string' || fieldOrUpdateData instanceof FieldPath$1) {
                validateAtLeastNumberOfArgs('WriteBatch.update', arguments, 3);
                ref = validateReference('WriteBatch.update', documentRef, this._firestore);
                parsed = this._firestore._dataConverter.parseUpdateVarargs('WriteBatch.update', fieldOrUpdateData, value, moreFieldsAndValues);
            } else {
                validateExactNumberOfArgs('WriteBatch.update', arguments, 2);
                ref = validateReference('WriteBatch.update', documentRef, this._firestore);
                parsed = this._firestore._dataConverter.parseUpdateData('WriteBatch.update', fieldOrUpdateData);
            }

            this._mutations = this._mutations.concat(parsed.toMutations(ref._key, Precondition.exists(true)));
            return this;
        };

        WriteBatch.prototype.delete = function (documentRef) {
            validateExactNumberOfArgs('WriteBatch.delete', arguments, 1);
            this.verifyNotCommitted();
            var ref = validateReference('WriteBatch.delete', documentRef, this._firestore);
            this._mutations = this._mutations.concat(new DeleteMutation(ref._key, Precondition.NONE));
            return this;
        };

        WriteBatch.prototype.commit = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                return tslib_1.__generator(this, function (_a) {
                    this.verifyNotCommitted();
                    this._committed = true;

                    if (this._mutations.length > 0) {
                        return [2, this._firestore.ensureClientConfigured().write(this._mutations)];
                    }

                    return [2];
                });
            });
        };

        WriteBatch.prototype.verifyNotCommitted = function () {
            if (this._committed) {
                throw new FirestoreError(Code.FAILED_PRECONDITION, 'A write batch can no longer be used after commit() ' + 'has been called.');
            }
        };

        return WriteBatch;
    }();

    var DocumentReference = function () {
        function DocumentReference(_key, firestore) {
            this._key = _key;
            this.firestore = firestore;
            this._firestoreClient = this.firestore.ensureClientConfigured();
        }

        DocumentReference.forPath = function (path, firestore) {
            if (path.length % 2 !== 0) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid document reference. Document ' + 'references must have an even number of segments, but ' + (path.canonicalString() + " has " + path.length));
            }

            return new DocumentReference(new DocumentKey(path), firestore);
        };

        Object.defineProperty(DocumentReference.prototype, "id", {
            get: function get() {
                return this._key.path.lastSegment();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DocumentReference.prototype, "parent", {
            get: function get() {
                return new CollectionReference(this._key.path.popLast(), this.firestore);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DocumentReference.prototype, "path", {
            get: function get() {
                return this._key.path.canonicalString();
            },
            enumerable: true,
            configurable: true
        });

        DocumentReference.prototype.collection = function (pathString) {
            validateExactNumberOfArgs('DocumentReference.collection', arguments, 1);
            validateArgType('DocumentReference.collection', 'non-empty string', 1, pathString);

            if (!pathString) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty collection name to collection()');
            }

            var path = ResourcePath.fromString(pathString);
            return new CollectionReference(this._key.path.child(path), this.firestore);
        };

        DocumentReference.prototype.isEqual = function (other) {
            if (!(other instanceof DocumentReference)) {
                throw invalidClassError('isEqual', 'DocumentReference', 1, other);
            }

            return this.firestore === other.firestore && this._key.isEqual(other._key);
        };

        DocumentReference.prototype.set = function (value, options) {
            validateBetweenNumberOfArgs('DocumentReference.set', arguments, 1, 2);
            options = validateSetOptions('DocumentReference.set', options);
            var parsed = options.merge || options.mergeFields ? this.firestore._dataConverter.parseMergeData('DocumentReference.set', value, options.mergeFields) : this.firestore._dataConverter.parseSetData('DocumentReference.set', value);
            return this._firestoreClient.write(parsed.toMutations(this._key, Precondition.NONE));
        };

        DocumentReference.prototype.update = function (fieldOrUpdateData, value) {
            var moreFieldsAndValues = [];

            for (var _i = 2; _i < arguments.length; _i++) {
                moreFieldsAndValues[_i - 2] = arguments[_i];
            }

            var parsed;

            if (typeof fieldOrUpdateData === 'string' || fieldOrUpdateData instanceof FieldPath$1) {
                validateAtLeastNumberOfArgs('DocumentReference.update', arguments, 2);
                parsed = this.firestore._dataConverter.parseUpdateVarargs('DocumentReference.update', fieldOrUpdateData, value, moreFieldsAndValues);
            } else {
                validateExactNumberOfArgs('DocumentReference.update', arguments, 1);
                parsed = this.firestore._dataConverter.parseUpdateData('DocumentReference.update', fieldOrUpdateData);
            }

            return this._firestoreClient.write(parsed.toMutations(this._key, Precondition.exists(true)));
        };

        DocumentReference.prototype.delete = function () {
            validateExactNumberOfArgs('DocumentReference.delete', arguments, 0);
            return this._firestoreClient.write([new DeleteMutation(this._key, Precondition.NONE)]);
        };

        DocumentReference.prototype.onSnapshot = function () {
            var args = [];

            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }

            validateBetweenNumberOfArgs('DocumentReference.onSnapshot', arguments, 1, 4);
            var options = {
                includeMetadataChanges: false
            };
            var observer;
            var currArg = 0;

            if (typeof args[currArg] === 'object' && !isPartialObserver(args[currArg])) {
                options = args[currArg];
                validateOptionNames('DocumentReference.onSnapshot', options, ['includeMetadataChanges']);
                validateNamedOptionalType('DocumentReference.onSnapshot', 'boolean', 'includeMetadataChanges', options.includeMetadataChanges);
                currArg++;
            }

            var internalOptions = {
                includeMetadataChanges: options.includeMetadataChanges
            };

            if (isPartialObserver(args[currArg])) {
                observer = args[currArg];
            } else {
                validateArgType('DocumentReference.onSnapshot', 'function', currArg, args[currArg]);
                validateOptionalArgType('DocumentReference.onSnapshot', 'function', currArg + 1, args[currArg + 1]);
                validateOptionalArgType('DocumentReference.onSnapshot', 'function', currArg + 2, args[currArg + 2]);
                observer = {
                    next: args[currArg],
                    error: args[currArg + 1],
                    complete: args[currArg + 2]
                };
            }

            return this.onSnapshotInternal(internalOptions, observer);
        };

        DocumentReference.prototype.onSnapshotInternal = function (options, observer) {
            var _this = this;

            var errHandler = function errHandler(err) {
                console.error('Uncaught Error in onSnapshot:', err);
            };

            if (observer.error) {
                errHandler = observer.error.bind(observer);
            }

            var asyncObserver = new AsyncObserver({
                next: function next(snapshot) {
                    if (observer.next) {
                        assert(snapshot.docs.size <= 1, 'Too many documents returned on a document query');
                        var doc = snapshot.docs.get(_this._key);
                        observer.next(new DocumentSnapshot(_this.firestore, _this._key, doc, snapshot.fromCache, snapshot.hasPendingWrites));
                    }
                },
                error: errHandler
            });

            var internalListener = this._firestoreClient.listen(Query.atPath(this._key.path), asyncObserver, options);

            return function () {
                asyncObserver.mute();

                _this._firestoreClient.unlisten(internalListener);
            };
        };

        DocumentReference.prototype.get = function (options) {
            var _this = this;

            validateBetweenNumberOfArgs('DocumentReference.get', arguments, 0, 1);
            validateGetOptions('DocumentReference.get', options);
            return new Promise(function (resolve, reject) {
                if (options && options.source === 'cache') {
                    _this.firestore.ensureClientConfigured().getDocumentFromLocalCache(_this._key).then(function (doc) {
                        resolve(new DocumentSnapshot(_this.firestore, _this._key, doc, true, doc instanceof Document ? doc.hasLocalMutations : false));
                    }, reject);
                } else {
                    _this.getViaSnapshotListener(resolve, reject, options);
                }
            });
        };

        DocumentReference.prototype.getViaSnapshotListener = function (resolve, reject, options) {
            var unlisten = this.onSnapshotInternal({
                includeMetadataChanges: true,
                waitForSyncWhenOnline: true
            }, {
                next: function next(snap) {
                    unlisten();

                    if (!snap.exists && snap.metadata.fromCache) {
                        reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document because the client is ' + 'offline.'));
                    } else if (snap.exists && snap.metadata.fromCache && options && options.source === 'server') {
                        reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document from server. (However, this ' + 'document does exist in the local cache. Run again ' + 'without setting source to "server" to ' + 'retrieve the cached document.)'));
                    } else {
                        resolve(snap);
                    }
                },
                error: reject
            });
        };

        return DocumentReference;
    }();

    var SnapshotMetadata = function () {
        function SnapshotMetadata(hasPendingWrites, fromCache) {
            this.hasPendingWrites = hasPendingWrites;
            this.fromCache = fromCache;
        }

        SnapshotMetadata.prototype.isEqual = function (other) {
            return this.hasPendingWrites === other.hasPendingWrites && this.fromCache === other.fromCache;
        };

        return SnapshotMetadata;
    }();

    var DocumentSnapshot = function () {
        function DocumentSnapshot(_firestore, _key, _document, _fromCache, _hasPendingWrites) {
            this._firestore = _firestore;
            this._key = _key;
            this._document = _document;
            this._fromCache = _fromCache;
            this._hasPendingWrites = _hasPendingWrites;
        }

        DocumentSnapshot.prototype.data = function (options) {
            validateBetweenNumberOfArgs('DocumentSnapshot.data', arguments, 0, 1);
            options = validateSnapshotOptions('DocumentSnapshot.data', options);
            return !this._document ? undefined : this.convertObject(this._document.data, FieldValueOptions.fromSnapshotOptions(options, this._firestore._areTimestampsInSnapshotsEnabled()));
        };

        DocumentSnapshot.prototype.get = function (fieldPath, options) {
            validateBetweenNumberOfArgs('DocumentSnapshot.get', arguments, 1, 2);
            options = validateSnapshotOptions('DocumentSnapshot.get', options);

            if (this._document) {
                var value = this._document.data.field(fieldPathFromArgument('DocumentSnapshot.get', fieldPath));

                if (value !== undefined) {
                    return this.convertValue(value, FieldValueOptions.fromSnapshotOptions(options, this._firestore._areTimestampsInSnapshotsEnabled()));
                }
            }

            return undefined;
        };

        Object.defineProperty(DocumentSnapshot.prototype, "id", {
            get: function get() {
                return this._key.path.lastSegment();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DocumentSnapshot.prototype, "ref", {
            get: function get() {
                return new DocumentReference(this._key, this._firestore);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DocumentSnapshot.prototype, "exists", {
            get: function get() {
                return this._document !== null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DocumentSnapshot.prototype, "metadata", {
            get: function get() {
                return new SnapshotMetadata(this._hasPendingWrites, this._fromCache);
            },
            enumerable: true,
            configurable: true
        });

        DocumentSnapshot.prototype.isEqual = function (other) {
            if (!(other instanceof DocumentSnapshot)) {
                throw invalidClassError('isEqual', 'DocumentSnapshot', 1, other);
            }

            return this._firestore === other._firestore && this._fromCache === other._fromCache && this._key.isEqual(other._key) && (this._document === null ? other._document === null : this._document.isEqual(other._document));
        };

        DocumentSnapshot.prototype.convertObject = function (data, options) {
            var _this = this;

            var result = {};
            data.forEach(function (key, value) {
                result[key] = _this.convertValue(value, options);
            });
            return result;
        };

        DocumentSnapshot.prototype.convertValue = function (value, options) {
            if (value instanceof ObjectValue) {
                return this.convertObject(value, options);
            } else if (value instanceof ArrayValue) {
                return this.convertArray(value, options);
            } else if (value instanceof RefValue) {
                var key = value.value(options);

                var database = this._firestore.ensureClientConfigured().databaseId();

                if (!value.databaseId.isEqual(database)) {
                    error("Document " + this._key.path + " contains a document " + "reference within a different database (" + (value.databaseId.projectId + "/" + value.databaseId.database + ") which is not ") + "supported. It will be treated as a reference in the current " + ("database (" + database.projectId + "/" + database.database + ") ") + "instead.");
                }

                return new DocumentReference(key, this._firestore);
            } else {
                return value.value(options);
            }
        };

        DocumentSnapshot.prototype.convertArray = function (data, options) {
            var _this = this;

            return data.internalValue.map(function (value) {
                return _this.convertValue(value, options);
            });
        };

        return DocumentSnapshot;
    }();

    var QueryDocumentSnapshot = function (_super) {
        tslib_1.__extends(QueryDocumentSnapshot, _super);

        function QueryDocumentSnapshot(firestore, key, document, fromCache, hasPendingWrites) {
            return _super.call(this, firestore, key, document, fromCache, hasPendingWrites) || this;
        }

        QueryDocumentSnapshot.prototype.data = function (options) {
            var data = _super.prototype.data.call(this, options);

            assert(typeof data === 'object', 'Document in a QueryDocumentSnapshot should exist');
            return data;
        };

        return QueryDocumentSnapshot;
    }(DocumentSnapshot);

    var Query$1 = function () {
        function Query$$1(_query, firestore) {
            this._query = _query;
            this.firestore = firestore;
        }

        Query$$1.prototype.where = function (field, opStr, value) {
            validateExactNumberOfArgs('Query.where', arguments, 3);
            validateArgType('Query.where', 'non-empty string', 2, opStr);
            validateDefined('Query.where', 3, value);
            var fieldValue;
            var fieldPath = fieldPathFromArgument('Query.where', field);
            var relationOp = RelationOp.fromString(opStr);

            if (fieldPath.isKeyField()) {
                if (relationOp === RelationOp.ARRAY_CONTAINS) {
                    throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid Query. You can't perform array-contains queries on " + 'FieldPath.documentId() since document IDs are not arrays.');
                }

                if (typeof value === 'string') {
                    if (value.indexOf('/') !== -1) {
                        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Function Query.where() requires its third parameter to be a ' + 'valid document ID if the first parameter is ' + 'FieldPath.documentId(), but it contains a slash.');
                    }

                    if (value === '') {
                        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Function Query.where() requires its third parameter to be a ' + 'valid document ID if the first parameter is ' + 'FieldPath.documentId(), but it was an empty string.');
                    }

                    var path = this._query.path.child(new ResourcePath([value]));

                    assert(path.length % 2 === 0, 'Path should be a document key');
                    fieldValue = new RefValue(this.firestore._databaseId, new DocumentKey(path));
                } else if (value instanceof DocumentReference) {
                    var ref = value;
                    fieldValue = new RefValue(this.firestore._databaseId, ref._key);
                } else {
                    throw new FirestoreError(Code.INVALID_ARGUMENT, "Function Query.where() requires its third parameter to be a " + "string or a DocumentReference if the first parameter is " + "FieldPath.documentId(), but it was: " + (valueDescription(value) + "."));
                }
            } else {
                fieldValue = this.firestore._dataConverter.parseQueryValue('Query.where', value);
            }

            var filter = Filter.create(fieldPath, relationOp, fieldValue);
            this.validateNewFilter(filter);
            return new Query$$1(this._query.addFilter(filter), this.firestore);
        };

        Query$$1.prototype.orderBy = function (field, directionStr) {
            validateBetweenNumberOfArgs('Query.orderBy', arguments, 1, 2);
            validateOptionalArgType('Query.orderBy', 'non-empty string', 2, directionStr);
            var direction;

            if (directionStr === undefined || directionStr === 'asc') {
                direction = Direction.ASCENDING;
            } else if (directionStr === 'desc') {
                direction = Direction.DESCENDING;
            } else {
                throw new FirestoreError(Code.INVALID_ARGUMENT, "Function Query.orderBy() has unknown direction '" + directionStr + "', " + "expected 'asc' or 'desc'.");
            }

            if (this._query.startAt !== null) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call Query.startAt() or ' + 'Query.startAfter() before calling Query.orderBy().');
            }

            if (this._query.endAt !== null) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call Query.endAt() or ' + 'Query.endBefore() before calling Query.orderBy().');
            }

            var fieldPath = fieldPathFromArgument('Query.orderBy', field);
            var orderBy = new OrderBy(fieldPath, direction);
            this.validateNewOrderBy(orderBy);
            return new Query$$1(this._query.addOrderBy(orderBy), this.firestore);
        };

        Query$$1.prototype.limit = function (n) {
            validateExactNumberOfArgs('Query.limit', arguments, 1);
            validateArgType('Query.limit', 'number', 1, n);

            if (n <= 0) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid Query. Query limit (" + n + ") is invalid. Limit must be " + 'positive.');
            }

            return new Query$$1(this._query.withLimit(n), this.firestore);
        };

        Query$$1.prototype.startAt = function (docOrField) {
            var fields = [];

            for (var _i = 1; _i < arguments.length; _i++) {
                fields[_i - 1] = arguments[_i];
            }

            validateAtLeastNumberOfArgs('Query.startAt', arguments, 1);
            var bound = this.boundFromDocOrFields('Query.startAt', docOrField, fields, true);
            return new Query$$1(this._query.withStartAt(bound), this.firestore);
        };

        Query$$1.prototype.startAfter = function (docOrField) {
            var fields = [];

            for (var _i = 1; _i < arguments.length; _i++) {
                fields[_i - 1] = arguments[_i];
            }

            validateAtLeastNumberOfArgs('Query.startAfter', arguments, 1);
            var bound = this.boundFromDocOrFields('Query.startAfter', docOrField, fields, false);
            return new Query$$1(this._query.withStartAt(bound), this.firestore);
        };

        Query$$1.prototype.endBefore = function (docOrField) {
            var fields = [];

            for (var _i = 1; _i < arguments.length; _i++) {
                fields[_i - 1] = arguments[_i];
            }

            validateAtLeastNumberOfArgs('Query.endBefore', arguments, 1);
            var bound = this.boundFromDocOrFields('Query.endBefore', docOrField, fields, true);
            return new Query$$1(this._query.withEndAt(bound), this.firestore);
        };

        Query$$1.prototype.endAt = function (docOrField) {
            var fields = [];

            for (var _i = 1; _i < arguments.length; _i++) {
                fields[_i - 1] = arguments[_i];
            }

            validateAtLeastNumberOfArgs('Query.endAt', arguments, 1);
            var bound = this.boundFromDocOrFields('Query.endAt', docOrField, fields, false);
            return new Query$$1(this._query.withEndAt(bound), this.firestore);
        };

        Query$$1.prototype.isEqual = function (other) {
            if (!(other instanceof Query$$1)) {
                throw invalidClassError('isEqual', 'Query', 1, other);
            }

            return this.firestore === other.firestore && this._query.isEqual(other._query);
        };

        Query$$1.prototype.boundFromDocOrFields = function (methodName, docOrField, fields, before) {
            validateDefined(methodName, 1, docOrField);

            if (docOrField instanceof DocumentSnapshot) {
                if (fields.length > 0) {
                    throw new FirestoreError(Code.INVALID_ARGUMENT, "Too many arguments provided to " + methodName + "().");
                }

                var snap = docOrField;

                if (!snap.exists) {
                    throw new FirestoreError(Code.NOT_FOUND, "Can't use a DocumentSnapshot that doesn't exist for " + (methodName + "()."));
                }

                return this.boundFromDocument(methodName, snap._document, before);
            } else {
                var allFields = [docOrField].concat(fields);
                return this.boundFromFields(methodName, allFields, before);
            }
        };

        Query$$1.prototype.boundFromDocument = function (methodName, doc, before) {
            var components = [];

            for (var _i = 0, _a = this._query.orderBy; _i < _a.length; _i++) {
                var orderBy = _a[_i];

                if (orderBy.field.isKeyField()) {
                    components.push(new RefValue(this.firestore._databaseId, doc.key));
                } else {
                    var value = doc.field(orderBy.field);

                    if (value !== undefined) {
                        components.push(value);
                    } else {
                        var field = orderBy.field.canonicalString();
                        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You are trying to start or end a query using a " + ("document for which the field '" + field + "' (used as the ") + "orderBy) does not exist.");
                    }
                }
            }

            return new Bound(components, before);
        };

        Query$$1.prototype.boundFromFields = function (methodName, values$$1, before) {
            var orderBy = this._query.explicitOrderBy;

            if (values$$1.length > orderBy.length) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, "Too many arguments provided to " + methodName + "(). " + "The number of arguments must be less than or equal to the " + "number of Query.orderBy() clauses");
            }

            var components = [];

            for (var i = 0; i < values$$1.length; i++) {
                var rawValue = values$$1[i];
                var orderByComponent = orderBy[i];

                if (orderByComponent.field.isKeyField()) {
                    if (typeof rawValue !== 'string') {
                        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. Expected a string for document ID in " + (methodName + "(), but got a " + typeof rawValue));
                    }

                    if (rawValue.indexOf('/') !== -1) {
                        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. Document ID '" + rawValue + "' contains a slash in " + (methodName + "()"));
                    }

                    var key = new DocumentKey(this._query.path.child(rawValue));
                    components.push(new RefValue(this.firestore._databaseId, key));
                } else {
                    var wrapped = this.firestore._dataConverter.parseQueryValue(methodName, rawValue);

                    components.push(wrapped);
                }
            }

            return new Bound(components, before);
        };

        Query$$1.prototype.onSnapshot = function () {
            var args = [];

            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }

            validateBetweenNumberOfArgs('Query.onSnapshot', arguments, 1, 4);
            var options = {};
            var observer;
            var currArg = 0;

            if (typeof args[currArg] === 'object' && !isPartialObserver(args[currArg])) {
                options = args[currArg];
                validateOptionNames('Query.onSnapshot', options, ['includeMetadataChanges']);
                validateNamedOptionalType('Query.onSnapshot', 'boolean', 'includeMetadataChanges', options.includeMetadataChanges);
                currArg++;
            }

            if (isPartialObserver(args[currArg])) {
                observer = args[currArg];
            } else {
                validateArgType('Query.onSnapshot', 'function', currArg, args[currArg]);
                validateOptionalArgType('Query.onSnapshot', 'function', currArg + 1, args[currArg + 1]);
                validateOptionalArgType('Query.onSnapshot', 'function', currArg + 2, args[currArg + 2]);
                observer = {
                    next: args[currArg],
                    error: args[currArg + 1],
                    complete: args[currArg + 2]
                };
            }

            return this.onSnapshotInternal(options, observer);
        };

        Query$$1.prototype.onSnapshotInternal = function (options, observer) {
            var _this = this;

            var errHandler = function errHandler(err) {
                console.error('Uncaught Error in onSnapshot:', err);
            };

            if (observer.error) {
                errHandler = observer.error.bind(observer);
            }

            var asyncObserver = new AsyncObserver({
                next: function next(result) {
                    if (observer.next) {
                        observer.next(new QuerySnapshot(_this.firestore, _this._query, result));
                    }
                },
                error: errHandler
            });
            var firestoreClient = this.firestore.ensureClientConfigured();
            var internalListener = firestoreClient.listen(this._query, asyncObserver, options);
            return function () {
                asyncObserver.mute();
                firestoreClient.unlisten(internalListener);
            };
        };

        Query$$1.prototype.get = function (options) {
            var _this = this;

            validateBetweenNumberOfArgs('Query.get', arguments, 0, 1);
            validateGetOptions('Query.get', options);
            return new Promise(function (resolve, reject) {
                if (options && options.source === 'cache') {
                    _this.firestore.ensureClientConfigured().getDocumentsFromLocalCache(_this._query).then(function (viewSnap) {
                        resolve(new QuerySnapshot(_this.firestore, _this._query, viewSnap));
                    }, reject);
                } else {
                    _this.getViaSnapshotListener(resolve, reject, options);
                }
            });
        };

        Query$$1.prototype.getViaSnapshotListener = function (resolve, reject, options) {
            var unlisten = this.onSnapshotInternal({
                includeMetadataChanges: true,
                waitForSyncWhenOnline: true
            }, {
                next: function next(result) {
                    unlisten();

                    if (result.metadata.fromCache && options && options.source === 'server') {
                        reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get documents from server. (However, these ' + 'documents may exist in the local cache. Run again ' + 'without setting source to "server" to ' + 'retrieve the cached documents.)'));
                    } else {
                        resolve(result);
                    }
                },
                error: reject
            });
        };

        Query$$1.prototype.validateNewFilter = function (filter) {
            if (filter instanceof RelationFilter) {
                if (filter.isInequality()) {
                    var existingField = this._query.getInequalityFilterField();

                    if (existingField !== null && !existingField.isEqual(filter.field)) {
                        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. All where filters with an inequality' + ' (<, <=, >, or >=) must be on the same field. But you have' + (" inequality filters on '" + existingField.toString() + "'") + (" and '" + filter.field.toString() + "'"));
                    }

                    var firstOrderByField = this._query.getFirstOrderByField();

                    if (firstOrderByField !== null) {
                        this.validateOrderByAndInequalityMatch(filter.field, firstOrderByField);
                    }
                } else if (filter.op === RelationOp.ARRAY_CONTAINS) {
                    if (this._query.hasArrayContainsFilter()) {
                        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. Queries only support a single array-contains ' + 'filter.');
                    }
                }
            }
        };

        Query$$1.prototype.validateNewOrderBy = function (orderBy) {
            if (this._query.getFirstOrderByField() === null) {
                var inequalityField = this._query.getInequalityFilterField();

                if (inequalityField !== null) {
                    this.validateOrderByAndInequalityMatch(inequalityField, orderBy.field);
                }
            }
        };

        Query$$1.prototype.validateOrderByAndInequalityMatch = function (inequality, orderBy) {
            if (!orderBy.isEqual(inequality)) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You have a where filter with an inequality " + ("(<, <=, >, or >=) on field '" + inequality.toString() + "' ") + ("and so you must also use '" + inequality.toString() + "' ") + "as your first Query.orderBy(), but your first Query.orderBy() " + ("is on field '" + orderBy.toString() + "' instead."));
            }
        };

        return Query$$1;
    }();

    var QuerySnapshot = function () {
        function QuerySnapshot(_firestore, _originalQuery, _snapshot) {
            this._firestore = _firestore;
            this._originalQuery = _originalQuery;
            this._snapshot = _snapshot;
            this._cachedChanges = null;
            this._cachedChangesIncludeMetadataChanges = null;
            this.metadata = new SnapshotMetadata(_snapshot.hasPendingWrites, _snapshot.fromCache);
        }

        Object.defineProperty(QuerySnapshot.prototype, "docs", {
            get: function get() {
                var result = [];
                this.forEach(function (doc) {
                    return result.push(doc);
                });
                return result;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuerySnapshot.prototype, "empty", {
            get: function get() {
                return this._snapshot.docs.isEmpty();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuerySnapshot.prototype, "size", {
            get: function get() {
                return this._snapshot.docs.size;
            },
            enumerable: true,
            configurable: true
        });

        QuerySnapshot.prototype.forEach = function (callback, thisArg) {
            var _this = this;

            validateBetweenNumberOfArgs('QuerySnapshot.forEach', arguments, 1, 2);
            validateArgType('QuerySnapshot.forEach', 'function', 1, callback);

            this._snapshot.docs.forEach(function (doc) {
                callback.call(thisArg, _this.convertToDocumentImpl(doc));
            });
        };

        Object.defineProperty(QuerySnapshot.prototype, "query", {
            get: function get() {
                return new Query$1(this._originalQuery, this._firestore);
            },
            enumerable: true,
            configurable: true
        });

        QuerySnapshot.prototype.docChanges = function (options) {
            if (options) {
                validateOptionNames('QuerySnapshot.docChanges', options, ['includeMetadataChanges']);
                validateNamedOptionalType('QuerySnapshot.docChanges', 'boolean', 'includeMetadataChanges', options.includeMetadataChanges);
            }

            var includeMetadataChanges = !!(options && options.includeMetadataChanges);

            if (includeMetadataChanges && this._snapshot.excludesMetadataChanges) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'To include metadata changes with your document changes, you must ' + 'also pass { includeMetadataChanges:true } to onSnapshot().');
            }

            if (!this._cachedChanges || this._cachedChangesIncludeMetadataChanges !== includeMetadataChanges) {
                this._cachedChanges = changesFromSnapshot(this._firestore, includeMetadataChanges, this._snapshot);
                this._cachedChangesIncludeMetadataChanges = includeMetadataChanges;
            }

            return this._cachedChanges;
        };

        QuerySnapshot.prototype.isEqual = function (other) {
            if (!(other instanceof QuerySnapshot)) {
                throw invalidClassError('isEqual', 'QuerySnapshot', 1, other);
            }

            return this._firestore === other._firestore && this._originalQuery.isEqual(other._originalQuery) && this._snapshot.isEqual(other._snapshot);
        };

        QuerySnapshot.prototype.convertToDocumentImpl = function (doc) {
            return new QueryDocumentSnapshot(this._firestore, doc.key, doc, this.metadata.fromCache, this._snapshot.mutatedKeys.has(doc.key));
        };

        return QuerySnapshot;
    }();

    function throwDocChangesMethodError() {
        throw new FirestoreError(Code.INVALID_ARGUMENT, 'QuerySnapshot.docChanges has been changed from a property into a ' + 'method, so usages like "querySnapshot.docChanges" should become ' + '"querySnapshot.docChanges()"');
    }

    var docChangesPropertiesToOverride = ['length', 'forEach', 'map'].concat(typeof Symbol !== 'undefined' ? [typeof Symbol === "function" ? Symbol.iterator : "@@iterator"] : []);
    docChangesPropertiesToOverride.forEach(function (property) {
        try {
            Object.defineProperty(QuerySnapshot.prototype.docChanges, property, {
                get: function get() {
                    return throwDocChangesMethodError();
                }
            });
        } catch (err) {}
    });

    var CollectionReference = function (_super) {
        tslib_1.__extends(CollectionReference, _super);

        function CollectionReference(path, firestore) {
            var _this = _super.call(this, Query.atPath(path), firestore) || this;

            if (path.length % 2 !== 1) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid collection reference. Collection ' + 'references must have an odd number of segments, but ' + (path.canonicalString() + " has " + path.length));
            }

            return _this;
        }

        Object.defineProperty(CollectionReference.prototype, "id", {
            get: function get() {
                return this._query.path.lastSegment();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CollectionReference.prototype, "parent", {
            get: function get() {
                var parentPath = this._query.path.popLast();

                if (parentPath.isEmpty()) {
                    return null;
                } else {
                    return new DocumentReference(new DocumentKey(parentPath), this.firestore);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CollectionReference.prototype, "path", {
            get: function get() {
                return this._query.path.canonicalString();
            },
            enumerable: true,
            configurable: true
        });

        CollectionReference.prototype.doc = function (pathString) {
            validateBetweenNumberOfArgs('CollectionReference.doc', arguments, 0, 1);

            if (arguments.length === 0) {
                pathString = AutoId.newId();
            }

            validateArgType('CollectionReference.doc', 'non-empty string', 1, pathString);

            if (pathString === '') {
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Document path must be a non-empty string');
            }

            var path = ResourcePath.fromString(pathString);
            return DocumentReference.forPath(this._query.path.child(path), this.firestore);
        };

        CollectionReference.prototype.add = function (value) {
            validateExactNumberOfArgs('CollectionReference.add', arguments, 1);
            validateArgType('CollectionReference.add', 'object', 1, value);
            var docRef = this.doc();
            return docRef.set(value).then(function () {
                return docRef;
            });
        };

        return CollectionReference;
    }(Query$1);

    function validateSetOptions(methodName, options) {
        if (options === undefined) {
            return {
                merge: false
            };
        }

        validateOptionNames(methodName, options, ['merge', 'mergeFields']);
        validateNamedOptionalType(methodName, 'boolean', 'merge', options.merge);
        validateOptionalArrayElements(methodName, 'mergeFields', 'a string or a FieldPath', options.mergeFields, function (element) {
            return typeof element === 'string' || element instanceof FieldPath$1;
        });

        if (options.mergeFields !== undefined && options.merge !== undefined) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid options passed to function " + methodName + "(): You cannot specify both \"merge\" " + "and \"mergeFields\".");
        }

        return options;
    }

    function validateSnapshotOptions(methodName, options) {
        if (options === undefined) {
            return {};
        }

        validateOptionNames(methodName, options, ['serverTimestamps']);
        validateNamedOptionalPropertyEquals(methodName, 'options', 'serverTimestamps', options.serverTimestamps, ['estimate', 'previous', 'none']);
        return options;
    }

    function validateGetOptions(methodName, options) {
        validateOptionalArgType(methodName, 'object', 1, options);

        if (options) {
            validateOptionNames(methodName, options, ['source']);
            validateNamedOptionalPropertyEquals(methodName, 'options', 'source', options.source, ['default', 'server', 'cache']);
        }
    }

    function validateReference(methodName, documentRef, firestore) {
        if (!(documentRef instanceof DocumentReference)) {
            throw invalidClassError(methodName, 'DocumentReference', 1, documentRef);
        } else if (documentRef.firestore !== firestore) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Provided document reference is from a different Firestore instance.');
        } else {
            return documentRef;
        }
    }

    function changesFromSnapshot(firestore, includeMetadataChanges, snapshot) {
        if (snapshot.oldDocs.isEmpty()) {
            var lastDoc_1;
            var index_1 = 0;
            return snapshot.docChanges.map(function (change) {
                var doc = new QueryDocumentSnapshot(firestore, change.doc.key, change.doc, snapshot.fromCache, snapshot.mutatedKeys.has(change.doc.key));
                assert(change.type === ChangeType.Added, 'Invalid event type for first snapshot');
                assert(!lastDoc_1 || snapshot.query.docComparator(lastDoc_1, change.doc) < 0, 'Got added events in wrong order');
                lastDoc_1 = change.doc;
                return {
                    type: 'added',
                    doc: doc,
                    oldIndex: -1,
                    newIndex: index_1++
                };
            });
        } else {
            var indexTracker_1 = snapshot.oldDocs;
            return snapshot.docChanges.filter(function (change) {
                return includeMetadataChanges || change.type !== ChangeType.Metadata;
            }).map(function (change) {
                var doc = new QueryDocumentSnapshot(firestore, change.doc.key, change.doc, snapshot.fromCache, snapshot.mutatedKeys.has(change.doc.key));
                var oldIndex = -1;
                var newIndex = -1;

                if (change.type !== ChangeType.Added) {
                    oldIndex = indexTracker_1.indexOf(change.doc.key);
                    assert(oldIndex >= 0, 'Index for document not found');
                    indexTracker_1 = indexTracker_1.delete(change.doc.key);
                }

                if (change.type !== ChangeType.Removed) {
                    indexTracker_1 = indexTracker_1.add(change.doc);
                    newIndex = indexTracker_1.indexOf(change.doc.key);
                }

                return {
                    type: resultChangeType(change.type),
                    doc: doc,
                    oldIndex: oldIndex,
                    newIndex: newIndex
                };
            });
        }
    }

    function resultChangeType(type) {
        switch (type) {
            case ChangeType.Added:
                return 'added';

            case ChangeType.Modified:
            case ChangeType.Metadata:
                return 'modified';

            case ChangeType.Removed:
                return 'removed';

            default:
                return fail('Unknown change type: ' + type);
        }
    }

    var PublicFirestore = makeConstructorPrivate(Firestore, 'Use firebase.firestore() instead.');
    var PublicTransaction = makeConstructorPrivate(Transaction$1, 'Use firebase.firestore().runTransaction() instead.');
    var PublicWriteBatch = makeConstructorPrivate(WriteBatch, 'Use firebase.firestore().batch() instead.');
    var PublicDocumentReference = makeConstructorPrivate(DocumentReference, 'Use firebase.firestore().doc() instead.');
    var PublicDocumentSnapshot = makeConstructorPrivate(DocumentSnapshot);
    var PublicQueryDocumentSnapshot = makeConstructorPrivate(QueryDocumentSnapshot);
    var PublicQuery = makeConstructorPrivate(Query$1);
    var PublicQuerySnapshot = makeConstructorPrivate(QuerySnapshot);
    var PublicCollectionReference = makeConstructorPrivate(CollectionReference, 'Use firebase.firestore().collection() instead.');
    var firestoreNamespace = {
        Firestore: PublicFirestore,
        GeoPoint: GeoPoint,
        Timestamp: Timestamp,
        Blob: PublicBlob,
        Transaction: PublicTransaction,
        WriteBatch: PublicWriteBatch,
        DocumentReference: PublicDocumentReference,
        DocumentSnapshot: PublicDocumentSnapshot,
        Query: PublicQuery,
        QueryDocumentSnapshot: PublicQueryDocumentSnapshot,
        QuerySnapshot: PublicQuerySnapshot,
        CollectionReference: PublicCollectionReference,
        FieldPath: FieldPath$1,
        FieldValue: PublicFieldValue,
        setLogLevel: Firestore.setLogLevel
    };

    function configureForFirebase(firebase$$1) {
        firebase$$1.INTERNAL.registerService('firestore', function (app) {
            return new Firestore(app);
        }, shallowCopy(firestoreNamespace));
    }

    function registerFirestore(instance) {
        configureForFirebase(instance);
    }

    registerFirestore(firebase);
    exports.registerFirestore = registerFirestore;
});